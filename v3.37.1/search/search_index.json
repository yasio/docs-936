{"config":{"lang":["en","ja"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\\uff0c\\\u3002]+"},"docs":[{"location":"","text":"yasio \u4e2d\u6587\u6587\u6863 \u00b6 yasio \u662f\u4e00\u4e2a\u8f7b\u91cf\u7ea7\u8de8\u5e73\u53f0\u7684\u5f02\u6b65socket\u5e93\uff0c\u4e13\u6ce8\u4e8e\u5ba2\u6237\u7aef\u548c\u57fa\u4e8e\u5404\u79cd\u6e38\u620f\u5f15\u64ce\u7684\u6e38\u620f\u5ba2\u6237\u7aef\u7f51\u7edc\u670d\u52a1\u3002 \u6587\u6863\u8bed\u8a00: English \u7b80\u4f53\u4e2d\u6587 \u8de8\u5e73\u53f0\u6027: \u7f16\u8bd1\u5668: Visual Studio 2013+ GCC4.7+ xcode9+ \u5176\u4ed6\u652f\u6301 C++11,14,17 \u7684\u7f16\u8bd1\u5668 \u67b6\u6784: x86, x64, ARM\u7b49\u3002 \u64cd\u4f5c\u7cfb\u7edf: Windows, macOS, Linux, FreeBSD, iOS, Android\u7b49\u3002 \u672f\u8bed: \u7f51\u7edc\u670d\u52a1: io_service \u4fe1\u9053: io_channel \u4f20\u8f93\u4f1a\u8bdd: io_transport \u6846\u67b6\u56fe: \u5feb\u901f\u5f00\u59cb \u00b6 \u6b64\u5b9e\u4f8b\u7a0b\u5e8f\u7b80\u5355\u5411 tool.chinaz.com \u53d1\u9001http\u8bf7\u6c42\u5e76\u6253\u5370\u54cd\u5e94\u6570\u636e\u3002 C++ #include \"yasio/yasio.hpp\" #include \"yasio/obstream.hpp\" using namespace yasio ; using namespace yasio :: inet ; int main () { io_service service ({ \"tool.chinaz.com\" , 80 }); service . set_option ( YOPT_S_DEFERRED_EVENT , 0 ); // dispatch network event on network thread service . start ([ & ]( event_ptr && ev ) { switch ( ev -> kind ()) { case YEK_PACKET : { auto packet = std :: move ( ev -> packet ()); fwrite ( packet . data (), packet . size (), 1 , stdout ); fflush ( stdout ); break ; } case YEK_CONNECT_RESPONSE : if ( ev -> status () == 0 ) { auto transport = ev -> transport (); if ( ev -> cindex () == 0 ) { obstream obs ; obs . write_bytes ( \"GET /index.htm HTTP/1.1 \\r\\n \" ); obs . write_bytes ( \"Host: tool.chinaz.com \\r\\n \" ); obs . write_bytes ( \"User-Agent: Mozilla/5.0 (Windows NT 10.0; \" \"WOW64) AppleWebKit/537.36 (KHTML, like Gecko) \" \"Chrome/87.0.4820.88 Safari/537.36 \\r\\n \" ); obs . write_bytes ( \"Accept: */*;q=0.8 \\r\\n \" ); obs . write_bytes ( \"Connection: Close \\r\\n\\r\\n \" ); service . write ( transport , std :: move ( obs . buffer ())); } } break ; case YEK_CONNECTION_LOST : printf ( \"The connection is lost. \\n \" ); break ; } }); // open channel 0 as tcp client service . open ( 0 , YCK_TCP_CLIENT ); getchar (); } Lua local ip138 = \"tool.chinaz.com\" local service = yasio . io_service . new ({ host = ip138 , port = 80 }) local respdata = \"\" service : start ( function ( ev ) local k = ev . kind () if ( k == yasio . YEK_PACKET ) then respdata = respdata .. ev : packet (): to_string () elseif k == yasio . YEK_CONNECT_RESPONSE then if ev : status () == 0 then -- connect succeed local transport = ev : transport () local obs = yasio . obstream . new () obs : write_bytes ( \"GET / HTTP/1.1 \\r\\n \" ) obs : write_bytes ( \"Host: \" .. ip138 .. \" \\r\\n \" ) obs : write_bytes ( \"User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.117 Safari/537.36 \\r\\n \" ) obs : write_bytes ( \"Accept: */*;q=0.8 \\r\\n \" ) obs : write_bytes ( \"Connection: Close \\r\\n\\r\\n \" ) service : write ( transport , obs ) end elseif k == yasio . YEK_CONNECTION_LOST then print ( \"request finish, respdata: \" .. respdata ) end end ) -- Open channel 0 as tcp client and start non-blocking tcp 3 times handshake service : open ( 0 , yasio . YCK_TCP_CLIENT ) -- Call this function at thread which focus on the network event. function gDispatchNetworkEvent (...) service : dispatch ( 128 ) -- dispatch max events is 128 per frame end _G . yservice = service -- Store service to global table as a singleton instance \u6d4b\u8bd5 & \u793a\u4f8b \u00b6 \u6ce8\u610f \u8fd0\u884cLua\u793a\u4f8b\u7a0b\u5e8f\uff0c\u4f1a\u6253\u5370\u5f02\u5e38\u4fe1\u606f yasio - ibstream_view::consume out of range! \uff0c\u8fd9\u662f\u793a\u4f8b\u7a0b\u5e8f\u91cc\u6545\u610f\u5199\u7684\uff0c\u8bf7\u4e0d\u5fc5\u5728\u610f\u3002 \u6d4b\u8bd5: echo_server : TCP/UDP/KCP \u56de\u5c04\u670d\u52a1\u5668 echo_client : TCP/UDP/KCP \u56de\u5c04\u5ba2\u6237\u7aef ssltest : SSL\u6d4b\u8bd5\u5ba2\u6237\u7aef, \u8bf7\u6c42github.com\u4e3b\u9875\u5e76\u6253\u5370\u8fd4\u56de\u6570\u636e tcptest : TCP\u6d4b\u8bd5\u7a0b\u5e8f speedtest : TCP,UDP,KCP \u672c\u673a\u4f20\u8f93\u901f\u7387\u6d4b\u8bd5\u7a0b\u5e8f mcast : \u7ec4\u64ad\u6d4b\u8bd5\u7a0b\u5e8f \u793a\u4f8b: ftp_server : \u57fa\u4e8eyasio\u5b9e\u73b0\u7684\u4ec5\u652f\u6301\u4e0b\u8f7d\u7684ftp\u670d\u52a1\u5668\uff0c \u70b9\u51fb \u8bbf\u95ee\u3002 lua : Lua\u793a\u4f8b\u7a0b\u5e8f\uff0c\u5305\u542b\u7b80\u6613\u7684\u5e76\u53d1http\u8bf7\u6c42\uff0cTCP\u62c6\u5305\u53c2\u6570\u8bbe\u7f6e\u793a\u4f8b\u4ee3\u7801 xlua : xlua\u96c6\u6210\u6848\u4f8b DemoUE4 : UE4\u96c6\u6210\u6848\u4f8b \u7f16\u8bd1 \u6d4b\u8bd5 & \u793a\u4f8b \u00b6 \u786e\u4fdd\u5df2\u5b89\u88c5\u652f\u6301C++11\u6807\u51c6\u7684\u7f16\u8bd1\u5668\uff0c\u4f8b\u5982 msvc , gcc , clang \u786e\u4fdd\u5df2\u5b89\u88c5 git , cmake installed \u8fd0\u884c\u5982\u4e0b\u547d\u4ee4: git clone https://github.com/yasio/yasio cd yasio git submodule update --init --recursive cd build # for xcode should be: cmake .. -GXcode cmake .. cmake --build . --config Debug","title":"\u4e3b\u9875"},{"location":"#yasio","text":"yasio \u662f\u4e00\u4e2a\u8f7b\u91cf\u7ea7\u8de8\u5e73\u53f0\u7684\u5f02\u6b65socket\u5e93\uff0c\u4e13\u6ce8\u4e8e\u5ba2\u6237\u7aef\u548c\u57fa\u4e8e\u5404\u79cd\u6e38\u620f\u5f15\u64ce\u7684\u6e38\u620f\u5ba2\u6237\u7aef\u7f51\u7edc\u670d\u52a1\u3002 \u6587\u6863\u8bed\u8a00: English \u7b80\u4f53\u4e2d\u6587 \u8de8\u5e73\u53f0\u6027: \u7f16\u8bd1\u5668: Visual Studio 2013+ GCC4.7+ xcode9+ \u5176\u4ed6\u652f\u6301 C++11,14,17 \u7684\u7f16\u8bd1\u5668 \u67b6\u6784: x86, x64, ARM\u7b49\u3002 \u64cd\u4f5c\u7cfb\u7edf: Windows, macOS, Linux, FreeBSD, iOS, Android\u7b49\u3002 \u672f\u8bed: \u7f51\u7edc\u670d\u52a1: io_service \u4fe1\u9053: io_channel \u4f20\u8f93\u4f1a\u8bdd: io_transport \u6846\u67b6\u56fe:","title":"yasio \u4e2d\u6587\u6587\u6863"},{"location":"#_1","text":"\u6b64\u5b9e\u4f8b\u7a0b\u5e8f\u7b80\u5355\u5411 tool.chinaz.com \u53d1\u9001http\u8bf7\u6c42\u5e76\u6253\u5370\u54cd\u5e94\u6570\u636e\u3002 C++ #include \"yasio/yasio.hpp\" #include \"yasio/obstream.hpp\" using namespace yasio ; using namespace yasio :: inet ; int main () { io_service service ({ \"tool.chinaz.com\" , 80 }); service . set_option ( YOPT_S_DEFERRED_EVENT , 0 ); // dispatch network event on network thread service . start ([ & ]( event_ptr && ev ) { switch ( ev -> kind ()) { case YEK_PACKET : { auto packet = std :: move ( ev -> packet ()); fwrite ( packet . data (), packet . size (), 1 , stdout ); fflush ( stdout ); break ; } case YEK_CONNECT_RESPONSE : if ( ev -> status () == 0 ) { auto transport = ev -> transport (); if ( ev -> cindex () == 0 ) { obstream obs ; obs . write_bytes ( \"GET /index.htm HTTP/1.1 \\r\\n \" ); obs . write_bytes ( \"Host: tool.chinaz.com \\r\\n \" ); obs . write_bytes ( \"User-Agent: Mozilla/5.0 (Windows NT 10.0; \" \"WOW64) AppleWebKit/537.36 (KHTML, like Gecko) \" \"Chrome/87.0.4820.88 Safari/537.36 \\r\\n \" ); obs . write_bytes ( \"Accept: */*;q=0.8 \\r\\n \" ); obs . write_bytes ( \"Connection: Close \\r\\n\\r\\n \" ); service . write ( transport , std :: move ( obs . buffer ())); } } break ; case YEK_CONNECTION_LOST : printf ( \"The connection is lost. \\n \" ); break ; } }); // open channel 0 as tcp client service . open ( 0 , YCK_TCP_CLIENT ); getchar (); } Lua local ip138 = \"tool.chinaz.com\" local service = yasio . io_service . new ({ host = ip138 , port = 80 }) local respdata = \"\" service : start ( function ( ev ) local k = ev . kind () if ( k == yasio . YEK_PACKET ) then respdata = respdata .. ev : packet (): to_string () elseif k == yasio . YEK_CONNECT_RESPONSE then if ev : status () == 0 then -- connect succeed local transport = ev : transport () local obs = yasio . obstream . new () obs : write_bytes ( \"GET / HTTP/1.1 \\r\\n \" ) obs : write_bytes ( \"Host: \" .. ip138 .. \" \\r\\n \" ) obs : write_bytes ( \"User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.117 Safari/537.36 \\r\\n \" ) obs : write_bytes ( \"Accept: */*;q=0.8 \\r\\n \" ) obs : write_bytes ( \"Connection: Close \\r\\n\\r\\n \" ) service : write ( transport , obs ) end elseif k == yasio . YEK_CONNECTION_LOST then print ( \"request finish, respdata: \" .. respdata ) end end ) -- Open channel 0 as tcp client and start non-blocking tcp 3 times handshake service : open ( 0 , yasio . YCK_TCP_CLIENT ) -- Call this function at thread which focus on the network event. function gDispatchNetworkEvent (...) service : dispatch ( 128 ) -- dispatch max events is 128 per frame end _G . yservice = service -- Store service to global table as a singleton instance","title":"\u5feb\u901f\u5f00\u59cb"},{"location":"#_2","text":"\u6ce8\u610f \u8fd0\u884cLua\u793a\u4f8b\u7a0b\u5e8f\uff0c\u4f1a\u6253\u5370\u5f02\u5e38\u4fe1\u606f yasio - ibstream_view::consume out of range! \uff0c\u8fd9\u662f\u793a\u4f8b\u7a0b\u5e8f\u91cc\u6545\u610f\u5199\u7684\uff0c\u8bf7\u4e0d\u5fc5\u5728\u610f\u3002 \u6d4b\u8bd5: echo_server : TCP/UDP/KCP \u56de\u5c04\u670d\u52a1\u5668 echo_client : TCP/UDP/KCP \u56de\u5c04\u5ba2\u6237\u7aef ssltest : SSL\u6d4b\u8bd5\u5ba2\u6237\u7aef, \u8bf7\u6c42github.com\u4e3b\u9875\u5e76\u6253\u5370\u8fd4\u56de\u6570\u636e tcptest : TCP\u6d4b\u8bd5\u7a0b\u5e8f speedtest : TCP,UDP,KCP \u672c\u673a\u4f20\u8f93\u901f\u7387\u6d4b\u8bd5\u7a0b\u5e8f mcast : \u7ec4\u64ad\u6d4b\u8bd5\u7a0b\u5e8f \u793a\u4f8b: ftp_server : \u57fa\u4e8eyasio\u5b9e\u73b0\u7684\u4ec5\u652f\u6301\u4e0b\u8f7d\u7684ftp\u670d\u52a1\u5668\uff0c \u70b9\u51fb \u8bbf\u95ee\u3002 lua : Lua\u793a\u4f8b\u7a0b\u5e8f\uff0c\u5305\u542b\u7b80\u6613\u7684\u5e76\u53d1http\u8bf7\u6c42\uff0cTCP\u62c6\u5305\u53c2\u6570\u8bbe\u7f6e\u793a\u4f8b\u4ee3\u7801 xlua : xlua\u96c6\u6210\u6848\u4f8b DemoUE4 : UE4\u96c6\u6210\u6848\u4f8b","title":"\u6d4b\u8bd5 &amp; \u793a\u4f8b"},{"location":"#_3","text":"\u786e\u4fdd\u5df2\u5b89\u88c5\u652f\u6301C++11\u6807\u51c6\u7684\u7f16\u8bd1\u5668\uff0c\u4f8b\u5982 msvc , gcc , clang \u786e\u4fdd\u5df2\u5b89\u88c5 git , cmake installed \u8fd0\u884c\u5982\u4e0b\u547d\u4ee4: git clone https://github.com/yasio/yasio cd yasio git submodule update --init --recursive cd build # for xcode should be: cmake .. -GXcode cmake .. cmake --build . --config Debug","title":"\u7f16\u8bd1 \u6d4b\u8bd5 &amp; \u793a\u4f8b"},{"location":"faq/","text":"FAQ \u00b6 \u91cd\u70b9\u95ee\u9898\u89e3\u7b54 \u00b6 yasio\u662f\u5426\u4f9d\u8d56\u5176\u4ed6\u7f51\u7edc\u5e93? yasio\u7684\u6838\u5fc3\u4ee3\u7801\u9ed8\u8ba4\u4e0d\u4f9d\u8d56\u4efb\u4f55\u7b2c\u4e09\u65b9\u5e93\uff0c\u4ece\u4f5c\u8005\u4ece\u4e1a\u8e0f\u5165\u901a\u4fe1\u884c\u4e1a\u5f00\u59cb\u5c31\u7422\u78e8\u7740\u7f16\u5199\u4e00\u4e2a\u8f7b\u91cf\u800c\u597d\u7528\u7684\u901a\u7528\u7f51\u7edc\u5e93\uff0cxxsocket\u5c31\u662fyasio\u7684\u8d77\u6e90\uff0c\u53ea\u6709\u5f02\u6b65\u6d88\u606f\u53d1\u9001\u7684\u8f6f\u4e2d\u65ad\u5668\u63d0\u53d6\u4e8eboost.asio\u3002 \u4e3a\u4ec0\u4e48\u4f7f\u7528yasio? \u5f00\u6e90\u793e\u533a\u5df2\u77e5\u6bd4\u8f83\u6709\u540d\u7684\u7f51\u7edc\u5e93\u6709asio,libevent,libev,libuv\uff0c\u4ed6\u4eec\u63d0\u4f9b\u7684\u90fd\u662f\u975e\u5e38\u57fa\u7840\u7684\u975e\u963b\u585e\u591a\u8defio\u590d\u7528\u6a21\u578b\uff0c\u5e76\u4e14\uff0c\u5404\u5e73\u53f0\u5e95\u5c42\u4f1a\u4f7f\u7528iocp,kqueue,epoll,select\u7b49\u6a21\u578b\uff0c\u62ff\u6765\u505a\u5ba2\u6237\u7aef\u7f51\u7edc\uff0c\u5982\u8fde\u63a5\u7ba1\u7406\uff0cTCP\u7c98\u5305\u5904\u7406\u7b49\u90fd\u9700\u8981\u7a0b\u5e8f\u5458\u81ea\u5df1\u5904\u7406\u3002 yasio\u5c06\u8fde\u63a5\u7ba1\u7406\uff0cTCP\u62c6\u5305\u90fd\u5c01\u88c5\u5230\u4e86\u5e95\u5c42\u3002 yasio\u5c06TCP,UDP,KCP\u7edf\u4e00\u62bd\u8c61\u6210Transport\u66f4\u52a0\u65b9\u4fbf\u4f7f\u7528\u3002 yasio\u66f4\u8f7b\u91cf\u7ea7\uff0c\u6240\u6709\u5e73\u53f0\u5747\u4f7f\u7528select\u6a21\u578b\u3002 yasio\u662f\u5426\u652f\u6301\u975e\u963b\u585e\u57df\u540d\u89e3\u6790? \u652f\u6301\uff0c\u4f46\u9700\u8981\u4f9d\u8d56c-ares\u5e93\uff0c\u8fd9\u4e2a\u5e93\u662f\u5b8c\u5168\u5b9e\u73b0DNS\u534f\u8bae\uff0c\u5e76\u53ef\u4ee5\u5f88\u597d\u7684\u548c\u73b0\u6709select\u6a21\u578b\u7ed3\u5408\u4f7f\u7528\uff0c\u57df\u540d\u89e3\u6790\u65e0\u9700\u65b0\u5f00\u7ebf\u7a0b\u3002\u5982\u679c\u4e0d\u5f00\u542fc-ares\uff0cyasio\u5185\u90e8\u4f1a\u4e3a\u6bcf\u6b21\u57df\u540d\u89e3\u6790\u5f00\u7ebf\u7a0b\u3002\u4f46\u4f1a\u9ed8\u8ba4\u7f13\u5b5810\u5206\u949f\uff0c\u6240\u4ee5\u4e5f\u4e0d\u7528\u62c5\u5fc3\u5f00\u7ebf\u7a0b\u592a\u9891\u7e41\u3002 yasio\u662f\u5426\u652f\u6301SSL/TLS\u4f20\u8f93? \u652f\u6301\uff0c\u4f46\u9700\u8981\u4f9d\u8d56OpenSSL\u6216\u8005MbedTLS\u3002 \u5982\u4f55\u4ece io_event \u4e2d\u8bbe\u7f6e\u548c\u83b7\u53d6 userdata \u8bf7\u53c2\u8003\uff1a https://github.com/yasio/ftp_server/blob/master/ftp_server.cpp#L98 yasio\u662f\u5426\u5904\u7406 SIGPIPE \u4fe1\u53f7\uff1f \u4ece 3.30 \u7248\u672c\u5f00\u59cb\u5df2\u5904\u7406\u3002 \u5982\u679c\u4e0d\u5904\u7406\uff0c\u5b9e\u6d4b\u8fc7iOS\u5728\u52a0\u8f7d\u8d44\u6e90\u6bd4\u8f83\u8017\u65f6\u4f1a\u89e6\u53d1SIGPIPE\u76f4\u63a5\u5bfc\u81f4APP\u95ea\u9000\uff0c\u5904\u7406\u540e\uff0c\u4ec5\u4ec5\u89e6\u53d1TCP\u8fde\u63a5\u65ad\u5f00\uff0c\u9519\u8bef\u780132\uff0c\u9519\u8bef\u4fe1\u606f: Broken pipe \u8be6\u89c1: https://github.com/yasio/yasio/issues/170 \u5728iOS\u8bbe\u5907\u4e0a\u8fde\u63a5\u670d\u52a1\u5668\u7aef\u53e3\u53f7\u4e3a10161\u65f6\u5931\u8d25\uff0c\u9519\u8bef\u4fe1\u606f\uff1aec=65, detail:No route to host \u6839\u672c\u539f\u56e0: \u5f53APP\u521d\u6b21\u542f\u52a8\u65f6\uff0c\u5728ios14.1+\u8bbe\u5907\u4e0a\uff0c\u4f1a\u63d0\u793a\u8bf7\u6c42 Local Network Perssion \u6743\u9650\uff0c\u7528\u6237\u70b9\u62d2\u7edd\u3002 \u7aef\u53e3\u53f7 10161 \u65f6\u7cfb\u7edf\u4fdd\u7559\u7aef\u53e3\uff0c\u7528\u4e8e SNMP via TLS \u534f\u8bae\u3002 \u89e3\u51b3\u65b9\u6848: \u4f7f\u7528\u5176\u4ed6\u7aef\u53e3\u53f7\u4f5c\u4e3aAPP\u670d\u52a1\u7aef\u53e3\u3002 macOS \u4e0a\u53d1\u9001UDP\u5931\u8d25\uff0c\u62a5\u9519\u8bef\u780140\uff0c\u9519\u8bef\u4fe1\u606f Message too long \u600e\u4e48\u529e\uff1f \u539f\u56e0: \u6570\u636e\u5305\u592a\u5927\uff0cmacOS\u7cfb\u7edfUDP\u53d1\u9001\u7f13\u51b2\u533a\u9ed8\u8ba4\u4e3a 9126 \u5b57\u8282\u3002 \u89e3\u51b3\u65b9\u6848: \u901a\u8fc7socket\u9009\u9879\u5c06UDP\u53d1\u9001\u7f13\u51b2\u533a\u8bbe\u7f6e\u5927\u4e00\u70b9\uff0c\u4f8b\u5982: xxsocket\u63a5\u53e3\u8bbe\u7f6e\u65b9\u5f0f\u4e3a: sock_udp.set_optval(SOL_SOCKET, SO_SNDBUF, (int)65535); io_service\u8bbe\u7f6e\u65b9\u5f0f\u8bf7\u53c2\u89c1: https://github.com/yasio/yasio/blob/master/tests/speed/main.cpp#L223 io_service schedule \u53ef\u4ee5\u591a\u4e2a\u4efb\u52a1\u5417\uff1f \u53ef\u4ee5\u3002 std::thread \u5728\u67d0\u4e9b\u5d4c\u5165\u5f0f\u5e73\u53f0\u7f16\u8bd1\u5668\u95ea\u9000\u600e\u4e48\u529e\uff1f \u4fee\u6539\u7f16\u8bd1\u53c2\u6570\uff0c\u8be6\u89c1: https://github.com/yasio/yasio/issues/244 xxsocket \u51fd\u6570\u547d\u540d\u540e\u7f00_n\u548c_i\u7684\u610f\u601d\uff1f _n\u662fnonblock\u7684\u610f\u601d\uff0c_i\u662finternal(\u65b0\u7248\u672c\u5df2\u53bb\u9664)\u3002 \u8bbe\u7f6e\u4e86YOPT_TCP_KEEPALIVE\uff0c\u8fd8\u9700\u8981\u5e94\u7528\u5c42\u5fc3\u8df3\u5417\uff1f \u4e00\u822c\u4e0d\u9700\u8981\uff0c\u9664\u975e\u9700\u8981\u68c0\u6d4b\u7f51\u7edc\u5ef6\u65f6\u5c55\u793a\u7ed9\u7528\u6237\uff0c\u8be6\u89c1: https://github.com/yasio/yasio/issues/117 Lua\u7ed1\u5b9a\u95ea\u9000\u600e\u4e48\u529e\uff1f c++11: \u4f7f\u7528kaguya\u7ed1\u5b9a\u5e93\uff0c\u4f46\u8fd9\u4e2a\u5e93\u6709\u4e2a\u95ee\u9898\uff1a\u5728\u7ed1\u5b9ac++\u7c7b\u7684\u8fc7\u7a0b\u4e2d\uff0c\u6784\u9020c++\u5bf9\u8c61\u8fc7\u7a0b\u662f\u5148\u901a\u8fc7lua_newuserdata, \u518d\u901a\u8fc7 placement new \u6784\u9020\u5bf9\u8c61\uff0c\u5728xcode clang release\u4f18\u5316\u7f16\u8bd1\u4e0b\u4f1a\u76f4\u63a5\u95ea\u9000 \u7ecf\u8fc7bing.com\u641c\u7d22\uff0c\u53d1\u73b0\u53ef\u901a\u8fc7\u5b9a\u4e49 LUAI_USER_ALIGNMENT_T=max_align_t \u6765\u89e3\u51b3 \u7ecf\u8fc7\u6d4b\u8bd5, max_align_t\u5728xcode clang\u4e0b\u5b9a\u4e49\u4e3along double\u7c7b\u578b\uff0c\u957f\u5ea6\u4e3a16\u4e2a\u5b57\u8282 \u53c2\u8003: http://lua-users.org/lists/lua-l/2019-07/msg00197.html c++14: \u4f7f\u7528 sol2 \u7ed1\u5b9a\u5e93\uff0csol2\u53ef\u4ee5\u6210\u529f\u89e3\u51b3kaguya\u7684\u95ee\u9898\uff0c\u7ecf\u8fc7\u67e5\u770bsol2\u7684\u6e90\u7801\uff0c\u53d1\u73b0\u5176\u5728\u5185\u90e8\u5bf9lua_newuserdata\u8fd4\u56de\u7684\u5730\u5740\u505a\u4e86\u5bf9\u9f50\u5904\u7406\uff0c\u56e0\u6b64\u6210\u529f\u907f\u514d\u4e86clang release\u4f18\u5316\u5730\u5740\u4e0d\u5bf9\u9f50\u95ea\u9000\u95ee\u9898 c++17: \u540c\u6837\u4f7f\u7528 sol2 \u5e93\uff0c\u4f46xcode\u4f1a\u63d0\u793aios11\u4ee5\u4e0b\u4e0d\u652f\u6301C++17\u9ed8\u8ba4 new \u64cd\u4f5c\u7b26\u7684 Aligned allocation/deallocation \uff0c\u901a\u8fc7\u6dfb\u52a0\u7f16\u8bd1\u9009\u9879-faligned-allocation\u53ef\u901a\u8fc7\u7f16\u8bd1\uff1b ios10\u4ee5\u4e0b\u4e0d\u652f\u6301stl\u7684shared_mutex(yasio\u6700\u8fd1\u505a\u4e86\u517c\u5bb9\uff0c\u5bf9\u4e8eApple\u5e73\u53f0\u4e00\u5f8b\u4f7f\u7528pthread\u5b9e\u73b0) \u601d\u8003\uff1a Lua\u865a\u62df\u673a\u5b9e\u73b0\u4e2d\u9ed8\u8ba4\u6700\u5927\u5bf9\u9f50\u7c7b\u578b\u662fdouble\uff0c\u800c max_align_t \u7c7b\u578b\u662fC11\u6807\u51c6\u624d\u5f15\u5165\u7684\uff1a https://en.cppreference.com/w/c/types/max_align_t \uff0c\u56e0\u6b64Lua\u4f5c\u4e3aANSI C89\u6807\u51c6\u517c\u5bb9\u5b9e\u73b0\u5e76\u672a\u5b8c\u7f8e\u5904\u7406\u5404\u4e2a\u7f16\u8bd1\u5668\u5730\u5740\u5bf9\u9f50\u95ee\u9898\uff0c\u800c\u662f\u7559\u7ed9\u4e86\u7528\u6237\u5b9a\u4e49: LUAI_USER_ALIGNMENT_T \u5728C++11\u7f16\u8bd1\u7cfb\u7edf\u4e0b\u5df2\u7ecf\u5f15\u5165 std::max_align_t \u7c7b\u578b: https://en.cppreference.com/w/cpp/types/max_align_t \u91cd\u8981: max_align_t\u5404\u5e73\u53f0\u5b9a\u4e49\u8bf7\u67e5\u770bllvm\u9879\u76ee\u7684 __stddef_max_align_t.h Can't load xlua bundle on macOS? The file xlua.bundle needs change attr by command sudo xattr -r -d com.apple.quarantine xlua.bundle xxsocket\u7684resolve\u7cfb\u5217\u51fd\u6570socktype\u53c2\u6570\u4f5c\u7528\uff1f winsock\u5b9e\u73b0\u53ef\u4ee5\u5ffd\u7565 \u5176\u4ed6\u64cd\u4f5c\u7cfb\u7edf\u5982\u679c\u8bbe\u7f6e\u4e3a0\u4f1a\u8fd4\u56de\u591a\u4e2a\u5730\u5740\uff0c\u5373\u4f7f\u76f4\u63a5\u4f20IP\u3002 \u66f4\u591a\u5e38\u89c1\u95ee\u9898 \u00b6 \u8bf7\u53c2\u9605 \u9879\u76ee\u5e2e\u52a9\u53f0","title":"\u5e38\u89c1\u95ee\u9898"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#_1","text":"yasio\u662f\u5426\u4f9d\u8d56\u5176\u4ed6\u7f51\u7edc\u5e93? yasio\u7684\u6838\u5fc3\u4ee3\u7801\u9ed8\u8ba4\u4e0d\u4f9d\u8d56\u4efb\u4f55\u7b2c\u4e09\u65b9\u5e93\uff0c\u4ece\u4f5c\u8005\u4ece\u4e1a\u8e0f\u5165\u901a\u4fe1\u884c\u4e1a\u5f00\u59cb\u5c31\u7422\u78e8\u7740\u7f16\u5199\u4e00\u4e2a\u8f7b\u91cf\u800c\u597d\u7528\u7684\u901a\u7528\u7f51\u7edc\u5e93\uff0cxxsocket\u5c31\u662fyasio\u7684\u8d77\u6e90\uff0c\u53ea\u6709\u5f02\u6b65\u6d88\u606f\u53d1\u9001\u7684\u8f6f\u4e2d\u65ad\u5668\u63d0\u53d6\u4e8eboost.asio\u3002 \u4e3a\u4ec0\u4e48\u4f7f\u7528yasio? \u5f00\u6e90\u793e\u533a\u5df2\u77e5\u6bd4\u8f83\u6709\u540d\u7684\u7f51\u7edc\u5e93\u6709asio,libevent,libev,libuv\uff0c\u4ed6\u4eec\u63d0\u4f9b\u7684\u90fd\u662f\u975e\u5e38\u57fa\u7840\u7684\u975e\u963b\u585e\u591a\u8defio\u590d\u7528\u6a21\u578b\uff0c\u5e76\u4e14\uff0c\u5404\u5e73\u53f0\u5e95\u5c42\u4f1a\u4f7f\u7528iocp,kqueue,epoll,select\u7b49\u6a21\u578b\uff0c\u62ff\u6765\u505a\u5ba2\u6237\u7aef\u7f51\u7edc\uff0c\u5982\u8fde\u63a5\u7ba1\u7406\uff0cTCP\u7c98\u5305\u5904\u7406\u7b49\u90fd\u9700\u8981\u7a0b\u5e8f\u5458\u81ea\u5df1\u5904\u7406\u3002 yasio\u5c06\u8fde\u63a5\u7ba1\u7406\uff0cTCP\u62c6\u5305\u90fd\u5c01\u88c5\u5230\u4e86\u5e95\u5c42\u3002 yasio\u5c06TCP,UDP,KCP\u7edf\u4e00\u62bd\u8c61\u6210Transport\u66f4\u52a0\u65b9\u4fbf\u4f7f\u7528\u3002 yasio\u66f4\u8f7b\u91cf\u7ea7\uff0c\u6240\u6709\u5e73\u53f0\u5747\u4f7f\u7528select\u6a21\u578b\u3002 yasio\u662f\u5426\u652f\u6301\u975e\u963b\u585e\u57df\u540d\u89e3\u6790? \u652f\u6301\uff0c\u4f46\u9700\u8981\u4f9d\u8d56c-ares\u5e93\uff0c\u8fd9\u4e2a\u5e93\u662f\u5b8c\u5168\u5b9e\u73b0DNS\u534f\u8bae\uff0c\u5e76\u53ef\u4ee5\u5f88\u597d\u7684\u548c\u73b0\u6709select\u6a21\u578b\u7ed3\u5408\u4f7f\u7528\uff0c\u57df\u540d\u89e3\u6790\u65e0\u9700\u65b0\u5f00\u7ebf\u7a0b\u3002\u5982\u679c\u4e0d\u5f00\u542fc-ares\uff0cyasio\u5185\u90e8\u4f1a\u4e3a\u6bcf\u6b21\u57df\u540d\u89e3\u6790\u5f00\u7ebf\u7a0b\u3002\u4f46\u4f1a\u9ed8\u8ba4\u7f13\u5b5810\u5206\u949f\uff0c\u6240\u4ee5\u4e5f\u4e0d\u7528\u62c5\u5fc3\u5f00\u7ebf\u7a0b\u592a\u9891\u7e41\u3002 yasio\u662f\u5426\u652f\u6301SSL/TLS\u4f20\u8f93? \u652f\u6301\uff0c\u4f46\u9700\u8981\u4f9d\u8d56OpenSSL\u6216\u8005MbedTLS\u3002 \u5982\u4f55\u4ece io_event \u4e2d\u8bbe\u7f6e\u548c\u83b7\u53d6 userdata \u8bf7\u53c2\u8003\uff1a https://github.com/yasio/ftp_server/blob/master/ftp_server.cpp#L98 yasio\u662f\u5426\u5904\u7406 SIGPIPE \u4fe1\u53f7\uff1f \u4ece 3.30 \u7248\u672c\u5f00\u59cb\u5df2\u5904\u7406\u3002 \u5982\u679c\u4e0d\u5904\u7406\uff0c\u5b9e\u6d4b\u8fc7iOS\u5728\u52a0\u8f7d\u8d44\u6e90\u6bd4\u8f83\u8017\u65f6\u4f1a\u89e6\u53d1SIGPIPE\u76f4\u63a5\u5bfc\u81f4APP\u95ea\u9000\uff0c\u5904\u7406\u540e\uff0c\u4ec5\u4ec5\u89e6\u53d1TCP\u8fde\u63a5\u65ad\u5f00\uff0c\u9519\u8bef\u780132\uff0c\u9519\u8bef\u4fe1\u606f: Broken pipe \u8be6\u89c1: https://github.com/yasio/yasio/issues/170 \u5728iOS\u8bbe\u5907\u4e0a\u8fde\u63a5\u670d\u52a1\u5668\u7aef\u53e3\u53f7\u4e3a10161\u65f6\u5931\u8d25\uff0c\u9519\u8bef\u4fe1\u606f\uff1aec=65, detail:No route to host \u6839\u672c\u539f\u56e0: \u5f53APP\u521d\u6b21\u542f\u52a8\u65f6\uff0c\u5728ios14.1+\u8bbe\u5907\u4e0a\uff0c\u4f1a\u63d0\u793a\u8bf7\u6c42 Local Network Perssion \u6743\u9650\uff0c\u7528\u6237\u70b9\u62d2\u7edd\u3002 \u7aef\u53e3\u53f7 10161 \u65f6\u7cfb\u7edf\u4fdd\u7559\u7aef\u53e3\uff0c\u7528\u4e8e SNMP via TLS \u534f\u8bae\u3002 \u89e3\u51b3\u65b9\u6848: \u4f7f\u7528\u5176\u4ed6\u7aef\u53e3\u53f7\u4f5c\u4e3aAPP\u670d\u52a1\u7aef\u53e3\u3002 macOS \u4e0a\u53d1\u9001UDP\u5931\u8d25\uff0c\u62a5\u9519\u8bef\u780140\uff0c\u9519\u8bef\u4fe1\u606f Message too long \u600e\u4e48\u529e\uff1f \u539f\u56e0: \u6570\u636e\u5305\u592a\u5927\uff0cmacOS\u7cfb\u7edfUDP\u53d1\u9001\u7f13\u51b2\u533a\u9ed8\u8ba4\u4e3a 9126 \u5b57\u8282\u3002 \u89e3\u51b3\u65b9\u6848: \u901a\u8fc7socket\u9009\u9879\u5c06UDP\u53d1\u9001\u7f13\u51b2\u533a\u8bbe\u7f6e\u5927\u4e00\u70b9\uff0c\u4f8b\u5982: xxsocket\u63a5\u53e3\u8bbe\u7f6e\u65b9\u5f0f\u4e3a: sock_udp.set_optval(SOL_SOCKET, SO_SNDBUF, (int)65535); io_service\u8bbe\u7f6e\u65b9\u5f0f\u8bf7\u53c2\u89c1: https://github.com/yasio/yasio/blob/master/tests/speed/main.cpp#L223 io_service schedule \u53ef\u4ee5\u591a\u4e2a\u4efb\u52a1\u5417\uff1f \u53ef\u4ee5\u3002 std::thread \u5728\u67d0\u4e9b\u5d4c\u5165\u5f0f\u5e73\u53f0\u7f16\u8bd1\u5668\u95ea\u9000\u600e\u4e48\u529e\uff1f \u4fee\u6539\u7f16\u8bd1\u53c2\u6570\uff0c\u8be6\u89c1: https://github.com/yasio/yasio/issues/244 xxsocket \u51fd\u6570\u547d\u540d\u540e\u7f00_n\u548c_i\u7684\u610f\u601d\uff1f _n\u662fnonblock\u7684\u610f\u601d\uff0c_i\u662finternal(\u65b0\u7248\u672c\u5df2\u53bb\u9664)\u3002 \u8bbe\u7f6e\u4e86YOPT_TCP_KEEPALIVE\uff0c\u8fd8\u9700\u8981\u5e94\u7528\u5c42\u5fc3\u8df3\u5417\uff1f \u4e00\u822c\u4e0d\u9700\u8981\uff0c\u9664\u975e\u9700\u8981\u68c0\u6d4b\u7f51\u7edc\u5ef6\u65f6\u5c55\u793a\u7ed9\u7528\u6237\uff0c\u8be6\u89c1: https://github.com/yasio/yasio/issues/117 Lua\u7ed1\u5b9a\u95ea\u9000\u600e\u4e48\u529e\uff1f c++11: \u4f7f\u7528kaguya\u7ed1\u5b9a\u5e93\uff0c\u4f46\u8fd9\u4e2a\u5e93\u6709\u4e2a\u95ee\u9898\uff1a\u5728\u7ed1\u5b9ac++\u7c7b\u7684\u8fc7\u7a0b\u4e2d\uff0c\u6784\u9020c++\u5bf9\u8c61\u8fc7\u7a0b\u662f\u5148\u901a\u8fc7lua_newuserdata, \u518d\u901a\u8fc7 placement new \u6784\u9020\u5bf9\u8c61\uff0c\u5728xcode clang release\u4f18\u5316\u7f16\u8bd1\u4e0b\u4f1a\u76f4\u63a5\u95ea\u9000 \u7ecf\u8fc7bing.com\u641c\u7d22\uff0c\u53d1\u73b0\u53ef\u901a\u8fc7\u5b9a\u4e49 LUAI_USER_ALIGNMENT_T=max_align_t \u6765\u89e3\u51b3 \u7ecf\u8fc7\u6d4b\u8bd5, max_align_t\u5728xcode clang\u4e0b\u5b9a\u4e49\u4e3along double\u7c7b\u578b\uff0c\u957f\u5ea6\u4e3a16\u4e2a\u5b57\u8282 \u53c2\u8003: http://lua-users.org/lists/lua-l/2019-07/msg00197.html c++14: \u4f7f\u7528 sol2 \u7ed1\u5b9a\u5e93\uff0csol2\u53ef\u4ee5\u6210\u529f\u89e3\u51b3kaguya\u7684\u95ee\u9898\uff0c\u7ecf\u8fc7\u67e5\u770bsol2\u7684\u6e90\u7801\uff0c\u53d1\u73b0\u5176\u5728\u5185\u90e8\u5bf9lua_newuserdata\u8fd4\u56de\u7684\u5730\u5740\u505a\u4e86\u5bf9\u9f50\u5904\u7406\uff0c\u56e0\u6b64\u6210\u529f\u907f\u514d\u4e86clang release\u4f18\u5316\u5730\u5740\u4e0d\u5bf9\u9f50\u95ea\u9000\u95ee\u9898 c++17: \u540c\u6837\u4f7f\u7528 sol2 \u5e93\uff0c\u4f46xcode\u4f1a\u63d0\u793aios11\u4ee5\u4e0b\u4e0d\u652f\u6301C++17\u9ed8\u8ba4 new \u64cd\u4f5c\u7b26\u7684 Aligned allocation/deallocation \uff0c\u901a\u8fc7\u6dfb\u52a0\u7f16\u8bd1\u9009\u9879-faligned-allocation\u53ef\u901a\u8fc7\u7f16\u8bd1\uff1b ios10\u4ee5\u4e0b\u4e0d\u652f\u6301stl\u7684shared_mutex(yasio\u6700\u8fd1\u505a\u4e86\u517c\u5bb9\uff0c\u5bf9\u4e8eApple\u5e73\u53f0\u4e00\u5f8b\u4f7f\u7528pthread\u5b9e\u73b0) \u601d\u8003\uff1a Lua\u865a\u62df\u673a\u5b9e\u73b0\u4e2d\u9ed8\u8ba4\u6700\u5927\u5bf9\u9f50\u7c7b\u578b\u662fdouble\uff0c\u800c max_align_t \u7c7b\u578b\u662fC11\u6807\u51c6\u624d\u5f15\u5165\u7684\uff1a https://en.cppreference.com/w/c/types/max_align_t \uff0c\u56e0\u6b64Lua\u4f5c\u4e3aANSI C89\u6807\u51c6\u517c\u5bb9\u5b9e\u73b0\u5e76\u672a\u5b8c\u7f8e\u5904\u7406\u5404\u4e2a\u7f16\u8bd1\u5668\u5730\u5740\u5bf9\u9f50\u95ee\u9898\uff0c\u800c\u662f\u7559\u7ed9\u4e86\u7528\u6237\u5b9a\u4e49: LUAI_USER_ALIGNMENT_T \u5728C++11\u7f16\u8bd1\u7cfb\u7edf\u4e0b\u5df2\u7ecf\u5f15\u5165 std::max_align_t \u7c7b\u578b: https://en.cppreference.com/w/cpp/types/max_align_t \u91cd\u8981: max_align_t\u5404\u5e73\u53f0\u5b9a\u4e49\u8bf7\u67e5\u770bllvm\u9879\u76ee\u7684 __stddef_max_align_t.h Can't load xlua bundle on macOS? The file xlua.bundle needs change attr by command sudo xattr -r -d com.apple.quarantine xlua.bundle xxsocket\u7684resolve\u7cfb\u5217\u51fd\u6570socktype\u53c2\u6570\u4f5c\u7528\uff1f winsock\u5b9e\u73b0\u53ef\u4ee5\u5ffd\u7565 \u5176\u4ed6\u64cd\u4f5c\u7cfb\u7edf\u5982\u679c\u8bbe\u7f6e\u4e3a0\u4f1a\u8fd4\u56de\u591a\u4e2a\u5730\u5740\uff0c\u5373\u4f7f\u76f4\u63a5\u4f20IP\u3002","title":"\u91cd\u70b9\u95ee\u9898\u89e3\u7b54"},{"location":"faq/#_2","text":"\u8bf7\u53c2\u9605 \u9879\u76ee\u5e2e\u52a9\u53f0","title":"\u66f4\u591a\u5e38\u89c1\u95ee\u9898"},{"location":"interop/","text":"yasio Interop \u00b6 \u4e3a\u4e86\u652f\u6301Unity C#\uff0c yasio\u63d0\u4f9b\u4e86C\u8bed\u8a00\u63a5\u53e3\u5bfc\u51fa\uff0c\u8be6\u89c1: https://github.com/yasio/yasio/blob/master/yasio/bindings/yasio_ni.cpp OpenNSM2 \u00b6 \u6700\u8fd1\u5f00\u653e\u4e86Unity \u57fa\u4e8eyasio-3.37.1\u6700\u65b0\u7248\u672c\u7684NetworkServiceManager\u53ef\u4ee5\u66f4\u65b9\u4fbf\u5730\u5728unity\u4e2d\u4f7f\u7528\uff0c\u8be6\u89c1: https://github.com/yasio/OpenNSM2","title":"Interop"},{"location":"interop/#yasio-interop","text":"\u4e3a\u4e86\u652f\u6301Unity C#\uff0c yasio\u63d0\u4f9b\u4e86C\u8bed\u8a00\u63a5\u53e3\u5bfc\u51fa\uff0c\u8be6\u89c1: https://github.com/yasio/yasio/blob/master/yasio/bindings/yasio_ni.cpp","title":"yasio Interop"},{"location":"interop/#opennsm2","text":"\u6700\u8fd1\u5f00\u653e\u4e86Unity \u57fa\u4e8eyasio-3.37.1\u6700\u65b0\u7248\u672c\u7684NetworkServiceManager\u53ef\u4ee5\u66f4\u65b9\u4fbf\u5730\u5728unity\u4e2d\u4f7f\u7528\uff0c\u8be6\u89c1: https://github.com/yasio/OpenNSM2","title":"OpenNSM2"},{"location":"preprocessor/","text":"yasio \u5b8f\u5b9a\u4e49 \u00b6 \u4ee5\u4e0b\u5b8f\u5b9a\u4e49\u53ef\u4ee5\u63a7\u5236 yasio \u5e93\u7684\u67d0\u4e9b\u884c\u4e3a\uff0c\u53ef\u4ee5\u5728 yasio/detail/config.hpp \u5b9a\u4e49\u6216\u8005\u5728\u7f16\u8bd1\u5668\u9884\u5904\u7406\u5668\u5b9a\u4e49 Name Description YASIO_HAVE_KCP \u662f\u5426\u542f\u7528kcp\u4f20\u8f93\u652f\u6301\uff0c\u9700\u8981kcp\u5df2\u7ecf\u5728\u8f6f\u4ef6\u7f16\u8bd1\u7cfb\u7edf\u4e2d\uff0c\u9ed8\u8ba4\u5173\u95ed\u3002 YASIO_HEADER_ONLY \u662f\u5426\u4ee5\u4ec5\u5934\u6587\u4ef6\u7684\u65b9\u5f0f\u4f7f\u7528yasio\u6838\u5fc3\u7ec4\u4ef6\uff0c\u9ed8\u8ba4\u5173\u95ed\u3002 YASIO_SSL_BACKEND \u9009\u62e9SSL\u5e93\u4ee5\u652f\u6301SSL\u5ba2\u6237\u7aef\uff0c\u9700\u8981\u8f6f\u4ef6\u7f16\u8bd1\u7cfb\u7edf\u5305\u542bOpenSSL/MbedTLS\u5e93\uff0c 3.36.0\u65b0\u589e(\u540c\u65f6\u79fb\u9664YASIO_HAVE_SSL)\uff0c\u6b64\u5b8f\u53ea\u80fd\u53d6\u503c 1 (\u4f7f\u7528OpenSSL) \u6216\u8005 2 (\u4f7f\u7528mbedtls)\u3002 YASIO_ENABLE_UDS \u662f\u5426\u542f\u7528unix domain socket\u652f\u6301\uff0c\u76ee\u524d\u4ec5\u7c7bunix\u7cfb\u7edf\u548cwin10 RS5+\u652f\u6301\uff0c\u9ed8\u8ba4\u5173\u95ed\u3002 YASIO_HAVE_CARES \u662f\u5426\u542f\u7528c-ares\u5f02\u6b65\u57df\u540d\u89e3\u6790\u5e93\uff0c \u5f53\u7f16\u8bd1\u7cfb\u7edf\u5305\u542bc-ares\u65f6\u53ef\u542f\u7528\uff0c\u6709\u6548\u907f\u514d\u6bcf\u6b21\u89e3\u6790\u57df\u540d\u90fd\u65b0\u5f00\u7ebf\u7a0b\u3002 yasio\u6709DNS\u7f13\u5b58\u673a\u5236\uff0c\u8d85\u65f6\u65f6\u95f4\u9ed8\u8ba410\u5206\u949f\uff0c \u56e0\u6b64\u65e0c-ares\u4e5f\u4e0d\u4f1a\u9020\u6210\u592a\u5927\u7684\u6027\u80fd\u635f\u8017\u3002 YASIO_VERBOSE_LOG \u662f\u5426\u6253\u5370\u8be6\u7ec6\u65e5\u5fd7\uff0c\u9ed8\u8ba4\u5173\u95ed\u3002 YASIO_NT_COMPAT_GAI \u662f\u5426\u542f\u7528Windows XP\u7cfb\u7edf\u4e0b\u4f7f\u7528 getaddrinfo API\u652f\u6301\u3002 YASIO_USE_SPSC_QUEUE \u662f\u5426\u4f7f\u7528SPSC(\u5355\u751f\u4ea7\u8005\u5355\u6d88\u8d39\u8005)\u961f\u5217\uff0c \u4ec5\u5f53\u53ea\u6709\u4e00\u4e2a\u7ebf\u7a0b\u8c03\u7528io_service::write\u65f6\u653e\u53ef\u542f\u7528\uff0c\u9ed8\u8ba4\u5173\u95ed\u3002 YASIO_HAVE_HALF_FLOAT \u662f\u5426\u542f\u7528\u534a\u7cbe\u5ea6\u6d6e\u70b9\u6570\u652f\u6301\uff0c\u4f9d\u8d56 half.hpp \u3002 YASIO_DISABLE_OBJECT_POOL \u662f\u5426\u7981\u7528\u5bf9\u8c61\u6c60\u7684\u4f7f\u7528\uff0c\u9ed8\u8ba4\u542f\u7528\u3002 YASIO_DISABLE_CONCURRENT_SINGLETON \u662f\u5426\u7981\u7528\u5e76\u53d1\u5355\u5229\u7c7b\u6a21\u677f\u3002","title":"\u9884\u5904\u7406\u5668"},{"location":"preprocessor/#yasio","text":"\u4ee5\u4e0b\u5b8f\u5b9a\u4e49\u53ef\u4ee5\u63a7\u5236 yasio \u5e93\u7684\u67d0\u4e9b\u884c\u4e3a\uff0c\u53ef\u4ee5\u5728 yasio/detail/config.hpp \u5b9a\u4e49\u6216\u8005\u5728\u7f16\u8bd1\u5668\u9884\u5904\u7406\u5668\u5b9a\u4e49 Name Description YASIO_HAVE_KCP \u662f\u5426\u542f\u7528kcp\u4f20\u8f93\u652f\u6301\uff0c\u9700\u8981kcp\u5df2\u7ecf\u5728\u8f6f\u4ef6\u7f16\u8bd1\u7cfb\u7edf\u4e2d\uff0c\u9ed8\u8ba4\u5173\u95ed\u3002 YASIO_HEADER_ONLY \u662f\u5426\u4ee5\u4ec5\u5934\u6587\u4ef6\u7684\u65b9\u5f0f\u4f7f\u7528yasio\u6838\u5fc3\u7ec4\u4ef6\uff0c\u9ed8\u8ba4\u5173\u95ed\u3002 YASIO_SSL_BACKEND \u9009\u62e9SSL\u5e93\u4ee5\u652f\u6301SSL\u5ba2\u6237\u7aef\uff0c\u9700\u8981\u8f6f\u4ef6\u7f16\u8bd1\u7cfb\u7edf\u5305\u542bOpenSSL/MbedTLS\u5e93\uff0c 3.36.0\u65b0\u589e(\u540c\u65f6\u79fb\u9664YASIO_HAVE_SSL)\uff0c\u6b64\u5b8f\u53ea\u80fd\u53d6\u503c 1 (\u4f7f\u7528OpenSSL) \u6216\u8005 2 (\u4f7f\u7528mbedtls)\u3002 YASIO_ENABLE_UDS \u662f\u5426\u542f\u7528unix domain socket\u652f\u6301\uff0c\u76ee\u524d\u4ec5\u7c7bunix\u7cfb\u7edf\u548cwin10 RS5+\u652f\u6301\uff0c\u9ed8\u8ba4\u5173\u95ed\u3002 YASIO_HAVE_CARES \u662f\u5426\u542f\u7528c-ares\u5f02\u6b65\u57df\u540d\u89e3\u6790\u5e93\uff0c \u5f53\u7f16\u8bd1\u7cfb\u7edf\u5305\u542bc-ares\u65f6\u53ef\u542f\u7528\uff0c\u6709\u6548\u907f\u514d\u6bcf\u6b21\u89e3\u6790\u57df\u540d\u90fd\u65b0\u5f00\u7ebf\u7a0b\u3002 yasio\u6709DNS\u7f13\u5b58\u673a\u5236\uff0c\u8d85\u65f6\u65f6\u95f4\u9ed8\u8ba410\u5206\u949f\uff0c \u56e0\u6b64\u65e0c-ares\u4e5f\u4e0d\u4f1a\u9020\u6210\u592a\u5927\u7684\u6027\u80fd\u635f\u8017\u3002 YASIO_VERBOSE_LOG \u662f\u5426\u6253\u5370\u8be6\u7ec6\u65e5\u5fd7\uff0c\u9ed8\u8ba4\u5173\u95ed\u3002 YASIO_NT_COMPAT_GAI \u662f\u5426\u542f\u7528Windows XP\u7cfb\u7edf\u4e0b\u4f7f\u7528 getaddrinfo API\u652f\u6301\u3002 YASIO_USE_SPSC_QUEUE \u662f\u5426\u4f7f\u7528SPSC(\u5355\u751f\u4ea7\u8005\u5355\u6d88\u8d39\u8005)\u961f\u5217\uff0c \u4ec5\u5f53\u53ea\u6709\u4e00\u4e2a\u7ebf\u7a0b\u8c03\u7528io_service::write\u65f6\u653e\u53ef\u542f\u7528\uff0c\u9ed8\u8ba4\u5173\u95ed\u3002 YASIO_HAVE_HALF_FLOAT \u662f\u5426\u542f\u7528\u534a\u7cbe\u5ea6\u6d6e\u70b9\u6570\u652f\u6301\uff0c\u4f9d\u8d56 half.hpp \u3002 YASIO_DISABLE_OBJECT_POOL \u662f\u5426\u7981\u7528\u5bf9\u8c61\u6c60\u7684\u4f7f\u7528\uff0c\u9ed8\u8ba4\u542f\u7528\u3002 YASIO_DISABLE_CONCURRENT_SINGLETON \u662f\u5426\u7981\u7528\u5e76\u53d1\u5355\u5229\u7c7b\u6a21\u677f\u3002","title":"yasio \u5b8f\u5b9a\u4e49"},{"location":"unpacking/","text":"yasio \u7c98\u5305\u5904\u7406 \u00b6 yasio\u7684\u7c98\u5305\u5904\u7406\u4e0d\u4ec5\u9488\u5bf9TCP\uff0c\u5bf9\u4e8eUDP\uff0c\u5982\u679c\u53d1\u9001\u7aef\u6709\u7ec4\u5305\u53d1\u9001\u673a\u5236\uff0c\u4e5f\u662f\u4ee5\u76f8\u540c\u7684\u65b9\u5f0f\u5904\u7406\u3002\u6574\u4f53\u6765\u8bb2\u6709\u4e24\u79cd\u65b9\u5f0f: \u901a\u8fc7io_service\u9009\u9879 YOPT_C_LFBFD_PARAMS \u8bbe\u7f6e\u4fe1\u9053\u53c2\u6570\u3002 \u901a\u8fc7io_service\u9009\u9879 YOPT_C_LFBFD_FN \u8bbe\u7f6e\u81ea\u5b9a\u4e49\u5305\u957f\u5ea6\u89e3\u7801\u51fd\u6570 decode_len_fn_t \u3002 \u6ce8\u610f \u81ea\u5b9a\u4e49\u89e3\u7801\u5305\u957f\u5ea6\u51fd\u6570\u5b9e\u73b0\u65f6\uff0c\u5f53\u4ece\u5b57\u8282\u6d41\u4e2d\u8bfb\u53d6int\u503c\u65f6\uff0c\u4e00\u5b9a\u4e0d\u8981\u4f7f\u7528\u6307\u9488\u5f3a\u8f6c\uff0c\u5426\u5219\u53ef\u80fd\u89e6\u53d1ARM\u82af\u7247\u5b57\u8282\u5bf9\u9f50\u95ee\u9898 SIGBUS \u5f02\u5e38\u95ea\u9000\u3002\u53ef\u4ee5\u53c2\u8003\u5185\u7f6e\u89e3\u7801\u5305\u957f\u5ea6\u51fd\u6570\u5b9e\u73b0 io_channel::__builtin_decode_len \u3002 YOPT_C_LFBFD_PARAMS \u00b6 \u8bbe\u7f6e\u4fe1\u9053\u62c6\u5305\u53c2\u6570\u3002 \u53c2\u6570 \u00b6 max_frame_length \u6700\u5927\u5305\u957f\u5ea6\uff0c\u8d85\u8fc7\u5c06\u89c6\u4e3a\u5f02\u5e38\u5305\u3002 length_field_offset \u5305\u957f\u5ea6\u5b57\u6bb5\u76f8\u5bf9\u4e8e\u6d88\u606f\u5305\u6570\u636e\u9996\u5b57\u8282\u504f\u79fb\u3002 length_field_length \u5305\u957f\u5ea6\u5b57\u6bb5\u5927\u5c0f\uff0c\u652f\u63011~4\u5b57\u8282\u6574\u6570( uint8_t,uint16_t,uint24_t,int32_t )\u3002 length_adjustment \u5305\u957f\u5ea6\u8c03\u6574\u503c\u3002\u901a\u5e38\u5e94\u7528\u5c42\u4e8c\u8fdb\u5236\u534f\u8bae\u90fd\u4f1a\u8bbe\u8ba1\u6d88\u606f\u5934\u548c\u6d88\u606f\u4f53\uff0c\u5f53\u957f\u5ea6\u5b57\u6bb5\u503c\u5305\u542b\u6d88\u606f\u5934\u65f6\uff0c\u5219\u6b64\u503c\u4e3a 0 \uff0c\u5426\u5219\u4e3a \u6d88\u606f\u5934\u957f\u5ea6 \u3002 \u6ce8\u610f \u00b6 \u6d88\u606f\u5305\u957f\u5ea6\u5b57\u6bb5\u5fc5\u987b\u4f7f\u7528\u7f51\u7edc\u5b57\u8282\u5e8f\u7f16\u7801\u3002\u8bf7\u67e5\u770b\u5185\u7f6e\u89e3\u7801\u5305\u957f\u5ea6\u5b9e\u73b0: int io_channel::__builtin_decode_len ( void * d , int n ) { int loffset = uparams_ . length_field_offset ; int lsize = uparams_ . length_field_length ; if ( loffset >= 0 ) { int len = 0 ; if ( n >= ( loffset + lsize )) { :: memcpy ( & len , ( uint8_t * ) d + loffset , lsize ); len = yasio :: network_to_host ( len , lsize ); len += uparams_ . length_adjustment ; if ( len > uparams_ . max_frame_length ) len = -1 ; } return len ; } return n ; } decode_len_fn_t \u00b6 \u4fe1\u9053\u89e3\u7801\u6d88\u606f\u5305\u957f\u5ea6\u51fd\u6570\u539f\u578b\u3002 typedef std :: function < int ( void * d , int n ) > decode_len_fn_t ; \u53c2\u6570 \u00b6 d \u5f85\u89e3\u5305\u6570\u636e\u9996\u5b57\u8282\u5730\u5740\u3002 n \u5f85\u89e3\u5305\u6570\u636e\u957f\u5ea6\u3002 \u8fd4\u56de\u503c \u00b6 \u8fd4\u56de\u6d88\u606f\u5305\u6570\u636e\u5b9e\u9645\u957f\u5ea6\u3002 > 0 : \u89e3\u7801\u5305\u957f\u5ea6\u6210\u529f\u3002 == 0 : \u63a5\u6536\u6570\u636e\u4e0d\u8db3\u4ee5\u89e3\u7801\u6d88\u606f\u5305\u5b9e\u9645\u957f\u5ea6\uff0cyasio\u5e95\u5c42\u4f1a\u7ee7\u7eed\u63a5\u6536\u6570\u636e\uff0c\u4e00\u65e6\u6536\u5230\u65b0\u6570\u636e\uff0c\u4f1a\u518d\u6b21\u8c03\u7528\u6b64\u51fd\u6570\u3002 < 0 : \u89e3\u7801\u5305\u957f\u5ea6\u5f02\u5e38\uff0c\u4f1a\u89e6\u53d1\u5f53\u524d\u4f20\u8f93\u4f1a\u8bdd\u65ad\u5f00\u3002 \u6ce8\u610f \u00b6 \u89e3\u7801\u6d88\u606f\u5305\u957f\u5ea6\u51fd\u6570\u5fc5\u987b\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\uff0c\u4f8b\u5982\u5bf9\u4e8eLua\u5219\u4e0d\u652f\u6301\u8bbe\u7f6e\u81ea\u5b9a\u4e49\u89e3\u7801\u6d88\u606f\u5305\u957f\u5ea6\u51fd\u6570\u3002","title":"\u7c98\u5305\u5904\u7406"},{"location":"unpacking/#yasio","text":"yasio\u7684\u7c98\u5305\u5904\u7406\u4e0d\u4ec5\u9488\u5bf9TCP\uff0c\u5bf9\u4e8eUDP\uff0c\u5982\u679c\u53d1\u9001\u7aef\u6709\u7ec4\u5305\u53d1\u9001\u673a\u5236\uff0c\u4e5f\u662f\u4ee5\u76f8\u540c\u7684\u65b9\u5f0f\u5904\u7406\u3002\u6574\u4f53\u6765\u8bb2\u6709\u4e24\u79cd\u65b9\u5f0f: \u901a\u8fc7io_service\u9009\u9879 YOPT_C_LFBFD_PARAMS \u8bbe\u7f6e\u4fe1\u9053\u53c2\u6570\u3002 \u901a\u8fc7io_service\u9009\u9879 YOPT_C_LFBFD_FN \u8bbe\u7f6e\u81ea\u5b9a\u4e49\u5305\u957f\u5ea6\u89e3\u7801\u51fd\u6570 decode_len_fn_t \u3002 \u6ce8\u610f \u81ea\u5b9a\u4e49\u89e3\u7801\u5305\u957f\u5ea6\u51fd\u6570\u5b9e\u73b0\u65f6\uff0c\u5f53\u4ece\u5b57\u8282\u6d41\u4e2d\u8bfb\u53d6int\u503c\u65f6\uff0c\u4e00\u5b9a\u4e0d\u8981\u4f7f\u7528\u6307\u9488\u5f3a\u8f6c\uff0c\u5426\u5219\u53ef\u80fd\u89e6\u53d1ARM\u82af\u7247\u5b57\u8282\u5bf9\u9f50\u95ee\u9898 SIGBUS \u5f02\u5e38\u95ea\u9000\u3002\u53ef\u4ee5\u53c2\u8003\u5185\u7f6e\u89e3\u7801\u5305\u957f\u5ea6\u51fd\u6570\u5b9e\u73b0 io_channel::__builtin_decode_len \u3002","title":"yasio \u7c98\u5305\u5904\u7406"},{"location":"unpacking/#yopt_c_lfbfd_params","text":"\u8bbe\u7f6e\u4fe1\u9053\u62c6\u5305\u53c2\u6570\u3002","title":" YOPT_C_LFBFD_PARAMS"},{"location":"unpacking/#_1","text":"max_frame_length \u6700\u5927\u5305\u957f\u5ea6\uff0c\u8d85\u8fc7\u5c06\u89c6\u4e3a\u5f02\u5e38\u5305\u3002 length_field_offset \u5305\u957f\u5ea6\u5b57\u6bb5\u76f8\u5bf9\u4e8e\u6d88\u606f\u5305\u6570\u636e\u9996\u5b57\u8282\u504f\u79fb\u3002 length_field_length \u5305\u957f\u5ea6\u5b57\u6bb5\u5927\u5c0f\uff0c\u652f\u63011~4\u5b57\u8282\u6574\u6570( uint8_t,uint16_t,uint24_t,int32_t )\u3002 length_adjustment \u5305\u957f\u5ea6\u8c03\u6574\u503c\u3002\u901a\u5e38\u5e94\u7528\u5c42\u4e8c\u8fdb\u5236\u534f\u8bae\u90fd\u4f1a\u8bbe\u8ba1\u6d88\u606f\u5934\u548c\u6d88\u606f\u4f53\uff0c\u5f53\u957f\u5ea6\u5b57\u6bb5\u503c\u5305\u542b\u6d88\u606f\u5934\u65f6\uff0c\u5219\u6b64\u503c\u4e3a 0 \uff0c\u5426\u5219\u4e3a \u6d88\u606f\u5934\u957f\u5ea6 \u3002","title":"\u53c2\u6570"},{"location":"unpacking/#_2","text":"\u6d88\u606f\u5305\u957f\u5ea6\u5b57\u6bb5\u5fc5\u987b\u4f7f\u7528\u7f51\u7edc\u5b57\u8282\u5e8f\u7f16\u7801\u3002\u8bf7\u67e5\u770b\u5185\u7f6e\u89e3\u7801\u5305\u957f\u5ea6\u5b9e\u73b0: int io_channel::__builtin_decode_len ( void * d , int n ) { int loffset = uparams_ . length_field_offset ; int lsize = uparams_ . length_field_length ; if ( loffset >= 0 ) { int len = 0 ; if ( n >= ( loffset + lsize )) { :: memcpy ( & len , ( uint8_t * ) d + loffset , lsize ); len = yasio :: network_to_host ( len , lsize ); len += uparams_ . length_adjustment ; if ( len > uparams_ . max_frame_length ) len = -1 ; } return len ; } return n ; }","title":"\u6ce8\u610f"},{"location":"unpacking/#decode_len_fn_t","text":"\u4fe1\u9053\u89e3\u7801\u6d88\u606f\u5305\u957f\u5ea6\u51fd\u6570\u539f\u578b\u3002 typedef std :: function < int ( void * d , int n ) > decode_len_fn_t ;","title":"decode_len_fn_t"},{"location":"unpacking/#_3","text":"d \u5f85\u89e3\u5305\u6570\u636e\u9996\u5b57\u8282\u5730\u5740\u3002 n \u5f85\u89e3\u5305\u6570\u636e\u957f\u5ea6\u3002","title":"\u53c2\u6570"},{"location":"unpacking/#_4","text":"\u8fd4\u56de\u6d88\u606f\u5305\u6570\u636e\u5b9e\u9645\u957f\u5ea6\u3002 > 0 : \u89e3\u7801\u5305\u957f\u5ea6\u6210\u529f\u3002 == 0 : \u63a5\u6536\u6570\u636e\u4e0d\u8db3\u4ee5\u89e3\u7801\u6d88\u606f\u5305\u5b9e\u9645\u957f\u5ea6\uff0cyasio\u5e95\u5c42\u4f1a\u7ee7\u7eed\u63a5\u6536\u6570\u636e\uff0c\u4e00\u65e6\u6536\u5230\u65b0\u6570\u636e\uff0c\u4f1a\u518d\u6b21\u8c03\u7528\u6b64\u51fd\u6570\u3002 < 0 : \u89e3\u7801\u5305\u957f\u5ea6\u5f02\u5e38\uff0c\u4f1a\u89e6\u53d1\u5f53\u524d\u4f20\u8f93\u4f1a\u8bdd\u65ad\u5f00\u3002","title":"\u8fd4\u56de\u503c"},{"location":"unpacking/#_5","text":"\u89e3\u7801\u6d88\u606f\u5305\u957f\u5ea6\u51fd\u6570\u5fc5\u987b\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\uff0c\u4f8b\u5982\u5bf9\u4e8eLua\u5219\u4e0d\u652f\u6301\u8bbe\u7f6e\u81ea\u5b9a\u4e49\u89e3\u7801\u6d88\u606f\u5305\u957f\u5ea6\u51fd\u6570\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/ibstream-class/","text":"ibstream_view Class \u00b6 \u63d0\u4f9b\u4e8c\u8fdb\u5236\u53cd\u5e8f\u5217\u5316\u529f\u80fd\u3002 \u6ce8\u610f \u5728\u53cd\u5e8f\u5217\u5316\u8fc7\u7a0b\u4e2d\uff0c\u5f53\u5269\u4f59\u6570\u636e\u4e0d\u8db3\u65f6\u4f1a\u629b\u51fa std::out_of_range \u5f02\u5e38\u3002 \u8bed\u6cd5 \u00b6 namespace yasio { // \u53cd\u5e8f\u5217\u5316\u8fc7\u7a0b\uff0c\u4f1a\u81ea\u52a8\u8f6c\u6362\u5b57\u8282\u5e8f\uff0c\u9002\u7528\u4e8e\u7f51\u7edc\u4f20\u8f93 using ibstream_view = basic_ibstream_view < endian :: network_convert_tag > ; // \u53cd\u5e8f\u5217\u5316\u8fc7\u7a0b\uff0c\u65e0\u5b57\u8282\u5e8f\u8f6c\u6362\uff0c\u6027\u80fd\u66f4\u5feb using fast_ibstream_view = basic_ibstream_view < endian :: host_convert_tag > ; } \u6210\u5458 \u00b6 \u516c\u5171\u6784\u9020 \u00b6 Name Description ibstream_view::ibstream_view \u6784\u90201\u4e2a ibstream_view \u5bf9\u8c61 \u516c\u5171\u65b9\u6cd5 \u00b6 Name Description ibstream_view::reset \u91cd\u7f6e\u5f85\u53cd\u5e8f\u5217\u5316\u6570\u636e ibstream_view::read \u51fd\u6570\u6a21\u677f\uff0c\u8bfb\u53d6\u6570\u503c ibstream_view:read_ix \u51fd\u6570\u6a21\u677f\uff0c\u8bfb\u53d6( 7bit Encoded Int/Int64 )\u6574\u6570\u503c ibstream_view:read_v \u8bfb\u53d6\u5e26\u957f\u5ea6\u57df( 7bit Encoded Int/Int64 )\u7684\u4e8c\u8fdb\u5236\u6570\u636e ibstream_view:read_byte \u8bfb\u53d61\u4e2a\u5b57\u8282 ibstream_view:read_bytes \u8bfb\u53d6\u6307\u5b9a\u957f\u5ea6\u4e8c\u8fdb\u5236\u6570\u636e ibstream_view::empty \u68c0\u67e5\u6d41\u662f\u5426\u4e3a\u7a7a ibstream_view::data \u83b7\u53d6\u6d41\u6570\u636e\u6307\u9488 ibstream_view::length \u83b7\u53d6\u6d41\u5927\u5c0f ibstream_view::advance \u5411\u524d\u79fb\u52a8\u6d41\u7684\u8bfb\u53d6\u6e38\u6807 ibstream_view::seek \u79fb\u52a8\u6d41\u7684\u8bfb\u53d6\u6e38\u6807 \u6ce8\u610f \u00b6 ibstream_view \u501f\u9274C++17\u6807\u51c6\u7684 std::string_view , \u610f\u5473\u7740\u5728\u521d\u59cb\u5316\u548c\u53cd\u5e8f\u5217\u5316\u8fc7\u7a0b\u4e2d\u4e0d\u4f1a\u4ea7\u751f\u4efb\u4f55GC\u3002 \u8981\u6c42 \u00b6 \u5934\u6587\u4ef6: ibstream.hpp ibstream_view::ibstream_view \u00b6 \u6784\u9020\u4e00\u4e2a ibstream_view \u5bf9\u8c61\u3002 ibstream_view (); ibstream_view ( const void * data , size_t size ); ibstream_view ( const obstream * obs ); \u53c2\u6570 \u00b6 data \u5f85\u53cd\u5e8f\u5217\u5316\u4e8c\u8fdb\u5236\u6570\u636e\u9996\u5730\u5740\u3002 size \u5f85\u53cd\u5e8f\u5217\u5316\u4e8c\u8fdb\u5236\u6570\u636e\u5927\u5c0f\u3002 obs \u5df2\u5e8f\u5217\u5316\u7684\u6d41\u3002 ibstream_view::reset \u00b6 \u91cd\u7f6e ibstream_view \u7f13\u51b2\u89c6\u56fe\u3002 void ibstream_view::reset ( const void * data , size_t size ); \u53c2\u6570 \u00b6 data \u5f85\u53cd\u5e8f\u5217\u5316\u4e8c\u8fdb\u5236\u6570\u636e\u9996\u5730\u5740\u3002 size \u5f85\u53cd\u5e8f\u5217\u5316\u4e8c\u8fdb\u5236\u6570\u636e\u5927\u5c0f\u3002 ibstream_view::read \u00b6 \u4ece\u6d41\u4e2d\u8bfb\u53d6\u6570\u503c\u3002 template < typename _Nty > _Nty ibstream_view :: read (); \u8fd4\u56de\u503c \u00b6 \u8fd4\u56de\u8bfb\u5230\u7684\u503c \u6ce8\u610f \u00b6 _Nty \u5b9e\u9645\u7c7b\u578b\u53ef\u4ee5\u662f\u4efb\u610f1~8\u5b57\u8282\u6574\u6570\u7c7b\u578b\u6216\u6d6e\u70b9\u7c7b\u578b\u3002 ibstream_view::read_ix \u00b6 \u8bfb\u53d67Bit Encoded Int\u538b\u7f29\u7f16\u7801\u7684\u6574\u6570\u503c\u3002 template < typename _Intty > _Intty ibstream_view :: read_ix (); \u8fd4\u56de\u503c \u00b6 32/64\u4f4d\u6574\u6570\u503c\u3002 \u6ce8\u610f \u00b6 _Intty \u7684\u5fc5\u987b\u662f\u4ee5\u4e0b\u7c7b\u578b int32_t int64_t \u672c\u51fd\u6570\u517c\u5bb9\u4e8e Microsoft dotnet \u5982\u4e0b\u51fd\u6570 BinaryReader.Read7BitEncodedInt() BinaryReader.Read7BitEncodedInt64() ibstream_view::read_v \u00b6 \u8bfb\u53d6\u53d8\u957f\u4e8c\u8fdb\u5236\u6570\u636e\u3002 cxx17 :: string_view read_v (); \u8fd4\u56de\u503c \u00b6 \u8fd4\u56de\u8bfb\u53d6\u5230\u7684\u4e8c\u8fdb\u5236\u6570\u636e\u89c6\u56fe\uff0c\u65e0GC\u3002 \u6ce8\u610f \u00b6 \u672c\u51fd\u6570\u4f1a\u5148\u8bfb\u53d67bit Encoded Int\u538b\u7f29\u7f16\u7801\u7684\u957f\u5ea6\u503c\uff0c\u518d\u8c03\u7528 read_bytes \u8bfb\u53d6\u4e8c\u8fdb\u5236\u5b57\u8282\u6570\u636e\u3002 ibstream_view::read_byte \u00b6 \u8bfb\u53d61\u4e2a\u5b57\u8282\u3002 uint8_t read_byte (); \u8fd4\u56de\u503c \u00b6 uint8_t\u503c\u3002 \u6ce8\u610f \u00b6 \u672c\u51fd\u6570\u7b49\u4ef7\u4e8e ibstream_view::read ibstream_view::read_bytes \u00b6 \u8bfb\u53d6\u6307\u5b9a\u957f\u5ea6\u5b57\u8282\u6570\u636e\uff0c\u65e0GC\u3002 cxx17 :: string_view read_bytes (); \u8fd4\u56de\u503c \u00b6 \u4e8c\u8fdb\u5236\u6570\u636e\u7684 cxx17::string_view \u7c7b\u578b\u89c6\u56fe\u3002 ibstream_view::empty \u00b6 \u5224\u65ad\u6d41\u662f\u5426\u4e3a\u7a7a\u3002 bool empty () const ; \u8fd4\u56de\u503c \u00b6 true \u7a7a; false \u6d41\u4e2d\u81f3\u5c11\u5305\u542b1\u4e2a\u5b57\u8282\u3002 \u6ce8\u610f \u00b6 \u6b64\u65b9\u6cd5\u7b49\u4ef7\u4e8e length == 0\u3002 ibstream_view::data \u00b6 \u8fd4\u56de\u6d41\u6570\u636e\u6307\u9488\u3002 const char * data () const ; \u8fd4\u56de\u503c \u00b6 \u8fd4\u56de\u6307\u5411\u6d41\u4e2d\u7b2c\u4e00\u4e2a\u5b57\u8282\u7684\u6307\u9488\u3002 ibstream_view::length \u00b6 \u83b7\u53d6\u6d41\u957f\u5ea6\u3002 size_t length () const ; \u8fd4\u56de\u503c \u00b6 \u5f53\u524d\u6d41\u957f\u5ea6\u3002 ibstream_view::advance \u00b6 \u5411\u524d\u79fb\u52a8\u6d41\u8bfb\u53d6\u6e38\u6807\u3002 void advance ( ptrdiff_t offset ); \u53c2\u6570 \u00b6 offset \u8981\u5411\u524d\u79fb\u52a8\u7684\u504f\u79fb\u91cf\u3002 \u6ce8\u610f \u00b6 \u82e5*offset*\u4f20\u8d1f\u6570\uff0c\u5219\u53cd\u5411\u53ef\u79fb\u52a8\u8bfb\u53d6\u6e38\u6807\u3002 ibstream_view::seek \u00b6 \u79fb\u52a8\u8bfb\u53d6\u6e38\u6807\u3002 ptrdiff_t seek ( ptrdiff_t offset , int whence ); \u53c2\u6570 \u00b6 offset \u548c*whence*\u76f8\u5173\u7684\u504f\u79fb\u91cf\u3002 whence \u542b\u4e49\u7b49\u540c\u4e8eC\u6807\u51c6\u5e93\u679a\u4e3e\u503c\uff1a SEEK_SET , SEEK_CUR , SEEK_END \u3002 \u8fd4\u56de\u503c \u00b6 \u8fd4\u56de\u79fb\u52a8\u540e\u76f8\u5bf9\u4e8e\u6d41\u9996\u5b57\u8282\u504f\u79fb\u3002 ibstream Class \u00b6 \u63d0\u4f9b\u4e8c\u8fdb\u5236\u6570\u636e\u52a0\u8f7d\u548c\u53cd\u5e8f\u5217\u5316\u529f\u80fd\u3002 \u8bed\u6cd5 \u00b6 namespace yasio { using ibstream = basic_ibstream < endian :: network_convert_tag > ; // \u53cd\u5e8f\u5217\u5316\u8fc7\u7a0b\uff0c\u65e0\u5b57\u8282\u5e8f\u8f6c\u6362\uff0c\u6027\u80fd\u66f4\u5feb using fast_ibstream = basic_ibstream < endian :: host_convert_tag > ; } \u6210\u5458 \u00b6 \u516c\u5171\u6784\u9020\u51fd\u6570 \u00b6 Name Description ibstream::ibstream \u6784\u90201\u4e2a ibstream \u5bf9\u8c61 \u516c\u5171\u65b9\u6cd5 \u00b6 Name Description ibstream::load \u4ece\u6587\u4ef6\u52a0\u8f7d\u6d41 \u7ee7\u627f\u5c42\u6b21\u7ed3\u6784 \u00b6 ibstream_view ibstream ibstream::ibstream \u00b6 \u6784\u9020\u4e00\u4e2a ibstream \u5bf9\u8c61\u3002 ibstream ( std :: vector < char > blob ); ibstream ( const obstream * obs ); \u53c2\u6570 \u00b6 blob \u8f93\u5165\u4e8c\u8fdb\u5236\u6d41\u3002 obs \u5df2\u5e8f\u5217\u5316\u7684 obstream \u5bf9\u8c61\u3002 ibstream::load \u00b6 \u4ece\u6587\u4ef6\u52a0\u8f7d. bool load ( const char * filename ) const ; \u8fd4\u56de\u503c \u00b6 true \u52a0\u8f7d\u6210\u529f\uff0c false \u52a0\u8f7d\u5931\u8d25\u3002 \u793a\u4f8b \u00b6 \u8bf7\u67e5\u770b obstream::save \u8bf7\u53c2\u9605 \u00b6 obstream Class io_service Class","title":"ibstream\u7c7b"},{"location":"api/reference/ibstream-class/#ibstream_view-class","text":"\u63d0\u4f9b\u4e8c\u8fdb\u5236\u53cd\u5e8f\u5217\u5316\u529f\u80fd\u3002 \u6ce8\u610f \u5728\u53cd\u5e8f\u5217\u5316\u8fc7\u7a0b\u4e2d\uff0c\u5f53\u5269\u4f59\u6570\u636e\u4e0d\u8db3\u65f6\u4f1a\u629b\u51fa std::out_of_range \u5f02\u5e38\u3002","title":"ibstream_view Class"},{"location":"api/reference/ibstream-class/#_1","text":"namespace yasio { // \u53cd\u5e8f\u5217\u5316\u8fc7\u7a0b\uff0c\u4f1a\u81ea\u52a8\u8f6c\u6362\u5b57\u8282\u5e8f\uff0c\u9002\u7528\u4e8e\u7f51\u7edc\u4f20\u8f93 using ibstream_view = basic_ibstream_view < endian :: network_convert_tag > ; // \u53cd\u5e8f\u5217\u5316\u8fc7\u7a0b\uff0c\u65e0\u5b57\u8282\u5e8f\u8f6c\u6362\uff0c\u6027\u80fd\u66f4\u5feb using fast_ibstream_view = basic_ibstream_view < endian :: host_convert_tag > ; }","title":"\u8bed\u6cd5"},{"location":"api/reference/ibstream-class/#_2","text":"","title":"\u6210\u5458"},{"location":"api/reference/ibstream-class/#_3","text":"Name Description ibstream_view::ibstream_view \u6784\u90201\u4e2a ibstream_view \u5bf9\u8c61","title":"\u516c\u5171\u6784\u9020"},{"location":"api/reference/ibstream-class/#_4","text":"Name Description ibstream_view::reset \u91cd\u7f6e\u5f85\u53cd\u5e8f\u5217\u5316\u6570\u636e ibstream_view::read \u51fd\u6570\u6a21\u677f\uff0c\u8bfb\u53d6\u6570\u503c ibstream_view:read_ix \u51fd\u6570\u6a21\u677f\uff0c\u8bfb\u53d6( 7bit Encoded Int/Int64 )\u6574\u6570\u503c ibstream_view:read_v \u8bfb\u53d6\u5e26\u957f\u5ea6\u57df( 7bit Encoded Int/Int64 )\u7684\u4e8c\u8fdb\u5236\u6570\u636e ibstream_view:read_byte \u8bfb\u53d61\u4e2a\u5b57\u8282 ibstream_view:read_bytes \u8bfb\u53d6\u6307\u5b9a\u957f\u5ea6\u4e8c\u8fdb\u5236\u6570\u636e ibstream_view::empty \u68c0\u67e5\u6d41\u662f\u5426\u4e3a\u7a7a ibstream_view::data \u83b7\u53d6\u6d41\u6570\u636e\u6307\u9488 ibstream_view::length \u83b7\u53d6\u6d41\u5927\u5c0f ibstream_view::advance \u5411\u524d\u79fb\u52a8\u6d41\u7684\u8bfb\u53d6\u6e38\u6807 ibstream_view::seek \u79fb\u52a8\u6d41\u7684\u8bfb\u53d6\u6e38\u6807","title":"\u516c\u5171\u65b9\u6cd5"},{"location":"api/reference/ibstream-class/#_5","text":"ibstream_view \u501f\u9274C++17\u6807\u51c6\u7684 std::string_view , \u610f\u5473\u7740\u5728\u521d\u59cb\u5316\u548c\u53cd\u5e8f\u5217\u5316\u8fc7\u7a0b\u4e2d\u4e0d\u4f1a\u4ea7\u751f\u4efb\u4f55GC\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/ibstream-class/#_6","text":"\u5934\u6587\u4ef6: ibstream.hpp","title":"\u8981\u6c42"},{"location":"api/reference/ibstream-class/#ibstream_viewibstream_view","text":"\u6784\u9020\u4e00\u4e2a ibstream_view \u5bf9\u8c61\u3002 ibstream_view (); ibstream_view ( const void * data , size_t size ); ibstream_view ( const obstream * obs );","title":" ibstream_view::ibstream_view"},{"location":"api/reference/ibstream-class/#_7","text":"data \u5f85\u53cd\u5e8f\u5217\u5316\u4e8c\u8fdb\u5236\u6570\u636e\u9996\u5730\u5740\u3002 size \u5f85\u53cd\u5e8f\u5217\u5316\u4e8c\u8fdb\u5236\u6570\u636e\u5927\u5c0f\u3002 obs \u5df2\u5e8f\u5217\u5316\u7684\u6d41\u3002","title":"\u53c2\u6570"},{"location":"api/reference/ibstream-class/#ibstream_viewreset","text":"\u91cd\u7f6e ibstream_view \u7f13\u51b2\u89c6\u56fe\u3002 void ibstream_view::reset ( const void * data , size_t size );","title":" ibstream_view::reset"},{"location":"api/reference/ibstream-class/#_8","text":"data \u5f85\u53cd\u5e8f\u5217\u5316\u4e8c\u8fdb\u5236\u6570\u636e\u9996\u5730\u5740\u3002 size \u5f85\u53cd\u5e8f\u5217\u5316\u4e8c\u8fdb\u5236\u6570\u636e\u5927\u5c0f\u3002","title":"\u53c2\u6570"},{"location":"api/reference/ibstream-class/#ibstream_viewread","text":"\u4ece\u6d41\u4e2d\u8bfb\u53d6\u6570\u503c\u3002 template < typename _Nty > _Nty ibstream_view :: read ();","title":" ibstream_view::read"},{"location":"api/reference/ibstream-class/#_9","text":"\u8fd4\u56de\u8bfb\u5230\u7684\u503c","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/ibstream-class/#_10","text":"_Nty \u5b9e\u9645\u7c7b\u578b\u53ef\u4ee5\u662f\u4efb\u610f1~8\u5b57\u8282\u6574\u6570\u7c7b\u578b\u6216\u6d6e\u70b9\u7c7b\u578b\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/ibstream-class/#ibstream_viewread_ix","text":"\u8bfb\u53d67Bit Encoded Int\u538b\u7f29\u7f16\u7801\u7684\u6574\u6570\u503c\u3002 template < typename _Intty > _Intty ibstream_view :: read_ix ();","title":" ibstream_view::read_ix"},{"location":"api/reference/ibstream-class/#_11","text":"32/64\u4f4d\u6574\u6570\u503c\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/ibstream-class/#_12","text":"_Intty \u7684\u5fc5\u987b\u662f\u4ee5\u4e0b\u7c7b\u578b int32_t int64_t \u672c\u51fd\u6570\u517c\u5bb9\u4e8e Microsoft dotnet \u5982\u4e0b\u51fd\u6570 BinaryReader.Read7BitEncodedInt() BinaryReader.Read7BitEncodedInt64()","title":"\u6ce8\u610f"},{"location":"api/reference/ibstream-class/#ibstream_viewread_v","text":"\u8bfb\u53d6\u53d8\u957f\u4e8c\u8fdb\u5236\u6570\u636e\u3002 cxx17 :: string_view read_v ();","title":" ibstream_view::read_v"},{"location":"api/reference/ibstream-class/#_13","text":"\u8fd4\u56de\u8bfb\u53d6\u5230\u7684\u4e8c\u8fdb\u5236\u6570\u636e\u89c6\u56fe\uff0c\u65e0GC\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/ibstream-class/#_14","text":"\u672c\u51fd\u6570\u4f1a\u5148\u8bfb\u53d67bit Encoded Int\u538b\u7f29\u7f16\u7801\u7684\u957f\u5ea6\u503c\uff0c\u518d\u8c03\u7528 read_bytes \u8bfb\u53d6\u4e8c\u8fdb\u5236\u5b57\u8282\u6570\u636e\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/ibstream-class/#ibstream_viewread_byte","text":"\u8bfb\u53d61\u4e2a\u5b57\u8282\u3002 uint8_t read_byte ();","title":" ibstream_view::read_byte"},{"location":"api/reference/ibstream-class/#_15","text":"uint8_t\u503c\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/ibstream-class/#_16","text":"\u672c\u51fd\u6570\u7b49\u4ef7\u4e8e ibstream_view::read","title":"\u6ce8\u610f"},{"location":"api/reference/ibstream-class/#ibstream_viewread_bytes","text":"\u8bfb\u53d6\u6307\u5b9a\u957f\u5ea6\u5b57\u8282\u6570\u636e\uff0c\u65e0GC\u3002 cxx17 :: string_view read_bytes ();","title":" ibstream_view::read_bytes"},{"location":"api/reference/ibstream-class/#_17","text":"\u4e8c\u8fdb\u5236\u6570\u636e\u7684 cxx17::string_view \u7c7b\u578b\u89c6\u56fe\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/ibstream-class/#ibstream_viewempty","text":"\u5224\u65ad\u6d41\u662f\u5426\u4e3a\u7a7a\u3002 bool empty () const ;","title":" ibstream_view::empty"},{"location":"api/reference/ibstream-class/#_18","text":"true \u7a7a; false \u6d41\u4e2d\u81f3\u5c11\u5305\u542b1\u4e2a\u5b57\u8282\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/ibstream-class/#_19","text":"\u6b64\u65b9\u6cd5\u7b49\u4ef7\u4e8e length == 0\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/ibstream-class/#ibstream_viewdata","text":"\u8fd4\u56de\u6d41\u6570\u636e\u6307\u9488\u3002 const char * data () const ;","title":" ibstream_view::data"},{"location":"api/reference/ibstream-class/#_20","text":"\u8fd4\u56de\u6307\u5411\u6d41\u4e2d\u7b2c\u4e00\u4e2a\u5b57\u8282\u7684\u6307\u9488\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/ibstream-class/#ibstream_viewlength","text":"\u83b7\u53d6\u6d41\u957f\u5ea6\u3002 size_t length () const ;","title":" ibstream_view::length"},{"location":"api/reference/ibstream-class/#_21","text":"\u5f53\u524d\u6d41\u957f\u5ea6\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/ibstream-class/#ibstream_viewadvance","text":"\u5411\u524d\u79fb\u52a8\u6d41\u8bfb\u53d6\u6e38\u6807\u3002 void advance ( ptrdiff_t offset );","title":" ibstream_view::advance"},{"location":"api/reference/ibstream-class/#_22","text":"offset \u8981\u5411\u524d\u79fb\u52a8\u7684\u504f\u79fb\u91cf\u3002","title":"\u53c2\u6570"},{"location":"api/reference/ibstream-class/#_23","text":"\u82e5*offset*\u4f20\u8d1f\u6570\uff0c\u5219\u53cd\u5411\u53ef\u79fb\u52a8\u8bfb\u53d6\u6e38\u6807\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/ibstream-class/#ibstream_viewseek","text":"\u79fb\u52a8\u8bfb\u53d6\u6e38\u6807\u3002 ptrdiff_t seek ( ptrdiff_t offset , int whence );","title":" ibstream_view::seek"},{"location":"api/reference/ibstream-class/#_24","text":"offset \u548c*whence*\u76f8\u5173\u7684\u504f\u79fb\u91cf\u3002 whence \u542b\u4e49\u7b49\u540c\u4e8eC\u6807\u51c6\u5e93\u679a\u4e3e\u503c\uff1a SEEK_SET , SEEK_CUR , SEEK_END \u3002","title":"\u53c2\u6570"},{"location":"api/reference/ibstream-class/#_25","text":"\u8fd4\u56de\u79fb\u52a8\u540e\u76f8\u5bf9\u4e8e\u6d41\u9996\u5b57\u8282\u504f\u79fb\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/ibstream-class/#ibstream-class","text":"\u63d0\u4f9b\u4e8c\u8fdb\u5236\u6570\u636e\u52a0\u8f7d\u548c\u53cd\u5e8f\u5217\u5316\u529f\u80fd\u3002","title":"ibstream Class"},{"location":"api/reference/ibstream-class/#_26","text":"namespace yasio { using ibstream = basic_ibstream < endian :: network_convert_tag > ; // \u53cd\u5e8f\u5217\u5316\u8fc7\u7a0b\uff0c\u65e0\u5b57\u8282\u5e8f\u8f6c\u6362\uff0c\u6027\u80fd\u66f4\u5feb using fast_ibstream = basic_ibstream < endian :: host_convert_tag > ; }","title":"\u8bed\u6cd5"},{"location":"api/reference/ibstream-class/#_27","text":"","title":" \u6210\u5458"},{"location":"api/reference/ibstream-class/#_28","text":"Name Description ibstream::ibstream \u6784\u90201\u4e2a ibstream \u5bf9\u8c61","title":" \u516c\u5171\u6784\u9020\u51fd\u6570"},{"location":"api/reference/ibstream-class/#_29","text":"Name Description ibstream::load \u4ece\u6587\u4ef6\u52a0\u8f7d\u6d41","title":"\u516c\u5171\u65b9\u6cd5"},{"location":"api/reference/ibstream-class/#_30","text":"ibstream_view ibstream","title":" \u7ee7\u627f\u5c42\u6b21\u7ed3\u6784"},{"location":"api/reference/ibstream-class/#ibstreamibstream","text":"\u6784\u9020\u4e00\u4e2a ibstream \u5bf9\u8c61\u3002 ibstream ( std :: vector < char > blob ); ibstream ( const obstream * obs );","title":" ibstream::ibstream"},{"location":"api/reference/ibstream-class/#_31","text":"blob \u8f93\u5165\u4e8c\u8fdb\u5236\u6d41\u3002 obs \u5df2\u5e8f\u5217\u5316\u7684 obstream \u5bf9\u8c61\u3002","title":"\u53c2\u6570"},{"location":"api/reference/ibstream-class/#ibstreamload","text":"\u4ece\u6587\u4ef6\u52a0\u8f7d. bool load ( const char * filename ) const ;","title":" ibstream::load"},{"location":"api/reference/ibstream-class/#_32","text":"true \u52a0\u8f7d\u6210\u529f\uff0c false \u52a0\u8f7d\u5931\u8d25\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/ibstream-class/#_33","text":"\u8bf7\u67e5\u770b obstream::save","title":"\u793a\u4f8b"},{"location":"api/reference/ibstream-class/#_34","text":"obstream Class io_service Class","title":"\u8bf7\u53c2\u9605"},{"location":"api/reference/io_channel-class/","text":"io_channel Class \u00b6 \u8d1f\u8d23\u7ba1\u7406 TCP/SSL/UDP/KCP \u8fde\u63a5\u548c\u4f20\u8f93\u4f1a\u8bdd\u3002 \u8bed\u6cd5 \u00b6 namespace yasio { namespace inet { class io_channel ; } } \u6210\u5458 \u00b6 \u516c\u5171\u65b9\u6cd5 \u00b6 Name Description io_channel::get_service \u83b7\u53d6\u7ba1\u7406\u4fe1\u9053\u7684io_service io_channel::index \u83b7\u53d6\u4fe1\u9053\u7d22\u5f15 io_channel::remote_port \u83b7\u53d6\u4fe1\u9053\u8fdc\u7a0b\u7aef\u53e3 \u6ce8\u610f \u00b6 \u5f53io_service\u5bf9\u8c61\u6784\u9020\u540e\uff0c\u6700\u5927\u4fe1\u9053\u6570\u91cf\u4e0d\u53ef\u6539\u53d8\uff0c \u4fe1\u9053\u53e5\u67c4\u53ef\u901a\u8fc7 io_service::channel_at \u83b7\u53d6\u3002 io_channel::get_service \u00b6 \u83b7\u53d6\u7ba1\u7406\u4fe1\u9053\u7684io_service\u5bf9\u8c61\u3002 io_service & get_service () io_channel::index \u00b6 \u83b7\u53d6\u4fe1\u9053\u7d22\u5f15\u3002 int index () const io_channel::remote_port \u00b6 \u83b7\u53d6\u4fe1\u9053\u8fdc\u7a0b\u7aef\u53e3. u_short remote_port () const ; \u8fd4\u56de\u503c \u00b6 \u8fd4\u56de\u4fe1\u9053\u8fdc\u7a0b\u7aef\u53e3\u53f7 \u5bf9\u4e8e\u5ba2\u6237\u7aef\u4fe1\u9053\u8868\u793a\u901a\u4fe1\u7684\u8fdc\u7aef\u7aef\u53e3 \u5bf9\u4e8e\u670d\u52a1\u7aef\u4fe1\u9053\u8868\u793a\u76d1\u542c\u7aef\u53e3 \u8bf7\u53c2\u9605 \u00b6 io_service Class io_event Class","title":"io_channel\u7c7b"},{"location":"api/reference/io_channel-class/#io_channel-class","text":"\u8d1f\u8d23\u7ba1\u7406 TCP/SSL/UDP/KCP \u8fde\u63a5\u548c\u4f20\u8f93\u4f1a\u8bdd\u3002","title":"io_channel Class"},{"location":"api/reference/io_channel-class/#_1","text":"namespace yasio { namespace inet { class io_channel ; } }","title":"\u8bed\u6cd5"},{"location":"api/reference/io_channel-class/#_2","text":"","title":"\u6210\u5458"},{"location":"api/reference/io_channel-class/#_3","text":"Name Description io_channel::get_service \u83b7\u53d6\u7ba1\u7406\u4fe1\u9053\u7684io_service io_channel::index \u83b7\u53d6\u4fe1\u9053\u7d22\u5f15 io_channel::remote_port \u83b7\u53d6\u4fe1\u9053\u8fdc\u7a0b\u7aef\u53e3","title":"\u516c\u5171\u65b9\u6cd5"},{"location":"api/reference/io_channel-class/#_4","text":"\u5f53io_service\u5bf9\u8c61\u6784\u9020\u540e\uff0c\u6700\u5927\u4fe1\u9053\u6570\u91cf\u4e0d\u53ef\u6539\u53d8\uff0c \u4fe1\u9053\u53e5\u67c4\u53ef\u901a\u8fc7 io_service::channel_at \u83b7\u53d6\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/io_channel-class/#io_channelget_service","text":"\u83b7\u53d6\u7ba1\u7406\u4fe1\u9053\u7684io_service\u5bf9\u8c61\u3002 io_service & get_service ()","title":" io_channel::get_service"},{"location":"api/reference/io_channel-class/#io_channelindex","text":"\u83b7\u53d6\u4fe1\u9053\u7d22\u5f15\u3002 int index () const","title":" io_channel::index"},{"location":"api/reference/io_channel-class/#io_channelremote_port","text":"\u83b7\u53d6\u4fe1\u9053\u8fdc\u7a0b\u7aef\u53e3. u_short remote_port () const ;","title":" io_channel::remote_port"},{"location":"api/reference/io_channel-class/#_5","text":"\u8fd4\u56de\u4fe1\u9053\u8fdc\u7a0b\u7aef\u53e3\u53f7 \u5bf9\u4e8e\u5ba2\u6237\u7aef\u4fe1\u9053\u8868\u793a\u901a\u4fe1\u7684\u8fdc\u7aef\u7aef\u53e3 \u5bf9\u4e8e\u670d\u52a1\u7aef\u4fe1\u9053\u8868\u793a\u76d1\u542c\u7aef\u53e3","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/io_channel-class/#_6","text":"io_service Class io_event Class","title":"\u8bf7\u53c2\u9605"},{"location":"api/reference/io_event-class/","text":"io_event Class \u00b6 \u7f51\u7edc\u4e8b\u4ef6\u7531 io_service \u7ebf\u7a0b\u4ea7\u751f\u3002 \u8bed\u6cd5 \u00b6 namespace yasio { namespace inet { class io_event ; } } \u6210\u5458 \u00b6 \u516c\u5171\u65b9\u6cd5 \u00b6 Name Description io_event::kind \u83b7\u53d6\u4e8b\u4ef6\u7c7b\u578b io_event::status \u83b7\u53d6\u4e8b\u4ef6\u72b6\u6001 io_event::packet \u83b7\u53d6\u4e8b\u4ef6\u6d88\u606f\u5305 io_event::timestamp \u83b7\u53d6\u4e8b\u4ef6\u65f6\u95f4\u6233 io_event::transport \u83b7\u53d6\u4e8b\u4ef6\u4f20\u8f93\u4f1a\u8bdd io_event::transport_id \u83b7\u53d6\u4e8b\u4ef6\u4f20\u8f93\u4f1a\u8bddID io_event::transport_udata \u8bbe\u7f6e\u6216\u83b7\u53d6\u4e8b\u4ef6\u4f20\u8f93\u4f1a\u8bdd\u7528\u6237\u6570\u636e io_event::kind \u00b6 \u83b7\u53d6\u4e8b\u4ef6\u7c7b\u578b\u3002 int kind () const ; \u8fd4\u56de\u503c \u00b6 \u4e8b\u4ef6\u7c7b\u578b\uff0c\u53ef\u4ee5\u662f\u4ee5\u4e0b\u503c: YEK_PACKET : \u6d88\u606f\u5305\u4e8b\u4ef6 YEK_CONNECT_RESPONSE : \u8fde\u63a5\u54cd\u5e94\u4e8b\u4ef6 YEK_CONNECTION_LOST : \u8fde\u63a5\u4e22\u5931\u4e8b\u4ef6 io_event::status \u00b6 \u83b7\u53d6\u4e8b\u4ef6\u72b6\u6001\u3002 int status () const ; \u8fd4\u56de\u503c \u00b6 0: \u6b63\u5e38 \u975e0: \u51fa\u9519, \u7528\u6237\u53ea\u9700\u8981\u7b80\u5355\u6253\u5370\u5373\u53ef\u3002 io_event::packet \u00b6 \u83b7\u53d6\u4e8b\u4ef6\u643a\u5e26\u7684\u6d88\u606f\u5305 std :: vector < char >& packet () \u8fd4\u56de\u503c \u00b6 \u6d88\u606f\u5305\u7684\u5f15\u7528, \u7528\u6237\u53ef\u4ee5\u4f7f\u7528 std::move \u65e0GC\u65b9\u5f0f\u4ece\u4e8b\u4ef6\u53d6\u8d70\u6d88\u606f\u5305\u3002 io_event::timestamp \u00b6 \u83b7\u53d6\u4e8b\u4ef6\u4ea7\u751f\u7684\u5fae\u79d2\u7ea7\u65f6\u95f4\u6233\u3002 highp_time_t timestamp () const ; \u8fd4\u56de\u503c \u00b6 \u548c\u7cfb\u7edf\u65f6\u95f4\u65e0\u5173\u7684\u5fae\u79d2\u7ea7\u65f6\u95f4\u6233\u3002 io_event::transport \u00b6 \u83b7\u53d6\u4e8b\u4ef6\u7684\u4f20\u8f93\u4f1a\u8bdd\u53e5\u67c4\u3002 transport_handle_t transport () const ; \u8fd4\u56de\u503c \u00b6 \u8fd4\u56de\u53e5\u67c4\uff0c\u5f53\u6536\u5230\u65ad\u5f00\u4e8b\u4ef6\u65f6\uff0c\u4f20\u8f93\u4f1a\u8bdd\u53e5\u67c4\u5df2\u5931\u6548\uff0c\u4ec5\u53ef\u7528\u4f5c\u5730\u5740\u503c\u6bd4\u8f83\u3002 io_event::transport_id \u00b6 \u83b7\u53d6\u4e8b\u4ef6\u7684\u4f20\u8f93\u4f1a\u8bddID\u3002 unsigned int transport_id () const ; \u8fd4\u56de\u503c \u00b6 32\u4f4d\u65e0\u7b26\u53f7\u6574\u6570\u8303\u56f4\u5185\u7684\u552f\u4e00ID\u3002 io_event::transport_udata \u00b6 \u8bbe\u7f6e\u6216\u83b7\u53d6\u4f20\u8f93\u4f1a\u8bdd\u7528\u6237\u6570\u636e\u3002 template < typename _Uty > _Uty io_event :: transport_udata (); template < typename _Uty > void io_event :: transport_udata ( _Uty uservalue ); \u6ce8\u610f \u00b6 \u7528\u6237\u9700\u8981\u81ea\u5df1\u7ba1\u7406 userdata \u7684\u5185\u5b58, \u4f8b\u5982: \u6536\u5230\u8fde\u63a5\u5efa\u7acb\u6210\u529f\u4e8b\u4ef6\u65f6\u5b58\u50a8userdata \u6536\u5230\u8fde\u63a5\u4e22\u5931\u4e8b\u4ef6\u65f6\u6e05\u7406userdata \u8bf7\u53c2\u9605 \u00b6 io_service Class io_channel Class","title":"io_event\u7c7b"},{"location":"api/reference/io_event-class/#io_event-class","text":"\u7f51\u7edc\u4e8b\u4ef6\u7531 io_service \u7ebf\u7a0b\u4ea7\u751f\u3002","title":"io_event Class"},{"location":"api/reference/io_event-class/#_1","text":"namespace yasio { namespace inet { class io_event ; } }","title":"\u8bed\u6cd5"},{"location":"api/reference/io_event-class/#_2","text":"","title":"\u6210\u5458"},{"location":"api/reference/io_event-class/#_3","text":"Name Description io_event::kind \u83b7\u53d6\u4e8b\u4ef6\u7c7b\u578b io_event::status \u83b7\u53d6\u4e8b\u4ef6\u72b6\u6001 io_event::packet \u83b7\u53d6\u4e8b\u4ef6\u6d88\u606f\u5305 io_event::timestamp \u83b7\u53d6\u4e8b\u4ef6\u65f6\u95f4\u6233 io_event::transport \u83b7\u53d6\u4e8b\u4ef6\u4f20\u8f93\u4f1a\u8bdd io_event::transport_id \u83b7\u53d6\u4e8b\u4ef6\u4f20\u8f93\u4f1a\u8bddID io_event::transport_udata \u8bbe\u7f6e\u6216\u83b7\u53d6\u4e8b\u4ef6\u4f20\u8f93\u4f1a\u8bdd\u7528\u6237\u6570\u636e","title":"\u516c\u5171\u65b9\u6cd5"},{"location":"api/reference/io_event-class/#io_eventkind","text":"\u83b7\u53d6\u4e8b\u4ef6\u7c7b\u578b\u3002 int kind () const ;","title":" io_event::kind"},{"location":"api/reference/io_event-class/#_4","text":"\u4e8b\u4ef6\u7c7b\u578b\uff0c\u53ef\u4ee5\u662f\u4ee5\u4e0b\u503c: YEK_PACKET : \u6d88\u606f\u5305\u4e8b\u4ef6 YEK_CONNECT_RESPONSE : \u8fde\u63a5\u54cd\u5e94\u4e8b\u4ef6 YEK_CONNECTION_LOST : \u8fde\u63a5\u4e22\u5931\u4e8b\u4ef6","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/io_event-class/#io_eventstatus","text":"\u83b7\u53d6\u4e8b\u4ef6\u72b6\u6001\u3002 int status () const ;","title":" io_event::status"},{"location":"api/reference/io_event-class/#_5","text":"0: \u6b63\u5e38 \u975e0: \u51fa\u9519, \u7528\u6237\u53ea\u9700\u8981\u7b80\u5355\u6253\u5370\u5373\u53ef\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/io_event-class/#io_eventpacket","text":"\u83b7\u53d6\u4e8b\u4ef6\u643a\u5e26\u7684\u6d88\u606f\u5305 std :: vector < char >& packet ()","title":" io_event::packet"},{"location":"api/reference/io_event-class/#_6","text":"\u6d88\u606f\u5305\u7684\u5f15\u7528, \u7528\u6237\u53ef\u4ee5\u4f7f\u7528 std::move \u65e0GC\u65b9\u5f0f\u4ece\u4e8b\u4ef6\u53d6\u8d70\u6d88\u606f\u5305\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/io_event-class/#io_eventtimestamp","text":"\u83b7\u53d6\u4e8b\u4ef6\u4ea7\u751f\u7684\u5fae\u79d2\u7ea7\u65f6\u95f4\u6233\u3002 highp_time_t timestamp () const ;","title":" io_event::timestamp"},{"location":"api/reference/io_event-class/#_7","text":"\u548c\u7cfb\u7edf\u65f6\u95f4\u65e0\u5173\u7684\u5fae\u79d2\u7ea7\u65f6\u95f4\u6233\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/io_event-class/#io_eventtransport","text":"\u83b7\u53d6\u4e8b\u4ef6\u7684\u4f20\u8f93\u4f1a\u8bdd\u53e5\u67c4\u3002 transport_handle_t transport () const ;","title":" io_event::transport"},{"location":"api/reference/io_event-class/#_8","text":"\u8fd4\u56de\u53e5\u67c4\uff0c\u5f53\u6536\u5230\u65ad\u5f00\u4e8b\u4ef6\u65f6\uff0c\u4f20\u8f93\u4f1a\u8bdd\u53e5\u67c4\u5df2\u5931\u6548\uff0c\u4ec5\u53ef\u7528\u4f5c\u5730\u5740\u503c\u6bd4\u8f83\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/io_event-class/#io_eventtransport_id","text":"\u83b7\u53d6\u4e8b\u4ef6\u7684\u4f20\u8f93\u4f1a\u8bddID\u3002 unsigned int transport_id () const ;","title":" io_event::transport_id"},{"location":"api/reference/io_event-class/#_9","text":"32\u4f4d\u65e0\u7b26\u53f7\u6574\u6570\u8303\u56f4\u5185\u7684\u552f\u4e00ID\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/io_event-class/#io_eventtransport_udata","text":"\u8bbe\u7f6e\u6216\u83b7\u53d6\u4f20\u8f93\u4f1a\u8bdd\u7528\u6237\u6570\u636e\u3002 template < typename _Uty > _Uty io_event :: transport_udata (); template < typename _Uty > void io_event :: transport_udata ( _Uty uservalue );","title":" io_event::transport_udata"},{"location":"api/reference/io_event-class/#_10","text":"\u7528\u6237\u9700\u8981\u81ea\u5df1\u7ba1\u7406 userdata \u7684\u5185\u5b58, \u4f8b\u5982: \u6536\u5230\u8fde\u63a5\u5efa\u7acb\u6210\u529f\u4e8b\u4ef6\u65f6\u5b58\u50a8userdata \u6536\u5230\u8fde\u63a5\u4e22\u5931\u4e8b\u4ef6\u65f6\u6e05\u7406userdata","title":"\u6ce8\u610f"},{"location":"api/reference/io_event-class/#_11","text":"io_service Class io_channel Class","title":"\u8bf7\u53c2\u9605"},{"location":"api/reference/io_service-class/","text":"io_service Class \u00b6 \u5145\u5206\u5229\u7528 socket.select \u591a\u8def\u590d\u7528\u6a21\u578b\u5b9e\u73b0\u7f51\u7edc\u670d\u52a1\uff0c\u63d0\u4f9b\u7ed9\u4e0a\u5c42\u7edf\u4e00\u7684\u63a5\u53e3\u6765\u8fdb\u884c tcp, udp, kcp, ssl-client \u901a\u4fe1\u3002 \u8bed\u6cd5 \u00b6 namespace yasio { namespace inet { class io_service ; } } \u6210\u5458 \u00b6 \u516c\u5171\u6784\u9020\u51fd\u6570 \u00b6 Name Description io_service::io_service \u6784\u90201\u4e2a io_service \u5bf9\u8c61 \u516c\u5171\u65b9\u6cd5 \u00b6 Name Description io_service::start \u542f\u52a8\u7f51\u7edc\u670d\u52a1\u7ebf\u7a0b io_service::stop \u505c\u6b62\u7f51\u7edc\u670d\u52a1\u7ebf\u7a0b io_service::open \u6253\u5f00\u4fe1\u9053 io_service::close \u5173\u95ed\u4f20\u8f93\u4f1a\u8bdd io_service::is_open \u68c0\u6d4b\u4fe1\u9053\u6216\u4f1a\u8bdd\u662f\u5426\u6253\u5f00 io_service::dispatch \u5206\u6d3e\u7f51\u7edc\u4e8b\u4ef6 io_service::write \u5f02\u6b65\u53d1\u9001\u6570\u636e io_service::write_to \u5f02\u6b65\u53d1\u9001DGRAM\u6570\u636e io_service::schedule \u6ce8\u518c\u5b9a\u65f6\u5668 io_service::init_globals \u663e\u793a\u521d\u59cb\u5316\u5168\u5c40\u6570\u636e io_service::cleanup_globals \u6e05\u7406\u5168\u5c40\u6570\u636e io_service::channel_at \u83b7\u53d6\u4fe1\u9053\u53e5\u67c4 io_service::set_option \u8bbe\u7f6e\u9009\u9879 \u6ce8\u610f \u00b6 \u9ed8\u8ba4\u4f20\u8f93\u4f1a\u8bdd\u7684\u521b\u5efa\u4f1a\u4f7f\u7528\u5bf9\u8c61\u6c60 object_pool \u3002 \u8981\u6c42 \u00b6 \u5934\u6587\u4ef6: yasio.hpp io_service::io_service \u00b6 \u6784\u9020 io_service \u5bf9\u8c61\u3002 io_service :: io_service (); io_service :: io_service ( int channel_count ); io_service :: io_service ( const io_hostent & channel_ep ); io_service :: io_service ( const io_hostent * channel_eps , int channel_count ); \u53c2\u6570 \u00b6 channel_count \u4fe1\u9053\u6570\u91cf\u3002 channel_ep \u4fe1\u9053\u8fdc\u7aef\u5730\u5740\u3002 channel_eps \u4fe1\u9053\u8fdc\u7aef\u5730\u5740\u6570\u7ec4\u9996\u5730\u5740\u3002 \u793a\u4f8b \u00b6 #include \"yasio/yasio.hpp\" int main () { using namespace yasio ; using namespace yasio :: inet ; io_service s1 ; // s1 only support 1 channel io_service s2 ( 5 ); // s2 support 5 channels concurrency io_service s3 ( io_hostent { \"github.com\" , 443 }); // s3 support 1 channel io_hostent hosts [] = { { \"192.168.1.66\" , 20336 }, { \"192.168.1.88\" , 20337 }, }; io_service s4 ( hosts , YASIO_ARRAYSIZE ( hosts )); // s4 support 2 channels concurrency return 0 ; } io_service::start \u00b6 \u542f\u52a8\u7f51\u7edc\u670d\u52a1\u7ebf\u7a0b\u3002 void start ( io_event_cb_t cb ); \u53c2\u6570 \u00b6 cb \u7f51\u7edc\u4e8b\u4ef6\u56de\u8c03\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u5728 io_service::dispatch \u8c03\u7528\u8005\u7ebf\u7a0b\u8c03\u5ea6\u3002 \u793a\u4f8b \u00b6 #include \"yasio/yasio.hpp\" int main () { using namespace yasio ; using namespace yasio :: inet ; auto service = yasio_shared_service ( io_hostent { host = \"ip138.com\" , port = 80 }); service -> start ([]( event_ptr && ev ) { auto kind = ev -> kind (); if ( kind == YEK_CONNECT_RESPONSE ) { if ( ev -> status () == 0 ) printf ( \"[%d] connect succeed. \\n \" , ev -> cindex ()); else printf ( \"[%d] connect failed! \\n \" , ev -> cindex ()); } }); return 0 ; } io_service::stop \u00b6 \u505c\u6b62\u7f51\u7edc\u670d\u52a1\u7ebf\u7a0b\u3002 void stop () \u6ce8\u610f \u00b6 \u5982\u679c\u7f51\u7edc\u670d\u52a1\u7ebf\u7a0b\u6b63\u5728\u8fd0\u884c, \u6b64\u51fd\u6570\u4f1a\u53d1\u9001\u9000\u51fa\u4fe1\u53f7\u5e76\u7b49\u5f85\u5176\u6b63\u5e38\u9000\u51fa\u3002 io_service::open \u00b6 \u6253\u5f00\u4fe1\u9053\u3002 void open ( size_t cindex , int kind ); \u53c2\u6570 \u00b6 cindex \u4fe1\u9053\u7d22\u5f15\u3002 kind \u4fe1\u9053\u7c7b\u578b\u3002 \u6ce8\u610f \u00b6 \u5bf9\u4e8e TCP , \u5c06\u4f1a\u8bf7\u6c42\u5185\u6838\u53d1\u8d77\u975e\u963b\u585e3\u6b21\u63e1\u624b\u6765\u5efa\u7acb\u53ef\u9760\u8fde\u63a5\u3002 cindex \u7684\u503c\u5fc5\u987b\u5c0f\u4e8eio_service\u521d\u59cb\u5316\u65f6\u7684\u4fe1\u9053\u6570\u91cf\u3002 kind \u5fc5\u987b\u662f\u4ee5\u4e0b\u679a\u4e3e\u503c\u4e4b\u4e00: YCK_TCP_CLIENT YCK_TCP_SERVER YCK_UDP_CLIENT YCK_UDP_SERVER YCK_KCP_CLIENT YCK_KCP_SERVER YCK_SSL_CLIENT io_service::close \u00b6 \u5173\u95ed\u4fe1\u9053\u6216\u8005\u4f20\u8f93\u4f1a\u8bdd\u3002 void close ( transport_handle_t transport ); void close ( int cindex ); \u53c2\u6570 \u00b6 transport \u5c06\u8981\u5173\u95ed\u7684\u4f20\u8f93\u4f1a\u8bdd\u3002 cindex \u5c06\u8981\u5173\u95ed\u7684\u4fe1\u9053\u3002 \u6ce8\u610f \u00b6 \u5bf9\u4e8e TCP \uff0c \u5c06\u4f1a\u53d1\u8d774\u6b21\u63e1\u624b\u6765\u7ec8\u6b62\u8fde\u63a5\u3002 io_service::is_open \u00b6 \u5224\u65ad\u4fe1\u9053\u6216\u4f20\u8f93\u4f1a\u8bdd\u662f\u5426\u5904\u4e8e\u6253\u5f00\u72b6\u6001\u3002 bool is_open ( transport_handle_t transport ) const ; bool is_open ( int cindex ) const ; \u53c2\u6570 \u00b6 transport \u4f20\u8f93\u4f1a\u8bdd\u53e5\u67c4\u3002 cindex \u4fe1\u9053\u7d22\u5f15\u3002 \u8fd4\u56de\u503c \u00b6 true : \u6253\u5f00\uff0c false : \u672a\u6253\u5f00 io_service::dispatch \u00b6 \u5206\u6d3e\u7f51\u7edc\u7ebf\u7a0b\u4ea7\u751f\u7684\u4e8b\u4ef6\u3002 void dispatch ( int max_count ); \u53c2\u6570 \u00b6 max_count \u672c\u6b21\u6700\u5927\u5206\u6d3e\u4e8b\u4ef6\u6570\u3002 \u6ce8\u610f \u00b6 \u901a\u5e38\u6b64\u65b9\u6cd5\u5e94\u5f53\u5728\u5173\u5fc3\u7f51\u7edc\u4e8b\u4ef6\u7684\u4e1a\u52a1\u903b\u8f91\u7ebf\u7a0b\u8c03\u7528, \u4f8b\u5982Cocos2d-x\u7684\u6e32\u67d3\u7ebf\u7a0b\uff0c\u4ee5\u53ca\u5176\u4ed6\u6e38\u620f\u5f15\u64ce(Unity,UE4)\u7684\u4e3b\u903b\u8f91\u7ebf\u7a0b\u3002 \u6b64\u65b9\u6cd5\u5bf9\u4e8e\u5b89\u5168\u5730\u66f4\u65b0\u6e38\u620f\u754c\u9762\u975e\u5e38\u6709\u7528\u3002 \u793a\u4f8b \u00b6 yasio_shared_service () -> dispatch ( 128 ); io_service::write \u00b6 \u5411\u4f20\u8f93\u4f1a\u8bdd\u8fdc\u7aef\u53d1\u9001\u6570\u636e\u3002 int write ( transport_handle_t thandle , std :: vector < char > buffer , io_completion_cb_t completion_handler = nullptr ); \u53c2\u6570 \u00b6 thandle \u4f20\u8f93\u4f1a\u8bdd\u53e5\u67c4\u3002 buffer \u8981\u53d1\u9001\u7684\u4e8c\u8fdb\u5236\u7f13\u51b2\u533a\u3002 completion_handler \u53d1\u9001\u5b8c\u6210\u56de\u8c03\u3002 \u8fd4\u56de\u503c \u00b6 \u8fd4\u56de\u53d1\u9001\u6570\u636e\u5b57\u8282\u6570, < 0 : \u8bf4\u660e\u53d1\u751f\u9519\u8bef\u3002 \u6ce8\u610f \u00b6 completion_handler \u4e0d\u652f\u6301 KCP \u3002 \u7a7abuffer\u4f1a\u76f4\u63a5\u88ab\u5ffd\u7565\uff0c\u4e5f\u4e0d\u4f1a\u89e6\u53d1 completion_handler \u3002 io_service::write_to \u00b6 \u5411UDP\u4f20\u8f93\u4f1a\u8bdd\u53d1\u9001\u6570\u636e\u3002 int write_to ( transport_handle_t thandle , std :: vector < char > buffer , const ip :: endpoint & to , io_completion_cb_t completion_handler = nullptr ); \u53c2\u6570 \u00b6 thandle \u4f20\u8f93\u4f1a\u8bdd\u53e5\u67c4\u3002 buffer \u8981\u53d1\u9001\u7684buffer\u3002 to \u8981\u53d1\u9001\u7684\u8fdc\u7aef\u5730\u5740\u3002 completion_handler \u53d1\u9001\u5b8c\u6210\u56de\u8c03\u3002 \u8fd4\u56de\u503c \u00b6 \u6210\u529f\u53d1\u9001\u7684\u5b57\u8282\u6570, \u5f53 < 0 \u65f6\u8bf4\u660e\u53d1\u751f\u9519\u8bef\uff0c\u901a\u5e38\u662f\u4f20\u8f93\u4f1a\u8bdd\u5df2\u5173\u95ed(TCP\u8fde\u63a5\u65ad\u5f00\u7b49)\u3002 \u6ce8\u610f \u00b6 \u6b64\u51fd\u6570\u4ec5\u53ef\u7528\u4e8e DGRAM \u4f20\u8f93\u4f1a\u8bdd\uff0c\u5373 UDP,KCP \u3002 \u53d1\u9001\u5b8c\u6210\u56de\u8c03 completion_handler \u4e0d\u652f\u6301 KCP \u3002 \u7a7abuffer\u4f1a\u76f4\u63a5\u88ab\u5ffd\u7565\uff0c\u4e5f\u4e0d\u4f1a\u89e6\u53d1 completion_handler \u3002 io_service::schedule \u00b6 \u6ce8\u518c\u4e00\u4e2a\u5b9a\u65f6\u5668\u3002 highp_timer_ptr schedule ( const std :: chrono :: microseconds & duration , timer_cb_t cb ); \u53c2\u6570 \u00b6 duration \u5b9a\u65f6\u5668\u8d85\u65f6\u65f6\u95f4\uff0c\u6beb\u79d2\u7ea7\u3002 cb \u5f53\u5b9a\u65f6\u5668\u5230\u671f\u540e\u56de\u8c03\u3002 \u8fd4\u56de\u503c \u00b6 std::shared_ptr \u5305\u88c5\u7684\u5b9a\u65f6\u5668\u5bf9\u8c61\uff0c\u4ee5\u4fbf\u7528\u6237\u5bf9\u5b9a\u65f6\u5668\u5b89\u5168\u5730\u8fdb\u884c\u5fc5\u8981\u64cd\u4f5c\u3002 \u793a\u4f8b \u00b6 // Register a once timer, timeout is 3 seconds. yasio_shared_service () -> schedule ( std :: chrono :: seconds ( 3 ), []() -> bool { printf ( \"time called! \\n \" ); return true ; }); // Register a loop timer, interval is 5 seconds. auto loopTimer = yasio_shared_service () -> schedule ( std :: chrono :: seconds ( 5 ), []() -> bool { printf ( \"time called! \\n \" ); return false ; }); io_service::init_globals \u00b6 \u9759\u6001\u65b9\u6cd5\uff0c\u663e\u793a\u5730\u521d\u59cb\u5316\u5168\u5c40\u6570\u636e static void init_globals ( print_fn2_t print_fn ); \u53c2\u6570 \u00b6 print_fn \u81ea\u5b9a\u4e49\u7f51\u7edc\u65e5\u5fd7\u6253\u5370\u51fd\u6570\u3002 \u6ce8\u610f \u00b6 \u6b64\u51fd\u6570\u662f\u53ef\u9009\u8c03\u7528\uff0c\u4f46\u662f\u5f53\u7528\u6237\u9700\u8981\u5c06\u7f51\u7edc\u65e5\u5fd7\u91cd\u5b9a\u5411\u5230\u81ea\u5b9a\u4e49\u65e5\u5fd7\u7cfb\u7edf\u65f6\uff0c \u5219\u975e\u5e38\u6709\u7528\uff0c\u4f8b\u5982\u91cd\u5b9a\u5411\u5230UE4\u548cU3D\u7684\u65e5\u5fd7\u8f93\u51fa\u3002 \u793a\u4f8b \u00b6 // yasio_uelua.cpp // compile with: /EHsc #include \"yasio_uelua.h\" #include \"yasio/platform/yasio_ue4.hpp\" #include \"lua.hpp\" #if defined(NS_SLUA) using namespace NS_SLUA ; #endif #include \"yasio/bindings/lyasio.cpp\" DECLARE_LOG_CATEGORY_EXTERN ( yasio_ue4 , Log , All ); DEFINE_LOG_CATEGORY ( yasio_ue4 ); void yasio_uelua_init ( void * L ) { auto Ls = ( lua_State * ) L ; print_fn2_t log_cb = []( int level , const char * msg ) { FString text ( msg ); const TCHAR * tstr = * text ; UE_LOG ( yasio_ue4 , Log , L \"%s\" , tstr ); }; io_service :: init_globals ( log_cb ); luaregister_yasio ( Ls ); } void yasio_uelua_cleanup () { io_service :: cleanup_globals (); } io_service::cleanup_globals \u00b6 \u9759\u6001\u65b9\u6cd5\uff0c\u663e\u793a\u5730\u6e05\u7406\u5168\u5c40\u6570\u636e\u3002 static void cleanup_globals (); \u6ce8\u610f \u00b6 \u5f53\u7528\u6237\u9700\u8981\u5378\u8f7d\u5305\u542b\u81ea\u5b9a\u4e49\u65e5\u5fd7\u6253\u5370\u56de\u8c03\u7684\u52a8\u6001\u5e93(.dll,.so)\u524d\u5fc5\u987b\u8c03\u7528\u6b64\u51fd\u6570\uff0c\u8c28\u9632\u5e94\u7528\u7a0b\u5e8f\u95ea\u9000\u3002 io_service::channel_at \u00b6 \u901a\u8fc7\u4fe1\u9053\u7d22\u5f15\u83b7\u53d6\u4fe1\u9053\u53e5\u67c4\u3002 io_channel * channel_at ( size_t cindex ) const ; \u53c2\u6570 \u00b6 cindex \u4fe1\u9053\u7d22\u5f15 \u8fd4\u56de\u503c \u00b6 \u4fe1\u9053\u53e5\u67c4\u6307\u9488, \u5f53\u7d22\u5f15\u503c\u8d85\u51fa\u8303\u56f4\u65f6\uff0c\u8fd4\u56de nullptr \u3002 io_service::set_option \u00b6 \u8bbe\u7f6e\u9009\u9879\u3002 void set_option ( int opt , ...); \u53c2\u6570 \u00b6 opt \u9009\u9879\u679a\u4e3e, \u8bf7\u67e5\u770b YOPT_X_XXX . \u793a\u4f8b \u00b6 #include \"yasio/yasio.hpp\" int main (){ using namespace yasio ; using namespace yasio :: inet ; io_hostent hosts [] = { { \"192.168.1.66\" , 20336 }, { \"192.168.1.88\" , 20337 }, }; auto service = std :: make_shared < io_service > ( hosts , YASIO_ARRAYSIZE ( hosts )); // for application protocol with length field, you just needs set this option. // it's similar to java netty length frame based decode. // such as when your protocol define as following // packet.header: (header.len=12bytes) // code:int16_t // datalen:int32_t (not contains packet.header.len) // timestamp:int32_t // crc16:int16_t // packet.data service -> set_option ( YOPT_C_LFBFD_PARAMS , 0 , // channelIndex, the channel index 65535 , // maxFrameLength, max packet size 2 , // lenghtFieldOffset, the offset of length field 4 , // lengthFieldLength, the size of length field, can be 1,2,4 12 , // lengthAdjustment\uff1aif the value of length feild == packet.header.len + packet.data.len, this parameter should be 0, otherwise should be sizeof(packet.header) ); // for application protocol without length field, just sets length field size to -1. // then io_service will dispatch any packet received from server immediately, // such as http request, this is default behavior of channel. service -> set_option ( YOPT_C_LFBFD_PARAMS , 1 , 65535 , -1 , 0 , 0 ); return 0 ; } \u8bf7\u53c2\u9605 \u00b6 io_event Class io_channel Class io_service Options xxsocket Class obstream Class ibstream_view Class ibstream Class","title":"io_service\u7c7b"},{"location":"api/reference/io_service-class/#io_service-class","text":"\u5145\u5206\u5229\u7528 socket.select \u591a\u8def\u590d\u7528\u6a21\u578b\u5b9e\u73b0\u7f51\u7edc\u670d\u52a1\uff0c\u63d0\u4f9b\u7ed9\u4e0a\u5c42\u7edf\u4e00\u7684\u63a5\u53e3\u6765\u8fdb\u884c tcp, udp, kcp, ssl-client \u901a\u4fe1\u3002","title":"io_service Class"},{"location":"api/reference/io_service-class/#_1","text":"namespace yasio { namespace inet { class io_service ; } }","title":"\u8bed\u6cd5"},{"location":"api/reference/io_service-class/#_2","text":"","title":"\u6210\u5458"},{"location":"api/reference/io_service-class/#_3","text":"Name Description io_service::io_service \u6784\u90201\u4e2a io_service \u5bf9\u8c61","title":"\u516c\u5171\u6784\u9020\u51fd\u6570"},{"location":"api/reference/io_service-class/#_4","text":"Name Description io_service::start \u542f\u52a8\u7f51\u7edc\u670d\u52a1\u7ebf\u7a0b io_service::stop \u505c\u6b62\u7f51\u7edc\u670d\u52a1\u7ebf\u7a0b io_service::open \u6253\u5f00\u4fe1\u9053 io_service::close \u5173\u95ed\u4f20\u8f93\u4f1a\u8bdd io_service::is_open \u68c0\u6d4b\u4fe1\u9053\u6216\u4f1a\u8bdd\u662f\u5426\u6253\u5f00 io_service::dispatch \u5206\u6d3e\u7f51\u7edc\u4e8b\u4ef6 io_service::write \u5f02\u6b65\u53d1\u9001\u6570\u636e io_service::write_to \u5f02\u6b65\u53d1\u9001DGRAM\u6570\u636e io_service::schedule \u6ce8\u518c\u5b9a\u65f6\u5668 io_service::init_globals \u663e\u793a\u521d\u59cb\u5316\u5168\u5c40\u6570\u636e io_service::cleanup_globals \u6e05\u7406\u5168\u5c40\u6570\u636e io_service::channel_at \u83b7\u53d6\u4fe1\u9053\u53e5\u67c4 io_service::set_option \u8bbe\u7f6e\u9009\u9879","title":"\u516c\u5171\u65b9\u6cd5"},{"location":"api/reference/io_service-class/#_5","text":"\u9ed8\u8ba4\u4f20\u8f93\u4f1a\u8bdd\u7684\u521b\u5efa\u4f1a\u4f7f\u7528\u5bf9\u8c61\u6c60 object_pool \u3002","title":"\u6ce8\u610f"},{"location":"api/reference/io_service-class/#_6","text":"\u5934\u6587\u4ef6: yasio.hpp","title":"\u8981\u6c42"},{"location":"api/reference/io_service-class/#io_serviceio_service","text":"\u6784\u9020 io_service \u5bf9\u8c61\u3002 io_service :: io_service (); io_service :: io_service ( int channel_count ); io_service :: io_service ( const io_hostent & channel_ep ); io_service :: io_service ( const io_hostent * channel_eps , int channel_count );","title":" io_service::io_service"},{"location":"api/reference/io_service-class/#_7","text":"channel_count \u4fe1\u9053\u6570\u91cf\u3002 channel_ep \u4fe1\u9053\u8fdc\u7aef\u5730\u5740\u3002 channel_eps \u4fe1\u9053\u8fdc\u7aef\u5730\u5740\u6570\u7ec4\u9996\u5730\u5740\u3002","title":"\u53c2\u6570"},{"location":"api/reference/io_service-class/#_8","text":"#include \"yasio/yasio.hpp\" int main () { using namespace yasio ; using namespace yasio :: inet ; io_service s1 ; // s1 only support 1 channel io_service s2 ( 5 ); // s2 support 5 channels concurrency io_service s3 ( io_hostent { \"github.com\" , 443 }); // s3 support 1 channel io_hostent hosts [] = { { \"192.168.1.66\" , 20336 }, { \"192.168.1.88\" , 20337 }, }; io_service s4 ( hosts , YASIO_ARRAYSIZE ( hosts )); // s4 support 2 channels concurrency return 0 ; }","title":"\u793a\u4f8b"},{"location":"api/reference/io_service-class/#io_servicestart","text":"\u542f\u52a8\u7f51\u7edc\u670d\u52a1\u7ebf\u7a0b\u3002 void start ( io_event_cb_t cb );","title":" io_service::start"},{"location":"api/reference/io_service-class/#_9","text":"cb \u7f51\u7edc\u4e8b\u4ef6\u56de\u8c03\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u5728 io_service::dispatch \u8c03\u7528\u8005\u7ebf\u7a0b\u8c03\u5ea6\u3002","title":"\u53c2\u6570"},{"location":"api/reference/io_service-class/#_10","text":"#include \"yasio/yasio.hpp\" int main () { using namespace yasio ; using namespace yasio :: inet ; auto service = yasio_shared_service ( io_hostent { host = \"ip138.com\" , port = 80 }); service -> start ([]( event_ptr && ev ) { auto kind = ev -> kind (); if ( kind == YEK_CONNECT_RESPONSE ) { if ( ev -> status () == 0 ) printf ( \"[%d] connect succeed. \\n \" , ev -> cindex ()); else printf ( \"[%d] connect failed! \\n \" , ev -> cindex ()); } }); return 0 ; }","title":"\u793a\u4f8b"},{"location":"api/reference/io_service-class/#io_servicestop","text":"\u505c\u6b62\u7f51\u7edc\u670d\u52a1\u7ebf\u7a0b\u3002 void stop ()","title":" io_service::stop"},{"location":"api/reference/io_service-class/#_11","text":"\u5982\u679c\u7f51\u7edc\u670d\u52a1\u7ebf\u7a0b\u6b63\u5728\u8fd0\u884c, \u6b64\u51fd\u6570\u4f1a\u53d1\u9001\u9000\u51fa\u4fe1\u53f7\u5e76\u7b49\u5f85\u5176\u6b63\u5e38\u9000\u51fa\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/io_service-class/#io_serviceopen","text":"\u6253\u5f00\u4fe1\u9053\u3002 void open ( size_t cindex , int kind );","title":" io_service::open"},{"location":"api/reference/io_service-class/#_12","text":"cindex \u4fe1\u9053\u7d22\u5f15\u3002 kind \u4fe1\u9053\u7c7b\u578b\u3002","title":"\u53c2\u6570"},{"location":"api/reference/io_service-class/#_13","text":"\u5bf9\u4e8e TCP , \u5c06\u4f1a\u8bf7\u6c42\u5185\u6838\u53d1\u8d77\u975e\u963b\u585e3\u6b21\u63e1\u624b\u6765\u5efa\u7acb\u53ef\u9760\u8fde\u63a5\u3002 cindex \u7684\u503c\u5fc5\u987b\u5c0f\u4e8eio_service\u521d\u59cb\u5316\u65f6\u7684\u4fe1\u9053\u6570\u91cf\u3002 kind \u5fc5\u987b\u662f\u4ee5\u4e0b\u679a\u4e3e\u503c\u4e4b\u4e00: YCK_TCP_CLIENT YCK_TCP_SERVER YCK_UDP_CLIENT YCK_UDP_SERVER YCK_KCP_CLIENT YCK_KCP_SERVER YCK_SSL_CLIENT","title":"\u6ce8\u610f"},{"location":"api/reference/io_service-class/#io_serviceclose","text":"\u5173\u95ed\u4fe1\u9053\u6216\u8005\u4f20\u8f93\u4f1a\u8bdd\u3002 void close ( transport_handle_t transport ); void close ( int cindex );","title":" io_service::close"},{"location":"api/reference/io_service-class/#_14","text":"transport \u5c06\u8981\u5173\u95ed\u7684\u4f20\u8f93\u4f1a\u8bdd\u3002 cindex \u5c06\u8981\u5173\u95ed\u7684\u4fe1\u9053\u3002","title":"\u53c2\u6570"},{"location":"api/reference/io_service-class/#_15","text":"\u5bf9\u4e8e TCP \uff0c \u5c06\u4f1a\u53d1\u8d774\u6b21\u63e1\u624b\u6765\u7ec8\u6b62\u8fde\u63a5\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/io_service-class/#io_serviceis_open","text":"\u5224\u65ad\u4fe1\u9053\u6216\u4f20\u8f93\u4f1a\u8bdd\u662f\u5426\u5904\u4e8e\u6253\u5f00\u72b6\u6001\u3002 bool is_open ( transport_handle_t transport ) const ; bool is_open ( int cindex ) const ;","title":" io_service::is_open"},{"location":"api/reference/io_service-class/#_16","text":"transport \u4f20\u8f93\u4f1a\u8bdd\u53e5\u67c4\u3002 cindex \u4fe1\u9053\u7d22\u5f15\u3002","title":"\u53c2\u6570"},{"location":"api/reference/io_service-class/#_17","text":"true : \u6253\u5f00\uff0c false : \u672a\u6253\u5f00","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/io_service-class/#io_servicedispatch","text":"\u5206\u6d3e\u7f51\u7edc\u7ebf\u7a0b\u4ea7\u751f\u7684\u4e8b\u4ef6\u3002 void dispatch ( int max_count );","title":" io_service::dispatch"},{"location":"api/reference/io_service-class/#_18","text":"max_count \u672c\u6b21\u6700\u5927\u5206\u6d3e\u4e8b\u4ef6\u6570\u3002","title":"\u53c2\u6570"},{"location":"api/reference/io_service-class/#_19","text":"\u901a\u5e38\u6b64\u65b9\u6cd5\u5e94\u5f53\u5728\u5173\u5fc3\u7f51\u7edc\u4e8b\u4ef6\u7684\u4e1a\u52a1\u903b\u8f91\u7ebf\u7a0b\u8c03\u7528, \u4f8b\u5982Cocos2d-x\u7684\u6e32\u67d3\u7ebf\u7a0b\uff0c\u4ee5\u53ca\u5176\u4ed6\u6e38\u620f\u5f15\u64ce(Unity,UE4)\u7684\u4e3b\u903b\u8f91\u7ebf\u7a0b\u3002 \u6b64\u65b9\u6cd5\u5bf9\u4e8e\u5b89\u5168\u5730\u66f4\u65b0\u6e38\u620f\u754c\u9762\u975e\u5e38\u6709\u7528\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/io_service-class/#_20","text":"yasio_shared_service () -> dispatch ( 128 );","title":"\u793a\u4f8b"},{"location":"api/reference/io_service-class/#io_servicewrite","text":"\u5411\u4f20\u8f93\u4f1a\u8bdd\u8fdc\u7aef\u53d1\u9001\u6570\u636e\u3002 int write ( transport_handle_t thandle , std :: vector < char > buffer , io_completion_cb_t completion_handler = nullptr );","title":" io_service::write"},{"location":"api/reference/io_service-class/#_21","text":"thandle \u4f20\u8f93\u4f1a\u8bdd\u53e5\u67c4\u3002 buffer \u8981\u53d1\u9001\u7684\u4e8c\u8fdb\u5236\u7f13\u51b2\u533a\u3002 completion_handler \u53d1\u9001\u5b8c\u6210\u56de\u8c03\u3002","title":"\u53c2\u6570"},{"location":"api/reference/io_service-class/#_22","text":"\u8fd4\u56de\u53d1\u9001\u6570\u636e\u5b57\u8282\u6570, < 0 : \u8bf4\u660e\u53d1\u751f\u9519\u8bef\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/io_service-class/#_23","text":"completion_handler \u4e0d\u652f\u6301 KCP \u3002 \u7a7abuffer\u4f1a\u76f4\u63a5\u88ab\u5ffd\u7565\uff0c\u4e5f\u4e0d\u4f1a\u89e6\u53d1 completion_handler \u3002","title":"\u6ce8\u610f"},{"location":"api/reference/io_service-class/#io_servicewrite_to","text":"\u5411UDP\u4f20\u8f93\u4f1a\u8bdd\u53d1\u9001\u6570\u636e\u3002 int write_to ( transport_handle_t thandle , std :: vector < char > buffer , const ip :: endpoint & to , io_completion_cb_t completion_handler = nullptr );","title":" io_service::write_to"},{"location":"api/reference/io_service-class/#_24","text":"thandle \u4f20\u8f93\u4f1a\u8bdd\u53e5\u67c4\u3002 buffer \u8981\u53d1\u9001\u7684buffer\u3002 to \u8981\u53d1\u9001\u7684\u8fdc\u7aef\u5730\u5740\u3002 completion_handler \u53d1\u9001\u5b8c\u6210\u56de\u8c03\u3002","title":"\u53c2\u6570"},{"location":"api/reference/io_service-class/#_25","text":"\u6210\u529f\u53d1\u9001\u7684\u5b57\u8282\u6570, \u5f53 < 0 \u65f6\u8bf4\u660e\u53d1\u751f\u9519\u8bef\uff0c\u901a\u5e38\u662f\u4f20\u8f93\u4f1a\u8bdd\u5df2\u5173\u95ed(TCP\u8fde\u63a5\u65ad\u5f00\u7b49)\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/io_service-class/#_26","text":"\u6b64\u51fd\u6570\u4ec5\u53ef\u7528\u4e8e DGRAM \u4f20\u8f93\u4f1a\u8bdd\uff0c\u5373 UDP,KCP \u3002 \u53d1\u9001\u5b8c\u6210\u56de\u8c03 completion_handler \u4e0d\u652f\u6301 KCP \u3002 \u7a7abuffer\u4f1a\u76f4\u63a5\u88ab\u5ffd\u7565\uff0c\u4e5f\u4e0d\u4f1a\u89e6\u53d1 completion_handler \u3002","title":"\u6ce8\u610f"},{"location":"api/reference/io_service-class/#io_serviceschedule","text":"\u6ce8\u518c\u4e00\u4e2a\u5b9a\u65f6\u5668\u3002 highp_timer_ptr schedule ( const std :: chrono :: microseconds & duration , timer_cb_t cb );","title":" io_service::schedule"},{"location":"api/reference/io_service-class/#_27","text":"duration \u5b9a\u65f6\u5668\u8d85\u65f6\u65f6\u95f4\uff0c\u6beb\u79d2\u7ea7\u3002 cb \u5f53\u5b9a\u65f6\u5668\u5230\u671f\u540e\u56de\u8c03\u3002","title":"\u53c2\u6570"},{"location":"api/reference/io_service-class/#_28","text":"std::shared_ptr \u5305\u88c5\u7684\u5b9a\u65f6\u5668\u5bf9\u8c61\uff0c\u4ee5\u4fbf\u7528\u6237\u5bf9\u5b9a\u65f6\u5668\u5b89\u5168\u5730\u8fdb\u884c\u5fc5\u8981\u64cd\u4f5c\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/io_service-class/#_29","text":"// Register a once timer, timeout is 3 seconds. yasio_shared_service () -> schedule ( std :: chrono :: seconds ( 3 ), []() -> bool { printf ( \"time called! \\n \" ); return true ; }); // Register a loop timer, interval is 5 seconds. auto loopTimer = yasio_shared_service () -> schedule ( std :: chrono :: seconds ( 5 ), []() -> bool { printf ( \"time called! \\n \" ); return false ; });","title":"\u793a\u4f8b"},{"location":"api/reference/io_service-class/#io_serviceinit_globals","text":"\u9759\u6001\u65b9\u6cd5\uff0c\u663e\u793a\u5730\u521d\u59cb\u5316\u5168\u5c40\u6570\u636e static void init_globals ( print_fn2_t print_fn );","title":" io_service::init_globals"},{"location":"api/reference/io_service-class/#_30","text":"print_fn \u81ea\u5b9a\u4e49\u7f51\u7edc\u65e5\u5fd7\u6253\u5370\u51fd\u6570\u3002","title":"\u53c2\u6570"},{"location":"api/reference/io_service-class/#_31","text":"\u6b64\u51fd\u6570\u662f\u53ef\u9009\u8c03\u7528\uff0c\u4f46\u662f\u5f53\u7528\u6237\u9700\u8981\u5c06\u7f51\u7edc\u65e5\u5fd7\u91cd\u5b9a\u5411\u5230\u81ea\u5b9a\u4e49\u65e5\u5fd7\u7cfb\u7edf\u65f6\uff0c \u5219\u975e\u5e38\u6709\u7528\uff0c\u4f8b\u5982\u91cd\u5b9a\u5411\u5230UE4\u548cU3D\u7684\u65e5\u5fd7\u8f93\u51fa\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/io_service-class/#_32","text":"// yasio_uelua.cpp // compile with: /EHsc #include \"yasio_uelua.h\" #include \"yasio/platform/yasio_ue4.hpp\" #include \"lua.hpp\" #if defined(NS_SLUA) using namespace NS_SLUA ; #endif #include \"yasio/bindings/lyasio.cpp\" DECLARE_LOG_CATEGORY_EXTERN ( yasio_ue4 , Log , All ); DEFINE_LOG_CATEGORY ( yasio_ue4 ); void yasio_uelua_init ( void * L ) { auto Ls = ( lua_State * ) L ; print_fn2_t log_cb = []( int level , const char * msg ) { FString text ( msg ); const TCHAR * tstr = * text ; UE_LOG ( yasio_ue4 , Log , L \"%s\" , tstr ); }; io_service :: init_globals ( log_cb ); luaregister_yasio ( Ls ); } void yasio_uelua_cleanup () { io_service :: cleanup_globals (); }","title":"\u793a\u4f8b"},{"location":"api/reference/io_service-class/#io_servicecleanup_globals","text":"\u9759\u6001\u65b9\u6cd5\uff0c\u663e\u793a\u5730\u6e05\u7406\u5168\u5c40\u6570\u636e\u3002 static void cleanup_globals ();","title":" io_service::cleanup_globals"},{"location":"api/reference/io_service-class/#_33","text":"\u5f53\u7528\u6237\u9700\u8981\u5378\u8f7d\u5305\u542b\u81ea\u5b9a\u4e49\u65e5\u5fd7\u6253\u5370\u56de\u8c03\u7684\u52a8\u6001\u5e93(.dll,.so)\u524d\u5fc5\u987b\u8c03\u7528\u6b64\u51fd\u6570\uff0c\u8c28\u9632\u5e94\u7528\u7a0b\u5e8f\u95ea\u9000\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/io_service-class/#io_servicechannel_at","text":"\u901a\u8fc7\u4fe1\u9053\u7d22\u5f15\u83b7\u53d6\u4fe1\u9053\u53e5\u67c4\u3002 io_channel * channel_at ( size_t cindex ) const ;","title":" io_service::channel_at"},{"location":"api/reference/io_service-class/#_34","text":"cindex \u4fe1\u9053\u7d22\u5f15","title":"\u53c2\u6570"},{"location":"api/reference/io_service-class/#_35","text":"\u4fe1\u9053\u53e5\u67c4\u6307\u9488, \u5f53\u7d22\u5f15\u503c\u8d85\u51fa\u8303\u56f4\u65f6\uff0c\u8fd4\u56de nullptr \u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/io_service-class/#io_serviceset_option","text":"\u8bbe\u7f6e\u9009\u9879\u3002 void set_option ( int opt , ...);","title":" io_service::set_option"},{"location":"api/reference/io_service-class/#_36","text":"opt \u9009\u9879\u679a\u4e3e, \u8bf7\u67e5\u770b YOPT_X_XXX .","title":"\u53c2\u6570"},{"location":"api/reference/io_service-class/#_37","text":"#include \"yasio/yasio.hpp\" int main (){ using namespace yasio ; using namespace yasio :: inet ; io_hostent hosts [] = { { \"192.168.1.66\" , 20336 }, { \"192.168.1.88\" , 20337 }, }; auto service = std :: make_shared < io_service > ( hosts , YASIO_ARRAYSIZE ( hosts )); // for application protocol with length field, you just needs set this option. // it's similar to java netty length frame based decode. // such as when your protocol define as following // packet.header: (header.len=12bytes) // code:int16_t // datalen:int32_t (not contains packet.header.len) // timestamp:int32_t // crc16:int16_t // packet.data service -> set_option ( YOPT_C_LFBFD_PARAMS , 0 , // channelIndex, the channel index 65535 , // maxFrameLength, max packet size 2 , // lenghtFieldOffset, the offset of length field 4 , // lengthFieldLength, the size of length field, can be 1,2,4 12 , // lengthAdjustment\uff1aif the value of length feild == packet.header.len + packet.data.len, this parameter should be 0, otherwise should be sizeof(packet.header) ); // for application protocol without length field, just sets length field size to -1. // then io_service will dispatch any packet received from server immediately, // such as http request, this is default behavior of channel. service -> set_option ( YOPT_C_LFBFD_PARAMS , 1 , 65535 , -1 , 0 , 0 ); return 0 ; }","title":"\u793a\u4f8b"},{"location":"api/reference/io_service-class/#_38","text":"io_event Class io_channel Class io_service Options xxsocket Class obstream Class ibstream_view Class ibstream Class","title":"\u8bf7\u53c2\u9605"},{"location":"api/reference/io_service-options/","text":"io_service options \u00b6 io_service\u652f\u6301\u7684\u6240\u6709\u9009\u9879\u3002 Name Description YOPT_S_DEFER_EVENT_CB Set defer event callback params: callback:defer_event_cb_t remarks: a. User can do custom packet resolve at network thread, such as decompress and crc check. b. Return true, io_service will continue enque to event queue. c. Return false, io_service will drop the event. YOPT_S_DEFERRED_EVENT Set whether deferred dispatch event, default is: 1 params: deferred_event:int(1) YOPT_S_RESOLV_FN Set custom resolve function, native C++ ONLY params: func:resolv_fn_t* YOPT_S_PRINT_FN Set custom print function native C++ ONLY parmas: func:print_fn_t remarks: you must ensure thread safe of it YOPT_S_PRINT_FN2 Set custom print function with log level parmas: func:print_fn2_t you must ensure thread safe of it YOPT_S_EVENT_CB Set event callback params: func:event_cb_t* YOPT_S_TCP_KEEPALIVE Set tcp keepalive in seconds, probes is tries. params: idle:int(7200), interal:int(75), probes:int(10) YOPT_S_NO_NEW_THREAD Don't start a new thread to run event loop. params: value:int(0) YOPT_S_SSL_CACERT Sets ssl verification cert, if empty, don't verify. params: path:const char* YOPT_S_CONNECT_TIMEOUT Set connect timeout in seconds. params: connect_timeout:int(10) YOPT_S_DNS_CACHE_TIMEOUT Set dns cache timeout in seconds. params: dns_cache_timeout : int(600), YOPT_S_DNS_QUERIES_TIMEOUT Set dns queries timeout in seconds, default is: 5000. params: dns_queries_timeout : int(5000) remark: a. this option must be set before 'io_service::start' b. only works when have c-ares c. since v3.33.0 it's milliseconds, previous is seconds. d. the timeout algorithm of c-ares is complicated, usually, by default, dns queries will failed with timeout after more than 75 seconds. e. for more detail, please see: https://c-ares.haxx.se/ares_init_options.html YOPT_S_DNS_QUERIES_TRIES Set dns queries tries when timeout reached, default is: 5. params: dns_queries_tries : int(5) remarks: a. this option must be set before 'io_service::start' b. relative option: YOPT_S_DNS_QUERIES_TIMEOUT YOPT_S_DNS_DIRTY Set dns server dirty. params: reserved : int(1) remarks: a. this option only works with c-ares enabled b. you should set this option after your mobile network changed YOPT_C_LFBFD_FN Sets channel length field based frame decode function. params: index:int, func:decode_len_fn_t* remark: native C++ ONLY YOPT_C_LFBFD_PARAMS Sets channel length field based frame decode params. params: index:int, max_frame_length:int(10MBytes), length_field_offset:int(-1), length_field_length:int(4), length_adjustment:int(0), YOPT_C_LFBFD_IBTS Sets channel length field based frame decode initial bytes to strip. params:index:int,initial_bytes_to_strip:int(0) YOPT_C_REMOTE_HOST Sets channel remote host. params: index:int, ip:const char* YOPT_C_REMOTE_PORT Sets channel remote port. params: index:int, port:int YOPT_C_REMOTE_ENDPOINT Sets channel remote endpoint. params: index:int, ip:const char*, port:int YOPT_C_LOCAL_HOST Sets local host for client channel only. params: index:int, ip:const char* YOPT_C_LOCAL_PORT Sets local port for client channel only. params: index:int, port:int YOPT_C_LOCAL_ENDPOINT Sets local endpoint for client channel only. params: index:int, ip:const char*, port:int YOPT_C_MOD_FLAGS Mods channl flags. params: index:int, flagsToAdd:int, flagsToRemove:int YOPT_C_ENABLE_MCAST Enable channel multicast mode. params: index:int, multi_addr:const char*, loopback:int YOPT_C_DISABLE_MCAST Disable channel multicast mode. params: index:int YOPT_C_KCP_CONV The kcp conv id, must equal in two endpoint from the same connection. params: index:int, conv:int YOPT_T_CONNECT Change 4-tuple association for io_transport_udp. params: transport:transport_handle_t remark: only works for udp client transport YOPT_T_DISCONNECT Dissolve 4-tuple association for io_transport_udp. params: transport:transport_handle_t remark: only works for udp client transport YOPT_B_SOCKOPT Sets io_base sockopt. params: io_base*,level:int,optname:int,optval:int,optlen:int \u8bf7\u53c2\u9605 \u00b6 io_service Class","title":"io_service\u9009\u9879"},{"location":"api/reference/io_service-options/#io_service-options","text":"io_service\u652f\u6301\u7684\u6240\u6709\u9009\u9879\u3002 Name Description YOPT_S_DEFER_EVENT_CB Set defer event callback params: callback:defer_event_cb_t remarks: a. User can do custom packet resolve at network thread, such as decompress and crc check. b. Return true, io_service will continue enque to event queue. c. Return false, io_service will drop the event. YOPT_S_DEFERRED_EVENT Set whether deferred dispatch event, default is: 1 params: deferred_event:int(1) YOPT_S_RESOLV_FN Set custom resolve function, native C++ ONLY params: func:resolv_fn_t* YOPT_S_PRINT_FN Set custom print function native C++ ONLY parmas: func:print_fn_t remarks: you must ensure thread safe of it YOPT_S_PRINT_FN2 Set custom print function with log level parmas: func:print_fn2_t you must ensure thread safe of it YOPT_S_EVENT_CB Set event callback params: func:event_cb_t* YOPT_S_TCP_KEEPALIVE Set tcp keepalive in seconds, probes is tries. params: idle:int(7200), interal:int(75), probes:int(10) YOPT_S_NO_NEW_THREAD Don't start a new thread to run event loop. params: value:int(0) YOPT_S_SSL_CACERT Sets ssl verification cert, if empty, don't verify. params: path:const char* YOPT_S_CONNECT_TIMEOUT Set connect timeout in seconds. params: connect_timeout:int(10) YOPT_S_DNS_CACHE_TIMEOUT Set dns cache timeout in seconds. params: dns_cache_timeout : int(600), YOPT_S_DNS_QUERIES_TIMEOUT Set dns queries timeout in seconds, default is: 5000. params: dns_queries_timeout : int(5000) remark: a. this option must be set before 'io_service::start' b. only works when have c-ares c. since v3.33.0 it's milliseconds, previous is seconds. d. the timeout algorithm of c-ares is complicated, usually, by default, dns queries will failed with timeout after more than 75 seconds. e. for more detail, please see: https://c-ares.haxx.se/ares_init_options.html YOPT_S_DNS_QUERIES_TRIES Set dns queries tries when timeout reached, default is: 5. params: dns_queries_tries : int(5) remarks: a. this option must be set before 'io_service::start' b. relative option: YOPT_S_DNS_QUERIES_TIMEOUT YOPT_S_DNS_DIRTY Set dns server dirty. params: reserved : int(1) remarks: a. this option only works with c-ares enabled b. you should set this option after your mobile network changed YOPT_C_LFBFD_FN Sets channel length field based frame decode function. params: index:int, func:decode_len_fn_t* remark: native C++ ONLY YOPT_C_LFBFD_PARAMS Sets channel length field based frame decode params. params: index:int, max_frame_length:int(10MBytes), length_field_offset:int(-1), length_field_length:int(4), length_adjustment:int(0), YOPT_C_LFBFD_IBTS Sets channel length field based frame decode initial bytes to strip. params:index:int,initial_bytes_to_strip:int(0) YOPT_C_REMOTE_HOST Sets channel remote host. params: index:int, ip:const char* YOPT_C_REMOTE_PORT Sets channel remote port. params: index:int, port:int YOPT_C_REMOTE_ENDPOINT Sets channel remote endpoint. params: index:int, ip:const char*, port:int YOPT_C_LOCAL_HOST Sets local host for client channel only. params: index:int, ip:const char* YOPT_C_LOCAL_PORT Sets local port for client channel only. params: index:int, port:int YOPT_C_LOCAL_ENDPOINT Sets local endpoint for client channel only. params: index:int, ip:const char*, port:int YOPT_C_MOD_FLAGS Mods channl flags. params: index:int, flagsToAdd:int, flagsToRemove:int YOPT_C_ENABLE_MCAST Enable channel multicast mode. params: index:int, multi_addr:const char*, loopback:int YOPT_C_DISABLE_MCAST Disable channel multicast mode. params: index:int YOPT_C_KCP_CONV The kcp conv id, must equal in two endpoint from the same connection. params: index:int, conv:int YOPT_T_CONNECT Change 4-tuple association for io_transport_udp. params: transport:transport_handle_t remark: only works for udp client transport YOPT_T_DISCONNECT Dissolve 4-tuple association for io_transport_udp. params: transport:transport_handle_t remark: only works for udp client transport YOPT_B_SOCKOPT Sets io_base sockopt. params: io_base*,level:int,optname:int,optval:int,optlen:int","title":"io_service options"},{"location":"api/reference/io_service-options/#_1","text":"io_service Class","title":"\u8bf7\u53c2\u9605"},{"location":"api/reference/obstream-class/","text":"obstream Class \u00b6 \u63d0\u4f9b\u4e8c\u8fdb\u5236\u5e8f\u5217\u5316\u529f\u80fd\u3002 \u6ce8\u610f \u81ea3.35.0\u8d77\uff0c\u4f18\u5316\u4e3a\u7c7b\u6a21\u677fbasic_obstream\u5b9e\u73b0\uff0c\u4f53\u73b0\u4e86C++\u6a21\u677f\u5f3a\u5927\u7684\u4ee3\u7801\u590d\u7528\u80fd\u529b\u3002 obstream \u5f53\u5199\u5165int16~int64\u548cfloat/double\u7c7b\u578b\u65f6, \u4f1a\u81ea\u52a8\u5c06\u4e3b\u673a\u5b57\u8282\u5e8f\u8f6c\u6362\u4e3a\u7f51\u7edc\u5b57\u8282\u5e8f\u3002 fast_obstream \u4e0d\u4f1a\u8f6c\u6362\u4efb\u4f55\u5b57\u8282\u5e8f\u3002 \u8bed\u6cd5 \u00b6 namespace yasio { using obstream = basic_obstream < endian :: network_convert_tag > ; using fast_obstream = basic_obstream < endian :: host_convert_tag > ; } \u6210\u5458 \u00b6 \u516c\u5171\u6784\u9020\u51fd\u6570 \u00b6 Name Description obstream::obstream \u6784\u90201\u4e2a obstream \u5bf9\u8c61 \u516c\u5171\u65b9\u6cd5 \u00b6 Name Description obstream::write \u51fd\u6570\u6a21\u677f\uff0c\u5199\u5165\u6570\u503c obstream::write_ix \u51fd\u6570\u6a21\u677f\uff0c\u5199\u5165( 7bit Encoded Int/Int64 )\u6570\u503c obstream::write_v \u5199\u5165\u5e26\u957f\u5ea6\u57df( 7bit Encoded Int )\u7684\u4e8c\u8fdb\u5236\u6570\u636e obstream::write_byte \u5199\u51651\u4e2a\u5b57\u8282 obstream::write_bytes \u5199\u5165\u6307\u5b9a\u957f\u5ea6\u4e8c\u8fdb\u5236\u6570\u636e obstream::empty \u68c0\u67e5\u6d41\u662f\u5426\u4e3a\u7a7a obstream::data \u83b7\u53d6\u6d41\u6570\u636e\u6307\u9488 obstream::length \u83b7\u53d6\u6d41\u6570\u636e\u5927\u5c0f obstream::buffer \u83b7\u53d6\u6d41\u5185\u90e8\u7f13\u51b2\u533a obstream::clear \u6e05\u7406\u6d41\uff0c\u4ee5\u4fbf\u590d\u7528 obstream::shrink_to_fit \u91ca\u653e\u6d41\u5185\u90e8\u7f13\u51b2\u533a\u591a\u4f59\u5185\u5b58 obstream::save \u4fdd\u5b58\u6d41\u4e8c\u8fdb\u5236\u6570\u636e\u5230\u6587\u4ef6\u7cfb\u7edf \u8981\u6c42 \u00b6 \u5934\u6587\u4ef6: obstream.hpp obstream::obstream \u00b6 \u6784\u9020 obstream \u5bf9\u8c61\u3002 obstream ( size_t capacity = 128 ); obstream ( const obstream & rhs ); obstream ( obstream && rhs ); obstream::write \u00b6 \u5199\u5165\u6570\u503c\u7c7b\u578b template < typename _Nty > void obstream :: write ( _Nty value ); \u53c2\u6570 \u00b6 value \u8981\u5199\u5165\u7684\u503c \u6ce8\u610f \u00b6 _Nty \u5b9e\u9645\u7c7b\u578b\u53ef\u4ee5\u662f\u4efb\u610f1~8\u5b57\u8282\u6574\u6570\u7c7b\u578b\u6216\u6d6e\u70b9\u7c7b\u578b\u3002 obstream::write_ix \u00b6 \u5c0632/64\u4f4d\u6574\u6570\u503c\u4ee57Bit Encoded Int\u65b9\u5f0f\u538b\u7f29\u540e\u5199\u5165\u6d41\u3002 template < typename _Intty > void obstream :: write_ix ( _Intty value ); \u53c2\u6570 \u00b6 value \u8981\u5199\u5165\u7684\u503c\u3002 \u6ce8\u610f \u00b6 _Intty \u7c7b\u578b\u53ea\u80fd\u662f\u5982\u4e0b\u7c7b\u578b int32_t int64_t \u6b64\u51fd\u6570\u538b\u7f29\u7f16\u7801\u65b9\u5f0f\u517c\u5bb9\u5fae\u8f6fdotnet\u5982\u4e0b\u51fd\u6570 BinaryWriter.Write7BitEncodedInt BinaryWriter.Write7BitEncodedInt64 obstream::write_v \u00b6 \u5199\u5165\u4e8c\u8fdb\u5236\u6570\u636e\uff0c\u5305\u542b\u957f\u5ea6\u5b57\u6bb5(7Bit Encoded Int). void write_v ( cxx17 :: string_view sv ); \u53c2\u6570 \u00b6 sv \u8981\u5199\u5165\u7684\u6570\u636e\u3002 \u6ce8\u610f \u00b6 \u6b64\u51fd\u6570\u5148\u4ee57Bit Encoded\u7f16\u7801\u65b9\u5f0f\u5199\u5165\u6570\u636e\u957f\u5ea6, \u518d\u8c03\u7528 write_bytes \u5199\u5165\u5b57\u8282\u6570\u636e. obstream::write_byte \u00b6 \u5199\u51651\u4e2a\u5b57\u8282\u3002 void write_byte ( uint8_t value ); \u53c2\u6570 \u00b6 value \u8981\u5199\u5165\u7684\u503c\u3002 \u6ce8\u610f \u00b6 \u6b64\u51fd\u6570\u529f\u80fd\u7b49\u4ef7\u4e8e obstream::write obstream::write_bytes \u00b6 \u5199\u5165\u5b57\u8282\u6570\u7ec4\u3002 void write_bytes ( cxx17 :: string_view sv ); void write_bytes ( const void * data , int length ); void write_bytes ( std :: streamoff offset , const void * data , int length ); \u53c2\u6570 \u00b6 sv \u5199\u5165string_view\u5305\u88c5\u7684\u5b57\u8282\u6570\u7ec4. data \u8981\u5199\u5165\u5b57\u8282\u6570\u7ec4\u7684\u9996\u5730\u5740. length \u8981\u5199\u5165\u5b57\u8282\u6570\u7ec4\u7684\u957f\u5ea6. offset \u8981\u5199\u5165\u5b57\u8282\u6570\u7ec4\u7684\u76ee\u6807\u504f\u79fb. \u6ce8\u610f \u00b6 offset + length \u7684\u503c\u5fc5\u987b\u5c0f\u4e8e obstream::length obstream::empty \u00b6 \u5224\u65ad\u6d41\u662f\u5426\u4e3a\u7a7a\u3002 bool empty () const ; \u8fd4\u56de\u503c \u00b6 true \u7a7a; false \u975e\u7a7a\u3002 \u6ce8\u610f \u00b6 \u6b64\u51fd\u6570\u7b49\u4ef7\u4e8e length == 0\u3002 obstream::data \u00b6 \u83b7\u53d6\u6570\u636e\u6307\u9488\u3002 const char * data () const ; char * data (); \u8fd4\u56de\u503c \u00b6 \u5b57\u8282\u6d41\u6570\u636e\u9996\u5730\u5740\u3002 obstream::length \u00b6 \u83b7\u53d6\u6d41\u957f\u5ea6\u3002 size_t length () const ; \u8fd4\u56de\u503c \u00b6 \u8fd4\u56de\u6d41\u4e2d\u5305\u542b\u7684\u603b\u5b57\u8282\u6570\u3002 obstream::buffer \u00b6 \u83b7\u53d6\u6d41\u5185\u90e8\u7f13\u51b2\u533a\u3002 const std :: vector < char >& buffer () const ; std :: vector < char >& buffer (); \u8fd4\u56de\u503c \u00b6 \u6d41\u5185\u90e8\u7f13\u51b2\u533a\u5f15\u7528\uff0c\u53ef\u4ee5\u4f7f\u7528 std::move \u53d6\u8d70\u3002 \u793a\u4f8b \u00b6 // obstream_buffer.cpp // compile with: /EHsc #include \"yasio/obstream.hpp\" int main ( ) { using namespace yasio ; using namespace cxx17 ; obstream obs ; obs . write_v ( \"hello world!\" ); const auto & const_buffer = obs . buffer (); // after this line, the obs will be empty auto move_buffer = std :: move ( obs . buffer ()); return 0 ; } obstream::clear \u00b6 \u6e05\u7406\u6d41\uff0c\u4ee5\u4fbf\u590d\u7528\u3002 void clear (); \u6ce8\u610f \u00b6 \u6b64\u51fd\u6570\u4e0d\u4f1a\u91ca\u653ebuffer\u5185\u5b58\uff0c\u5bf9\u4e8e\u9ad8\u6548\u5730\u590d\u7528\u5e8f\u5217\u5316\u5668\u975e\u5e38\u6709\u7528\u3002 obstream::shrink_to_fit \u00b6 \u91ca\u653e\u6d41\u5185\u90e8\u7f13\u51b2\u533a\u591a\u4f59\u5185\u5b58\u3002 void shrink_to_fit (); obstream::save \u00b6 \u5c06\u6d41\u4e2d\u7684\u4e8c\u8fdb\u5236\u5b57\u8282\u6570\u636e\u4fdd\u5b58\u5230\u6587\u4ef6\u3002 void save ( const char * filename ) const ; \u793a\u4f8b \u00b6 // obstream_save.cpp // compile with: /EHsc #include \"yasio/obstream.hpp\" #include \"yasio/ibstream.hpp\" int main ( ) { using namespace yasio ; using namespace cxx17 ; obstream obs ; obs . write_v ( \"hello world!\" ); obs . save ( \"obstream_save.bin\" ); ibstream ibs ; if ( ibs . load ( \"obstream_save.bin\" )) { // output should be: hello world! try { std :: count << ibs . read_v () << \" \\n \" ; } catch ( const std :: exception & ex ) { std :: count << \"read_v fail: \" << << ex . message () << \" \\n \" ; } } return 0 ; } \u8bf7\u53c2\u9605 \u00b6 ibstream_view Class ibstream Class","title":"obstream\u7c7b"},{"location":"api/reference/obstream-class/#obstream-class","text":"\u63d0\u4f9b\u4e8c\u8fdb\u5236\u5e8f\u5217\u5316\u529f\u80fd\u3002 \u6ce8\u610f \u81ea3.35.0\u8d77\uff0c\u4f18\u5316\u4e3a\u7c7b\u6a21\u677fbasic_obstream\u5b9e\u73b0\uff0c\u4f53\u73b0\u4e86C++\u6a21\u677f\u5f3a\u5927\u7684\u4ee3\u7801\u590d\u7528\u80fd\u529b\u3002 obstream \u5f53\u5199\u5165int16~int64\u548cfloat/double\u7c7b\u578b\u65f6, \u4f1a\u81ea\u52a8\u5c06\u4e3b\u673a\u5b57\u8282\u5e8f\u8f6c\u6362\u4e3a\u7f51\u7edc\u5b57\u8282\u5e8f\u3002 fast_obstream \u4e0d\u4f1a\u8f6c\u6362\u4efb\u4f55\u5b57\u8282\u5e8f\u3002","title":"obstream Class"},{"location":"api/reference/obstream-class/#_1","text":"namespace yasio { using obstream = basic_obstream < endian :: network_convert_tag > ; using fast_obstream = basic_obstream < endian :: host_convert_tag > ; }","title":"\u8bed\u6cd5"},{"location":"api/reference/obstream-class/#_2","text":"","title":"\u6210\u5458"},{"location":"api/reference/obstream-class/#_3","text":"Name Description obstream::obstream \u6784\u90201\u4e2a obstream \u5bf9\u8c61","title":"\u516c\u5171\u6784\u9020\u51fd\u6570"},{"location":"api/reference/obstream-class/#_4","text":"Name Description obstream::write \u51fd\u6570\u6a21\u677f\uff0c\u5199\u5165\u6570\u503c obstream::write_ix \u51fd\u6570\u6a21\u677f\uff0c\u5199\u5165( 7bit Encoded Int/Int64 )\u6570\u503c obstream::write_v \u5199\u5165\u5e26\u957f\u5ea6\u57df( 7bit Encoded Int )\u7684\u4e8c\u8fdb\u5236\u6570\u636e obstream::write_byte \u5199\u51651\u4e2a\u5b57\u8282 obstream::write_bytes \u5199\u5165\u6307\u5b9a\u957f\u5ea6\u4e8c\u8fdb\u5236\u6570\u636e obstream::empty \u68c0\u67e5\u6d41\u662f\u5426\u4e3a\u7a7a obstream::data \u83b7\u53d6\u6d41\u6570\u636e\u6307\u9488 obstream::length \u83b7\u53d6\u6d41\u6570\u636e\u5927\u5c0f obstream::buffer \u83b7\u53d6\u6d41\u5185\u90e8\u7f13\u51b2\u533a obstream::clear \u6e05\u7406\u6d41\uff0c\u4ee5\u4fbf\u590d\u7528 obstream::shrink_to_fit \u91ca\u653e\u6d41\u5185\u90e8\u7f13\u51b2\u533a\u591a\u4f59\u5185\u5b58 obstream::save \u4fdd\u5b58\u6d41\u4e8c\u8fdb\u5236\u6570\u636e\u5230\u6587\u4ef6\u7cfb\u7edf","title":"\u516c\u5171\u65b9\u6cd5"},{"location":"api/reference/obstream-class/#_5","text":"\u5934\u6587\u4ef6: obstream.hpp","title":"\u8981\u6c42"},{"location":"api/reference/obstream-class/#obstreamobstream","text":"\u6784\u9020 obstream \u5bf9\u8c61\u3002 obstream ( size_t capacity = 128 ); obstream ( const obstream & rhs ); obstream ( obstream && rhs );","title":" obstream::obstream"},{"location":"api/reference/obstream-class/#obstreamwrite","text":"\u5199\u5165\u6570\u503c\u7c7b\u578b template < typename _Nty > void obstream :: write ( _Nty value );","title":" obstream::write"},{"location":"api/reference/obstream-class/#_6","text":"value \u8981\u5199\u5165\u7684\u503c","title":"\u53c2\u6570"},{"location":"api/reference/obstream-class/#_7","text":"_Nty \u5b9e\u9645\u7c7b\u578b\u53ef\u4ee5\u662f\u4efb\u610f1~8\u5b57\u8282\u6574\u6570\u7c7b\u578b\u6216\u6d6e\u70b9\u7c7b\u578b\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/obstream-class/#obstreamwrite_ix","text":"\u5c0632/64\u4f4d\u6574\u6570\u503c\u4ee57Bit Encoded Int\u65b9\u5f0f\u538b\u7f29\u540e\u5199\u5165\u6d41\u3002 template < typename _Intty > void obstream :: write_ix ( _Intty value );","title":" obstream::write_ix"},{"location":"api/reference/obstream-class/#_8","text":"value \u8981\u5199\u5165\u7684\u503c\u3002","title":"\u53c2\u6570"},{"location":"api/reference/obstream-class/#_9","text":"_Intty \u7c7b\u578b\u53ea\u80fd\u662f\u5982\u4e0b\u7c7b\u578b int32_t int64_t \u6b64\u51fd\u6570\u538b\u7f29\u7f16\u7801\u65b9\u5f0f\u517c\u5bb9\u5fae\u8f6fdotnet\u5982\u4e0b\u51fd\u6570 BinaryWriter.Write7BitEncodedInt BinaryWriter.Write7BitEncodedInt64","title":"\u6ce8\u610f"},{"location":"api/reference/obstream-class/#obstreamwrite_v","text":"\u5199\u5165\u4e8c\u8fdb\u5236\u6570\u636e\uff0c\u5305\u542b\u957f\u5ea6\u5b57\u6bb5(7Bit Encoded Int). void write_v ( cxx17 :: string_view sv );","title":" obstream::write_v"},{"location":"api/reference/obstream-class/#_10","text":"sv \u8981\u5199\u5165\u7684\u6570\u636e\u3002","title":"\u53c2\u6570"},{"location":"api/reference/obstream-class/#_11","text":"\u6b64\u51fd\u6570\u5148\u4ee57Bit Encoded\u7f16\u7801\u65b9\u5f0f\u5199\u5165\u6570\u636e\u957f\u5ea6, \u518d\u8c03\u7528 write_bytes \u5199\u5165\u5b57\u8282\u6570\u636e.","title":"\u6ce8\u610f"},{"location":"api/reference/obstream-class/#obstreamwrite_byte","text":"\u5199\u51651\u4e2a\u5b57\u8282\u3002 void write_byte ( uint8_t value );","title":" obstream::write_byte"},{"location":"api/reference/obstream-class/#_12","text":"value \u8981\u5199\u5165\u7684\u503c\u3002","title":"\u53c2\u6570"},{"location":"api/reference/obstream-class/#_13","text":"\u6b64\u51fd\u6570\u529f\u80fd\u7b49\u4ef7\u4e8e obstream::write","title":"\u6ce8\u610f"},{"location":"api/reference/obstream-class/#obstreamwrite_bytes","text":"\u5199\u5165\u5b57\u8282\u6570\u7ec4\u3002 void write_bytes ( cxx17 :: string_view sv ); void write_bytes ( const void * data , int length ); void write_bytes ( std :: streamoff offset , const void * data , int length );","title":" obstream::write_bytes"},{"location":"api/reference/obstream-class/#_14","text":"sv \u5199\u5165string_view\u5305\u88c5\u7684\u5b57\u8282\u6570\u7ec4. data \u8981\u5199\u5165\u5b57\u8282\u6570\u7ec4\u7684\u9996\u5730\u5740. length \u8981\u5199\u5165\u5b57\u8282\u6570\u7ec4\u7684\u957f\u5ea6. offset \u8981\u5199\u5165\u5b57\u8282\u6570\u7ec4\u7684\u76ee\u6807\u504f\u79fb.","title":"\u53c2\u6570"},{"location":"api/reference/obstream-class/#_15","text":"offset + length \u7684\u503c\u5fc5\u987b\u5c0f\u4e8e obstream::length","title":"\u6ce8\u610f"},{"location":"api/reference/obstream-class/#obstreamempty","text":"\u5224\u65ad\u6d41\u662f\u5426\u4e3a\u7a7a\u3002 bool empty () const ;","title":" obstream::empty"},{"location":"api/reference/obstream-class/#_16","text":"true \u7a7a; false \u975e\u7a7a\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/obstream-class/#_17","text":"\u6b64\u51fd\u6570\u7b49\u4ef7\u4e8e length == 0\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/obstream-class/#obstreamdata","text":"\u83b7\u53d6\u6570\u636e\u6307\u9488\u3002 const char * data () const ; char * data ();","title":" obstream::data"},{"location":"api/reference/obstream-class/#_18","text":"\u5b57\u8282\u6d41\u6570\u636e\u9996\u5730\u5740\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/obstream-class/#obstreamlength","text":"\u83b7\u53d6\u6d41\u957f\u5ea6\u3002 size_t length () const ;","title":" obstream::length"},{"location":"api/reference/obstream-class/#_19","text":"\u8fd4\u56de\u6d41\u4e2d\u5305\u542b\u7684\u603b\u5b57\u8282\u6570\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/obstream-class/#obstreambuffer","text":"\u83b7\u53d6\u6d41\u5185\u90e8\u7f13\u51b2\u533a\u3002 const std :: vector < char >& buffer () const ; std :: vector < char >& buffer ();","title":" obstream::buffer"},{"location":"api/reference/obstream-class/#_20","text":"\u6d41\u5185\u90e8\u7f13\u51b2\u533a\u5f15\u7528\uff0c\u53ef\u4ee5\u4f7f\u7528 std::move \u53d6\u8d70\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/obstream-class/#_21","text":"// obstream_buffer.cpp // compile with: /EHsc #include \"yasio/obstream.hpp\" int main ( ) { using namespace yasio ; using namespace cxx17 ; obstream obs ; obs . write_v ( \"hello world!\" ); const auto & const_buffer = obs . buffer (); // after this line, the obs will be empty auto move_buffer = std :: move ( obs . buffer ()); return 0 ; }","title":"\u793a\u4f8b"},{"location":"api/reference/obstream-class/#obstreamclear","text":"\u6e05\u7406\u6d41\uff0c\u4ee5\u4fbf\u590d\u7528\u3002 void clear ();","title":" obstream::clear"},{"location":"api/reference/obstream-class/#_22","text":"\u6b64\u51fd\u6570\u4e0d\u4f1a\u91ca\u653ebuffer\u5185\u5b58\uff0c\u5bf9\u4e8e\u9ad8\u6548\u5730\u590d\u7528\u5e8f\u5217\u5316\u5668\u975e\u5e38\u6709\u7528\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/obstream-class/#obstreamshrink_to_fit","text":"\u91ca\u653e\u6d41\u5185\u90e8\u7f13\u51b2\u533a\u591a\u4f59\u5185\u5b58\u3002 void shrink_to_fit ();","title":" obstream::shrink_to_fit"},{"location":"api/reference/obstream-class/#obstreamsave","text":"\u5c06\u6d41\u4e2d\u7684\u4e8c\u8fdb\u5236\u5b57\u8282\u6570\u636e\u4fdd\u5b58\u5230\u6587\u4ef6\u3002 void save ( const char * filename ) const ;","title":" obstream::save"},{"location":"api/reference/obstream-class/#_23","text":"// obstream_save.cpp // compile with: /EHsc #include \"yasio/obstream.hpp\" #include \"yasio/ibstream.hpp\" int main ( ) { using namespace yasio ; using namespace cxx17 ; obstream obs ; obs . write_v ( \"hello world!\" ); obs . save ( \"obstream_save.bin\" ); ibstream ibs ; if ( ibs . load ( \"obstream_save.bin\" )) { // output should be: hello world! try { std :: count << ibs . read_v () << \" \\n \" ; } catch ( const std :: exception & ex ) { std :: count << \"read_v fail: \" << << ex . message () << \" \\n \" ; } } return 0 ; }","title":"\u793a\u4f8b"},{"location":"api/reference/obstream-class/#_24","text":"ibstream_view Class ibstream Class","title":"\u8bf7\u53c2\u9605"},{"location":"api/reference/others/","text":"\u5176\u4ed6\u5e38\u7528API \u00b6 \u547d\u540d\u7a7a\u95f4 \u00b6 namespace yasio {} \u516c\u5171\u65b9\u6cd5 \u00b6 Name Description yasio::host_to_network \u4e3b\u673a\u5b57\u8282\u5e8f\u8f6c\u7f51\u7edc\u5b57\u8282\u5e8f yasio::network_to_host \u7f51\u7edc\u5b57\u8282\u5e8f\u8f6c\u4e3b\u673a\u5b57\u8282\u5e8f yasio::xhighp_clock \u83b7\u53d6\u7eb3\u79d2\u7ea7\u65f6\u95f4\u6233 yasio::highp_clock \u83b7\u53d6\u5fae\u79d2\u7ea7\u65f6\u95f4\u6233 yasio::clock \u83b7\u53d6\u6beb\u79d2\u7ea7\u65f6\u95f4\u6233 yasio::set_thread_name \u8bbe\u7f6e\u8c03\u7528\u8005\u7ebf\u7a0b\u540d yasio::basic_strfmt \u683c\u5f0f\u5316\u5b57\u7b26\u4e32 yasio::host_to_network \u00b6 \u4e3b\u673a\u5b57\u8282\u5e8f\u8f6c\u7f51\u7edc\u5b57\u8282\u5e8f\u3002 \u5934\u6587\u4ef6 \u00b6 yasio/detail/endian_portable.hpp template < typename _Ty > inline _Ty host_to_network ( _Ty value ); inline int host_to_network ( int value , int size ); \u53c2\u6570 \u00b6 value \u8981\u8f6c\u6362\u7684\u6570\u503c\uff0cvalue\u7c7b\u578b _Ty \u53ef\u4ee5\u662f\u4efb\u610f1~8\u5b57\u8282\u6570\u503c\u7c7b\u578b\u3002 size \u8981\u8f6c\u6362\u7684\u6570\u503c\u6709\u6548\u5b57\u8282\u6570\uff0c\u53ea\u80fd\u662f1~4\u5b57\u8282\u3002 \u8fd4\u56de\u503c \u00b6 \u7f51\u7edc\u5b57\u8282\u5e8f\u6570\u503c\u3002 \u793a\u4f8b \u00b6 #include <stdio.h> #include <inttypes.h> #include \"yasio/detail/endian_portable.hpp\" int main (){ uint16_t v1 = 0x1122 ; uint32_t v2 = 0x11223344 ; uint64_t v3 = 0x1122334455667788 ; // output will be: net.v1=2211, net.v2=44332211, net.v3=8877665544332211 printf ( \"net.v1=%04\" PRIx16 \", net.v2=%08\" PRIx32 \", net.v3=%016\" PRIx64 \" \\n \" , yasio :: host_to_network ( v1 ), yasio :: host_to_network ( v2 ), yasio :: host_to_network ( v3 )); return 0 ; } yasio::network_to_host \u00b6 \u7f51\u7edc\u5b57\u8282\u5e8f\u8f6c\u4e3b\u673a\u5b57\u8282\u5e8f\u3002 \u5934\u6587\u4ef6 \u00b6 yasio/detail/endian_portable.hpp template < typename _Ty > inline _Ty network_to_host ( _Ty value ); inline int network_to_host ( int value , int size ); \u53c2\u6570 \u00b6 value \u8981\u8f6c\u6362\u7684\u6570\u503c\uff0cvalue\u7c7b\u578b _Ty \u53ef\u4ee5\u662f\u4efb\u610f1~8\u5b57\u8282\u6570\u503c\u7c7b\u578b\u3002 size \u8981\u8f6c\u6362\u7684\u6570\u503c\u6709\u6548\u5b57\u8282\u6570\uff0c\u53ea\u80fd\u662f1~4\u5b57\u8282\u3002 \u8fd4\u56de\u503c \u00b6 \u4e3b\u673a\u5b57\u8282\u5e8f\u6570\u503c\u3002 \u793a\u4f8b \u00b6 #include <stdio.h> #include <inttypes.h> #include \"yasio/detail/endian_portable.hpp\" int main (){ uint16_t v1 = 0x2211 ; uint32_t v2 = 0x44332211 ; uint64_t v3 = 0x8877665533442211 ; // output will be: net.v1=1122, net.v2=11223344, net.v3=1122334455667788 printf ( \"host.v1=%04\" PRIx16 \", host.v2=%08\" PRIx32 \", host.v3=%016\" PRIx64 \" \\n \" , yasio :: network_to_host ( v1 ), yasio :: network_to_host ( v2 ), yasio :: network_to_host ( v3 )); return 0 ; } yasio::xhighp_clock \u00b6 \u83b7\u53d6\u7eb3\u79d2\u7ea7\u65f6\u95f4\u6233\u3002 \u5934\u6587\u4ef6 \u00b6 yasio/detail/utils.hpp template < typename _Ty = steady_clock_t > inline highp_time_t xhighp_clock (); \u6a21\u677f\u53c2\u6570 \u00b6 _Ty yasio::steady_clock_t: \u8fd4\u56de\u5f53\u524d\u7cfb\u7edf\u65f6\u95f4\u65e0\u5173\u7684\u65f6\u95f4\u6233 yasio::system_clock_t: \u8fd4\u56de\u7cfb\u7edfUTC\u65f6\u95f4\u6233 \u8fd4\u56de\u503c \u00b6 \u7eb3\u79d2\u7ea7\u65f6\u95f4\u6233\u3002 yasio::highp_clock \u00b6 \u83b7\u53d6\u5fae\u79d2\u7ea7\u65f6\u95f4\u6233\u3002 \u5934\u6587\u4ef6 \u00b6 yasio/detail/utils.hpp template < typename _Ty = steady_clock_t > inline highp_time_t highp_clock (); \u6a21\u677f\u53c2\u6570 \u00b6 _Ty yasio::steady_clock_t : \u8fd4\u56de\u5f53\u524d\u7cfb\u7edf\u65f6\u95f4\u65e0\u5173\u7684\u65f6\u95f4\u6233 yasio::system_clock_t : \u8fd4\u56de\u7cfb\u7edfUTC\u65f6\u95f4\u6233 \u8fd4\u56de\u503c \u00b6 \u5fae\u79d2\u7ea7\u65f6\u95f4\u6233\u3002 yasio::clock \u00b6 \u83b7\u53d6\u6beb\u79d2\u7ea7\u65f6\u95f4\u6233\u3002 \u5934\u6587\u4ef6 \u00b6 yasio/detail/utils.hpp template < typename _Ty = steady_clock_t > inline highp_time_t clock (); \u6a21\u677f\u53c2\u6570 \u00b6 _Ty yasio::steady_clock_t : \u8fd4\u56de\u5f53\u524d\u7cfb\u7edf\u65f6\u95f4\u65e0\u5173\u7684\u65f6\u95f4\u6233 yasio::system_clock_t : \u8fd4\u56de\u7cfb\u7edfUTC\u65f6\u95f4\u6233 \u8fd4\u56de\u503c \u00b6 \u6beb\u79d2\u7ea7\u65f6\u95f4\u6233\u3002 yasio::set_thread_name \u00b6 \u8bbe\u7f6e\u8c03\u7528\u8005\u7ebf\u7a0b\u540d\u3002 \u5934\u6587\u4ef6 \u00b6 yasio/detail/thread_name.hpp inline void set_thread_name ( const char * name ); \u53c2\u6570 \u00b6 name \u9700\u8981\u8bbe\u7f6e\u7ebf\u7a0b\u540d\u79f0 \u6ce8\u610f \u00b6 \u6b64\u51fd\u6570\u7528\u4e8e\u8bca\u65ad\u591a\u7ebf\u7a0b\u7a0b\u5e8f\u975e\u5e38\u6709\u7528\u3002 yasio::basic_strfmt \u00b6 \u51fd\u6570\u6a21\u677f\uff0c\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\u6216\u8005\u5bbd\u5b57\u7b26\u4e32\u3002 \u5934\u6587\u4ef6 \u00b6 yasio/detail/strfmt.hpp template < class _Elem , class _Traits = std :: char_traits < _Elem > , class _Alloc = std :: allocator < _Elem >> inline std :: basic_string < _Elem , _Traits , _Alloc > basic_strfmt ( size_t n , const _Elem * format , ...); \u53c2\u6570 \u00b6 n \u521d\u59cbbuffer\u5927\u5c0f format \u683c\u5f0f\u5b57\u7b26\u4e32\uff0c\u548c\u6807\u51c6\u5e93 printf \u76f8\u540c \u8fd4\u56de\u503c \u00b6 \u8fd4\u56de\u683c\u5f0f\u5316\u540e\u7684 std::string \u7c7b\u578b\u5b57\u7b26\u4e32\u3002 \u6ce8\u610f \u00b6 \u5b9e\u9645\u4f7f\u7528\uff0c\u53ef\u76f4\u63a5\u4f7f\u7528\u5df2\u7ecf\u5b9a\u4e49\u597d\u7684\u522b\u540d yasio::strfmt : \u683c\u5f0f\u5316\u5b57\u7b26\u4e32 yasio::wcsfmt : \u683c\u5f0f\u5316\u5bbd\u5b57\u7b26\u4e32 \u793a\u4f8b \u00b6 #include \"yasio/detail/strfmt.hpp\" int main () { std :: string str1 = yasio :: strfmt ( 64 , \"My age is %d\" , 19 ); std :: wstring str2 = yasio :: wcsfmt ( 64 , L \"My age is %d\" , 19 ); return 0 ; }","title":"\u5176\u4ed6\u5e38\u7528API"},{"location":"api/reference/others/#api","text":"","title":"\u5176\u4ed6\u5e38\u7528API"},{"location":"api/reference/others/#_1","text":"namespace yasio {}","title":"\u547d\u540d\u7a7a\u95f4"},{"location":"api/reference/others/#_2","text":"Name Description yasio::host_to_network \u4e3b\u673a\u5b57\u8282\u5e8f\u8f6c\u7f51\u7edc\u5b57\u8282\u5e8f yasio::network_to_host \u7f51\u7edc\u5b57\u8282\u5e8f\u8f6c\u4e3b\u673a\u5b57\u8282\u5e8f yasio::xhighp_clock \u83b7\u53d6\u7eb3\u79d2\u7ea7\u65f6\u95f4\u6233 yasio::highp_clock \u83b7\u53d6\u5fae\u79d2\u7ea7\u65f6\u95f4\u6233 yasio::clock \u83b7\u53d6\u6beb\u79d2\u7ea7\u65f6\u95f4\u6233 yasio::set_thread_name \u8bbe\u7f6e\u8c03\u7528\u8005\u7ebf\u7a0b\u540d yasio::basic_strfmt \u683c\u5f0f\u5316\u5b57\u7b26\u4e32","title":"\u516c\u5171\u65b9\u6cd5"},{"location":"api/reference/others/#yasiohost_to_network","text":"\u4e3b\u673a\u5b57\u8282\u5e8f\u8f6c\u7f51\u7edc\u5b57\u8282\u5e8f\u3002","title":" yasio::host_to_network"},{"location":"api/reference/others/#_3","text":"yasio/detail/endian_portable.hpp template < typename _Ty > inline _Ty host_to_network ( _Ty value ); inline int host_to_network ( int value , int size );","title":"\u5934\u6587\u4ef6"},{"location":"api/reference/others/#_4","text":"value \u8981\u8f6c\u6362\u7684\u6570\u503c\uff0cvalue\u7c7b\u578b _Ty \u53ef\u4ee5\u662f\u4efb\u610f1~8\u5b57\u8282\u6570\u503c\u7c7b\u578b\u3002 size \u8981\u8f6c\u6362\u7684\u6570\u503c\u6709\u6548\u5b57\u8282\u6570\uff0c\u53ea\u80fd\u662f1~4\u5b57\u8282\u3002","title":"\u53c2\u6570"},{"location":"api/reference/others/#_5","text":"\u7f51\u7edc\u5b57\u8282\u5e8f\u6570\u503c\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/others/#_6","text":"#include <stdio.h> #include <inttypes.h> #include \"yasio/detail/endian_portable.hpp\" int main (){ uint16_t v1 = 0x1122 ; uint32_t v2 = 0x11223344 ; uint64_t v3 = 0x1122334455667788 ; // output will be: net.v1=2211, net.v2=44332211, net.v3=8877665544332211 printf ( \"net.v1=%04\" PRIx16 \", net.v2=%08\" PRIx32 \", net.v3=%016\" PRIx64 \" \\n \" , yasio :: host_to_network ( v1 ), yasio :: host_to_network ( v2 ), yasio :: host_to_network ( v3 )); return 0 ; }","title":"\u793a\u4f8b"},{"location":"api/reference/others/#yasionetwork_to_host","text":"\u7f51\u7edc\u5b57\u8282\u5e8f\u8f6c\u4e3b\u673a\u5b57\u8282\u5e8f\u3002","title":" yasio::network_to_host"},{"location":"api/reference/others/#_7","text":"yasio/detail/endian_portable.hpp template < typename _Ty > inline _Ty network_to_host ( _Ty value ); inline int network_to_host ( int value , int size );","title":"\u5934\u6587\u4ef6"},{"location":"api/reference/others/#_8","text":"value \u8981\u8f6c\u6362\u7684\u6570\u503c\uff0cvalue\u7c7b\u578b _Ty \u53ef\u4ee5\u662f\u4efb\u610f1~8\u5b57\u8282\u6570\u503c\u7c7b\u578b\u3002 size \u8981\u8f6c\u6362\u7684\u6570\u503c\u6709\u6548\u5b57\u8282\u6570\uff0c\u53ea\u80fd\u662f1~4\u5b57\u8282\u3002","title":"\u53c2\u6570"},{"location":"api/reference/others/#_9","text":"\u4e3b\u673a\u5b57\u8282\u5e8f\u6570\u503c\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/others/#_10","text":"#include <stdio.h> #include <inttypes.h> #include \"yasio/detail/endian_portable.hpp\" int main (){ uint16_t v1 = 0x2211 ; uint32_t v2 = 0x44332211 ; uint64_t v3 = 0x8877665533442211 ; // output will be: net.v1=1122, net.v2=11223344, net.v3=1122334455667788 printf ( \"host.v1=%04\" PRIx16 \", host.v2=%08\" PRIx32 \", host.v3=%016\" PRIx64 \" \\n \" , yasio :: network_to_host ( v1 ), yasio :: network_to_host ( v2 ), yasio :: network_to_host ( v3 )); return 0 ; }","title":"\u793a\u4f8b"},{"location":"api/reference/others/#yasioxhighp_clock","text":"\u83b7\u53d6\u7eb3\u79d2\u7ea7\u65f6\u95f4\u6233\u3002","title":" yasio::xhighp_clock"},{"location":"api/reference/others/#_11","text":"yasio/detail/utils.hpp template < typename _Ty = steady_clock_t > inline highp_time_t xhighp_clock ();","title":"\u5934\u6587\u4ef6"},{"location":"api/reference/others/#_12","text":"_Ty yasio::steady_clock_t: \u8fd4\u56de\u5f53\u524d\u7cfb\u7edf\u65f6\u95f4\u65e0\u5173\u7684\u65f6\u95f4\u6233 yasio::system_clock_t: \u8fd4\u56de\u7cfb\u7edfUTC\u65f6\u95f4\u6233","title":"\u6a21\u677f\u53c2\u6570"},{"location":"api/reference/others/#_13","text":"\u7eb3\u79d2\u7ea7\u65f6\u95f4\u6233\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/others/#yasiohighp_clock","text":"\u83b7\u53d6\u5fae\u79d2\u7ea7\u65f6\u95f4\u6233\u3002","title":" yasio::highp_clock"},{"location":"api/reference/others/#_14","text":"yasio/detail/utils.hpp template < typename _Ty = steady_clock_t > inline highp_time_t highp_clock ();","title":"\u5934\u6587\u4ef6"},{"location":"api/reference/others/#_15","text":"_Ty yasio::steady_clock_t : \u8fd4\u56de\u5f53\u524d\u7cfb\u7edf\u65f6\u95f4\u65e0\u5173\u7684\u65f6\u95f4\u6233 yasio::system_clock_t : \u8fd4\u56de\u7cfb\u7edfUTC\u65f6\u95f4\u6233","title":"\u6a21\u677f\u53c2\u6570"},{"location":"api/reference/others/#_16","text":"\u5fae\u79d2\u7ea7\u65f6\u95f4\u6233\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/others/#yasioclock","text":"\u83b7\u53d6\u6beb\u79d2\u7ea7\u65f6\u95f4\u6233\u3002","title":" yasio::clock"},{"location":"api/reference/others/#_17","text":"yasio/detail/utils.hpp template < typename _Ty = steady_clock_t > inline highp_time_t clock ();","title":"\u5934\u6587\u4ef6"},{"location":"api/reference/others/#_18","text":"_Ty yasio::steady_clock_t : \u8fd4\u56de\u5f53\u524d\u7cfb\u7edf\u65f6\u95f4\u65e0\u5173\u7684\u65f6\u95f4\u6233 yasio::system_clock_t : \u8fd4\u56de\u7cfb\u7edfUTC\u65f6\u95f4\u6233","title":"\u6a21\u677f\u53c2\u6570"},{"location":"api/reference/others/#_19","text":"\u6beb\u79d2\u7ea7\u65f6\u95f4\u6233\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/others/#yasioset_thread_name","text":"\u8bbe\u7f6e\u8c03\u7528\u8005\u7ebf\u7a0b\u540d\u3002","title":" yasio::set_thread_name"},{"location":"api/reference/others/#_20","text":"yasio/detail/thread_name.hpp inline void set_thread_name ( const char * name );","title":"\u5934\u6587\u4ef6"},{"location":"api/reference/others/#_21","text":"name \u9700\u8981\u8bbe\u7f6e\u7ebf\u7a0b\u540d\u79f0","title":"\u53c2\u6570"},{"location":"api/reference/others/#_22","text":"\u6b64\u51fd\u6570\u7528\u4e8e\u8bca\u65ad\u591a\u7ebf\u7a0b\u7a0b\u5e8f\u975e\u5e38\u6709\u7528\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/others/#yasiobasic_strfmt","text":"\u51fd\u6570\u6a21\u677f\uff0c\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\u6216\u8005\u5bbd\u5b57\u7b26\u4e32\u3002","title":" yasio::basic_strfmt"},{"location":"api/reference/others/#_23","text":"yasio/detail/strfmt.hpp template < class _Elem , class _Traits = std :: char_traits < _Elem > , class _Alloc = std :: allocator < _Elem >> inline std :: basic_string < _Elem , _Traits , _Alloc > basic_strfmt ( size_t n , const _Elem * format , ...);","title":"\u5934\u6587\u4ef6"},{"location":"api/reference/others/#_24","text":"n \u521d\u59cbbuffer\u5927\u5c0f format \u683c\u5f0f\u5b57\u7b26\u4e32\uff0c\u548c\u6807\u51c6\u5e93 printf \u76f8\u540c","title":"\u53c2\u6570"},{"location":"api/reference/others/#_25","text":"\u8fd4\u56de\u683c\u5f0f\u5316\u540e\u7684 std::string \u7c7b\u578b\u5b57\u7b26\u4e32\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/others/#_26","text":"\u5b9e\u9645\u4f7f\u7528\uff0c\u53ef\u76f4\u63a5\u4f7f\u7528\u5df2\u7ecf\u5b9a\u4e49\u597d\u7684\u522b\u540d yasio::strfmt : \u683c\u5f0f\u5316\u5b57\u7b26\u4e32 yasio::wcsfmt : \u683c\u5f0f\u5316\u5bbd\u5b57\u7b26\u4e32","title":"\u6ce8\u610f"},{"location":"api/reference/others/#_27","text":"#include \"yasio/detail/strfmt.hpp\" int main () { std :: string str1 = yasio :: strfmt ( 64 , \"My age is %d\" , 19 ); std :: wstring str2 = yasio :: wcsfmt ( 64 , L \"My age is %d\" , 19 ); return 0 ; }","title":"\u793a\u4f8b"},{"location":"api/reference/xxsocket-class/","text":"xxsocket Class \u00b6 \u5c01\u88c5\u5e95\u5c42bsd socket\u5e38\u7528API\uff0c\u5c4f\u853d\u5404\u64cd\u4f5c\u7cfb\u7edf\u5e73\u53f0\u5dee\u5f02\uff0cyasio\u7684\u8d77\u6e90\u3002 \u7279\u522b\u6ce8\u610f xxsocket\u9664\u4e86 accept_n \u4ee5\u5916\u7684\u6240\u6709 xxx_n \u63a5\u53e3\u5747\u4f1a\u5c06\u5f53\u524dsocket\u5bf9\u8c61\u5e95\u5c42\u63cf\u8ff0\u7b26\u8bbe\u7f6e\u4e3a\u975e\u963b\u585e\u6a21\u5f0f\uff0c\u4e14\u4e0d\u4f1a\u6062\u590d\u3002 \u8bed\u6cd5 \u00b6 namespace yasio { namespace inet { class xxsocket ; } } \u6210\u5458 \u00b6 Name Description xxsocket::xxsocket \u6784\u9020\u4e00\u4e2a xxsocket \u5bf9\u8c61 \u516c\u5171\u65b9\u6cd5 \u00b6 Name Description xxsocket::xpconnect \u5efa\u7acbTCP\u8fde\u63a5 xxsocket::xpconnect_n \u975e\u963b\u585e\u65b9\u5f0f\u5efa\u7acbTCP\u8fde\u63a5 xxsocket::pconnect \u5efa\u7acbTCP\u8fde\u63a5 xxsocket::pconnect_n \u975e\u963b\u585e\u65b9\u5f0f\u5efa\u7acbTCP\u8fde\u63a5 xxsocket::pserve \u521b\u5efatcp\u670d\u52a1\u7aef xxsocket::swap \u4ea4\u6362socket\u63cf\u8ff0\u7b26\u53e5\u67c4 xxsocket::open \u6253\u5f00socket xxsocket::reopen \u91cd\u65b0\u6253\u5f00socket xxsocket::is_open \u68c0\u67e5socket\u662f\u5426\u6253\u5f00 xxsocket::native_handle \u83b7\u53d6socket\u53e5\u67c4 xxsocket::release_handle \u91ca\u653esocket\u53e5\u67c4\u63a7\u5236\u6743 xxsocket::set_nonblocking \u5c06socket\u8bbe\u7f6e\u4e3a\u975e\u963b\u585e\u6a21\u5f0f xxsocket::test_nonblocking \u68c0\u6d4bsocket\u662f\u5426\u4e3a\u975e\u963b\u585e\u6a21\u5f0f xxsocket::bind \u7ed1\u5b9a\u6307\u5b9a\u672c\u5730\u6307\u5b9a\u7f51\u5361\u5730\u5740 xxsocket::bind_any \u7ed1\u5b9a\u672c\u5730\u4efb\u610f\u5730\u5740 xxsocket::listen \u5f00\u59cbTCP\u76d1\u542c xxsocket::accept \u63a5\u53d7\u4e00\u4e2aTCP\u5ba2\u6237\u7aef\u8fde\u63a5 xxsocket::accept_n \u975e\u963b\u585e\u65b9\u5f0f\u63a5\u53d7TCP\u8fde\u63a5 xxsocket::connect \u5efa\u7acb\u8fde\u63a5 xxsocket::connect_n \u975e\u963b\u585e\u65b9\u5f0f\u5efa\u7acb\u8fde\u63a5 xxsocket::send \u53d1\u9001\u6570\u636e xxsocket::send_n \u975e\u963b\u585e\u65b9\u5f0f\u53d1\u9001\u6570\u636e xxsocket::recv \u63a5\u53d7\u6570\u636e xxsocket::recv_n \u975e\u963b\u585e\u65b9\u5f0f\u63a5\u53d7\u6570\u636e xxsocket::sendto \u53d1\u9001DGRAM\u6570\u636e\u5230\u6307\u5b9a\u5730\u5740 xxsocket::recvfrom \u63a5\u53d7DGRAM\u6570\u636e xxsocket::handle_write_ready \u7b49\u5f85socket\u53ef\u5199 xxsocket::handle_read_ready \u7b49\u5f85socket\u53ef\u8bfb xxsocket::local_endpoint \u83b7\u53d6socket\u672c\u5730\u5730\u5740 xxsocket::peer_endpoint \u83b7\u53d6socket\u8fdc\u7aef\u5730\u5740 xxsocket::set_keepalive \u8bbe\u7f6etcp keepalive xxsocket::reuse_address \u8bbe\u7f6esocket\u662f\u5426\u91cd\u7528\u5730\u5740 xxsocket::exclusive_address \u8bbe\u7f6esocket\u662f\u5426\u963b\u6b62\u5730\u5740\u91cd\u7528 xxsocket::select \u76d1\u542csocket\u4e8b\u4ef6 xxsocket::shutdown \u505c\u6b62socket\u6536\u53d1 xxsocket::close \u5173\u95edsocket xxsocket::tcp_rtt \u83b7\u53d6tcp rtt. xxsocket::get_last_errno \u83b7\u53d6\u6700\u8fd1socket\u9519\u8bef\u7801 xxsocket::set_last_errno \u8bbe\u7f6e\u6700\u8fd1socket\u9519\u8bef\u7801 xxsocket::strerror \u5c06socket\u9519\u8bef\u7801\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32 xxsocket::gai_strerror \u5c06getaddrinfo\u8fd4\u56de\u503c\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32 xxsocket::resolve \u89e3\u6790\u57df\u540d xxsocket::resolve_v4 \u89e3\u6790\u57df\u540d\u5305\u542b\u7684ipv4\u5730\u5740 xxsocket::resolve_v6 \u89e3\u6790\u57df\u540d\u5305\u542b\u7684ipv6\u5730\u5740 xxsocket::resolve_v4to6 \u89e3\u6790\u57df\u540d\u5305\u542b\u7684ipv4\u5730\u5740\u5e76\u8f6c\u6362\u4e3aipv6\u7684V4MAPPED\u683c\u5f0f xxsocket::resolve_tov6 \u89e3\u6790\u57df\u540d\u5305\u542b\u7684\u6240\u6709\u5730\u5740\uff0cipv4\u5730\u5740\u4f1a\u8f6c\u6362\u4e3aipv6\u7684V4MAPPED\u683c\u5f0f xxsocket::getipsv \u83b7\u53d6\u672c\u673a\u652f\u6301\u7684ip\u534f\u8bae\u6808\u7248\u672c\u6807\u5fd7\u4f4d xxsocket::traverse_local_address \u679a\u4e3e\u672c\u673a\u5730\u5740 xxsocket::xxsocket \u00b6 \u6784\u9020 xxsocket \u5bf9\u8c61\u3002 xxsocket :: xxsocket (); xxsocket :: xxsocket ( socket_native_type handle ); xxsocket :: xxsocket ( xxsocket && right ); xxsocket :: xxsocket ( int af , int type , int protocol ); \u53c2\u6570 \u00b6 handle \u901a\u8fc7\u5df2\u6709socket\u53e5\u67c4\u6784\u9020 xxsocket \u5bf9\u8c61\u3002 right move\u6784\u9020\u51fd\u6570\u53f3\u503c\u5f15\u7528\u3002 af ip\u534f\u8bae\u5730\u5740\u7c7b\u578b\u3002 protocol \u534f\u8bae\u7c7b\u578b\uff0c\u5bf9\u4e8eTCP/UDP\u76f4\u63a5\u4f20 0 \u5c31\u53ef\u4ee5\u3002 xxsocket::xpconnect \u00b6 \u548c\u8fdc\u7a0b\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5\u3002 int xxsocket::xpconnect ( const char * hostname , u_short port , u_short local_port = 0 ); \u53c2\u6570 \u00b6 hostname \u8981\u8fde\u63a5\u670d\u52a1\u5668\u4e3b\u673a\u540d\uff0c\u53ef\u4ee5\u662f IP\u5730\u5740 \u6216 \u57df\u540d \u3002 port \u8981\u8fde\u63a5\u670d\u52a1\u5668\u7684\u7aef\u53e3\u3002 local_port \u672c\u5730\u901a\u4fe1\u7aef\u53e3\u53f7\uff0c\u9ed8\u8ba4\u503c 0 \u8868\u793a\u968f\u673a\u5206\u914d\u3002 \u6ce8\u610f \u00b6 \u4f1a\u81ea\u52a8\u68c0\u6d4b\u672c\u673a\u652f\u6301\u7684ip\u534f\u8bae\u6808\u7248\u672c\u3002 \u8fd4\u56de\u503c \u00b6 0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 xxsocket::xpconnect_n \u00b6 \u548c\u8fdc\u7a0b\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5\u3002 int xxsocket::xpconnect_n ( const char * hostname , u_short port , const std :: chrono :: microseconds & wtimeout , u_short local_port = 0 ); \u53c2\u6570 \u00b6 hostname \u8981\u8fde\u63a5\u670d\u52a1\u5668\u4e3b\u673a\u540d\uff0c\u53ef\u4ee5\u662f IP\u5730\u5740 \u6216 \u57df\u540d \u3002 port \u8981\u8fde\u63a5\u670d\u52a1\u5668\u7684\u7aef\u53e3\u3002 local_port \u672c\u5730\u901a\u4fe1\u7aef\u53e3\u53f7\uff0c\u9ed8\u8ba4\u503c 0 \u8868\u793a\u968f\u673a\u5206\u914d\u3002 wtimeout \u5efa\u7acb\u8fde\u63a5\u8d85\u65f6\u65f6\u95f4\u3002 \u8fd4\u56de\u503c \u00b6 0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 \u6ce8\u610f \u00b6 \u4f1a\u81ea\u52a8\u68c0\u6d4b\u672c\u673a\u652f\u6301\u7684ip\u534f\u8bae\u6808\u3002 xxsocket::pconnect \u00b6 \u548c\u8fdc\u7a0b\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5\u3002 int xxsocket::pconnect ( const char * hostname , u_short port , u_short local_port = 0 ); int xxsocket::pconnect ( const endpoint & ep , u_short local_port = 0 ); \u53c2\u6570 \u00b6 hostname \u8981\u8fde\u63a5\u670d\u52a1\u5668\u4e3b\u673a\u540d\uff0c\u53ef\u4ee5\u662f IP\u5730\u5740 \u6216 \u57df\u540d \u3002 ep \u8981\u8fde\u63a5\u670d\u52a1\u5668\u7684\u5730\u5740\u3002 port \u8981\u8fde\u63a5\u670d\u52a1\u5668\u7684\u7aef\u53e3\u3002 local_port \u672c\u5730\u901a\u4fe1\u7aef\u53e3\u53f7\uff0c\u9ed8\u8ba4\u503c 0 \u8868\u793a\u968f\u673a\u5206\u914d\u3002 \u8fd4\u56de\u503c \u00b6 0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 \u6ce8\u610f \u00b6 \u4e0d\u4f1a\u68c0\u6d4b\u672c\u673a\u652f\u6301\u7684ip\u534f\u8bae\u6808\u3002 xxsocket::pconnect_n \u00b6 \u548c\u8fdc\u7a0b\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5\u3002 int pconnect_n ( const char * hostname , u_short port , const std :: chrono :: microseconds & wtimeout , u_short local_port = 0 ); int pconnect_n ( const char * hostname , u_short port , u_short local_port = 0 ); int pconnect_n ( const endpoint & ep , const std :: chrono :: microseconds & wtimeout , u_short local_port = 0 ); int pconnect_n ( const endpoint & ep , u_short local_port = 0 ); \u53c2\u6570 \u00b6 hostname \u8981\u8fde\u63a5\u670d\u52a1\u5668\u4e3b\u673a\u540d\uff0c\u53ef\u4ee5\u662f IP\u5730\u5740 \u6216 \u57df\u540d \u3002 ep \u8981\u8fde\u63a5\u670d\u52a1\u5668\u7684\u5730\u5740\u3002 port \u8981\u8fde\u63a5\u670d\u52a1\u5668\u7684\u7aef\u53e3\u3002 local_port \u672c\u5730\u901a\u4fe1\u7aef\u53e3\u53f7\uff0c\u9ed8\u8ba4\u503c 0 \u8868\u793a\u968f\u673a\u5206\u914d\u3002 wtimeout \u5efa\u7acb\u8fde\u63a5\u8d85\u65f6\u65f6\u95f4\u3002 \u8fd4\u56de\u503c \u00b6 0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 xxsocket::pserve \u00b6 \u5f00\u542f\u672c\u5730TCP\u670d\u52a1\u76d1\u542c\u3002 int pserve ( const char * addr , u_short port ); int pserve ( const endpoint & ep ); \u53c2\u6570 \u00b6 addr \u672c\u673a\u6307\u5b9a\u7f51\u5361 IP\u5730\u5740 \u3002 ep \u672c\u673a\u5730\u5740\u3002 port TCP\u76d1\u542c\u7aef\u53e3\u3002 \u8fd4\u56de\u503c \u00b6 0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 \u793a\u4f8b \u00b6 // xxsocket-serve.cpp #include <signal.h> #include <vector> #include \"yasio/xxsocket.hpp\" using namespace yasio ; using namespace yasio :: inet ; xxsocket g_server ; static bool g_stopped = false ; void process_exit ( int sig ) { if ( sig == SIGINT ) { g_stopped = true ; g_server . close (); } printf ( \"exit\" ); } int main () { signal ( SIGINT , process_exit ); if ( g_server . pserve ( \"0.0.0.0\" , 1219 ) != 0 ) return -1 ; const char reply_msg [] = \"hi, I'm server \\n \" ; do { xxsocket cs = g_server . accept (); if ( cs . is_open ()) { cs . send ( reply_msg , sizeof ( reply_msg ) - 1 ); std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 100 )); } } while ( ! g_stopped ); return 0 ; } xxsocket::swap \u00b6 \u4ea4\u6362\u5e95\u5c42socket\u53e5\u67c4\u3002 xxsocket & swap ( xxsocket & who ); \u53c2\u6570 \u00b6 who \u4ea4\u6362\u5bf9\u8c61\u3002 \u8fd4\u56de\u503c \u00b6 xxsocket \u5de6\u503c\u5bf9\u8c61\u7684\u5f15\u7528\u3002 xxsocket::open \u00b6 \u6253\u5f00\u4e00\u4e2asocket\u3002 bool open ( int af = AF_INET , int type = SOCK_STREAM , int protocol = 0 ); \u53c2\u6570 \u00b6 af \u5730\u5740\u7c7b\u578b\uff0c\u4f8b\u5982 AF_INET (ipv4)\uff0c AF_INET6 (ipv6)\u3002 type socket\u7c7b\u578b\uff0c SOCK_STREAM (TCP), SOCK_DGRAM (UDP)\u3002 protocol \u534f\u8bae\uff0c\u5bf9\u4e8eTCP/UDP\uff0c\u4f20 0 \u5373\u53ef\u3002 \u8fd4\u56de\u503c \u00b6 true : \u6210\u529f\uff0c false \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 xxsocket::reopen \u00b6 \u6253\u5f00\u4e00\u4e2asocket\u3002 bool reopen ( int af = AF_INET , int type = SOCK_STREAM , int protocol = 0 ); \u53c2\u6570 \u00b6 af \u5730\u5740\u7c7b\u578b\uff0c\u4f8b\u5982 AF_INET (ipv4)\uff0c AF_INET6 (ipv6)\u3002 type socket\u7c7b\u578b\uff0c SOCK_STREAM (TCP), SOCK_DGRAM (UDP)\u3002 protocol \u534f\u8bae\uff0c\u5bf9\u4e8eTCP/UDP\uff0c\u4f20 0 \u5373\u53ef\u3002 \u8fd4\u56de\u503c \u00b6 true : \u6210\u529f\uff0c false \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 \u6ce8\u610f \u00b6 \u5982\u679csocket\u5df2\u6253\u5f00\uff0c\u6b64\u51fd\u6570\u4f1a\u5148\u5173\u95ed\uff0c\u518d\u91cd\u65b0\u6253\u5f00\u3002 xxsocket::is_open \u00b6 \u5224\u65adsocket\u662f\u5426\u5df2\u6253\u5f00\u3002 bool is_open () const ; \u8fd4\u56de\u503c \u00b6 true : \u5df2\u6253\u5f00\uff0c false : \u672a\u6253\u5f00\u3002 xxsocket::native_handle \u00b6 \u83b7\u53d6socket\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 socket_native_type native_handle () const ; \u8fd4\u56de\u503c \u00b6 socket\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c yasio::inet::invalid_socket \u8868\u793a\u65e0\u6548socket\u3002 xxsocket::release_handle \u00b6 \u91ca\u653e\u5e95\u5c42socket\u63cf\u8ff0\u7b26\u63a7\u5236\u6743\u3002 socket_native_type release_handle () const ; \u8fd4\u56de\u503c \u00b6 \u91ca\u653e\u524d\u7684socket\u6587\u4ef6\u63cf\u8ff0\u7b26 xxsocket::set_nonblocking \u00b6 \u8bbe\u7f6esocket\u7684\u975e\u963b\u585e\u6a21\u5f0f\u3002 int set_nonblocking ( bool nonblocking ) const ; \u53c2\u6570 \u00b6 nonblocking true : \u975e\u963b\u585e\u6a21\u5f0f\uff0c false : \u963b\u585e\u6a21\u5f0f\u3002 \u8fd4\u56de\u503c \u00b6 0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 xxsocket::test_nonblocking \u00b6 \u68c0\u6d4bsocket\u662f\u5426\u4e3a\u975e\u963b\u585e\u6a21\u5f0f\u3002 int test_nonblocking () const ; \u8fd4\u56de\u503c \u00b6 1 : \u975e\u963b\u585e\u6a21\u5f0f\uff0c 0 : \u963b\u585e\u6a21\u5f0f\u3002 \u6ce8\u610f \u00b6 \u5bf9\u4e8ewinsock2\uff0c\u672a\u8fde\u63a5\u7684 SOCK_STREAM \u7c7b\u578bsocket\u4f1a\u8fd4\u56de -1 \u3002 xxsocket::bind \u00b6 \u7ed1\u5b9asocket\u672c\u673a\u5730\u5740\u3002 int bind ( const char * addr , unsigned short port ) const ; int bind ( const endpoint & ep ) const ; \u53c2\u6570 \u00b6 addr \u672c\u673a\u6307\u5b9a\u7f51\u5361ip\u5730\u5740\u3002 port \u8981\u7ed1\u5b9a\u7684\u7aef\u53e3\u3002 ep \u8981\u7ed1\u5b9a\u7684\u672c\u673a\u5730\u5740\u3002 \u8fd4\u56de\u503c \u00b6 0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 xxsocket::bind_any \u00b6 \u7ed1\u5b9asocket\u672c\u673a\u4efb\u610f\u5730\u5740\u3002 int bind_any ( bool ipv6 ) const ; \u53c2\u6570 \u00b6 ipv6 \u662f\u5426\u7ed1\u5b9a\u672c\u673a\u4efb\u610fIPv6\u5730\u5740 \u8fd4\u56de\u503c \u00b6 0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 xxsocket::listen \u00b6 \u5f00\u59cb\u76d1\u542c\u6765\u81eaTCP\u5ba2\u6237\u7aef\u7684\u63e1\u624b\u8bf7\u6c42\u3002 int listen ( int backlog = SOMAXCONN ) const ; \u53c2\u6570 \u00b6 backlog \u6700\u5927\u76d1\u542c\u6570\u3002 \u8fd4\u56de\u503c \u00b6 0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 xxsocket::accept \u00b6 \u63a5\u53d7\u4e00\u4e2a\u5ba2\u6237\u7aef\u8fde\u63a5\u3002 xxsocket accept () const ; \u8fd4\u56de\u503c \u00b6 \u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684 xxsocket \u5bf9\u8c61\u3002 xxsocket::accept_n \u00b6 \u975e\u963b\u585e\u65b9\u5f0f\u63a5\u53d7\u4e00\u4e2a\u5ba2\u6237\u7aef\u8fde\u63a5\u3002 int accept_n ( socket_native_type & new_sock ) const ; \u53c2\u6570 \u00b6 new_sock \u8f93\u51fa\u53c2\u6570\uff0c\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\u5e95\u5c42socket\u53e5\u67c4\u5f15\u7528 \u8fd4\u56de\u503c \u00b6 0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 \u6ce8\u610f \u00b6 \u5982\u679c\u6b64\u51fd\u6570\u8fd4\u56de 0 \uff0c new_sock \u4f1a\u88ab\u8bbe\u7f6e\u4e3a\u975e\u963b\u585e\u6a21\u5f0f\u3002 \u8c03\u7528\u6b64\u51fd\u6570\u4e4b\u524d\uff0c\u8bf7\u624b\u52a8\u8c03\u7528 xxsocket::set_nonblocking \u5c06socket\u8bbe\u7f6e\u4e3a\u975e\u963b\u585e\u6a21\u5f0f\u3002 xxsocket::connect \u00b6 \u5efa\u7acb\u8fde\u63a5\u3002 int connect ( const char * addr , u_short port ); int connect ( const endpoint & ep ); \u53c2\u6570 \u00b6 addr \u8fdc\u7a0b\u4e3b\u673aip\u5730\u5740\u3002 port \u8fdc\u7a0b\u4e3b\u673a\u7aef\u53e3\u3002 ep \u8fdc\u7a0b\u4e3b\u673a\u5730\u5740\u3002 \u8fd4\u56de\u503c \u00b6 0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 \u6ce8\u610f \u00b6 TCP: \u53d1\u8d77TCP\u4e09\u6b21\u63e1\u624b UDP: \u5efa\u7acb4\u5143\u7ec4\u7ed1\u5b9a xxsocket::connect_n \u00b6 \u5efa\u7acb\u8fde\u63a5\u3002 int connect_n ( const char * addr , u_short port , const std :: chrono :: microseconds & wtimeout ); int connect_n ( const endpoint & ep , const std :: chrono :: microseconds & wtimeout ); int connect_n ( const endpoint & ep ); \u53c2\u6570 \u00b6 addr \u8fdc\u7a0b\u4e3b\u673aip\u5730\u5740\u3002 port \u8fdc\u7a0b\u4e3b\u673a\u7aef\u53e3\u3002 ep \u8fdc\u7a0b\u4e3b\u673a\u5730\u5740\u3002 wtimeout \u5efa\u7acb\u8fde\u63a5\u7684\u8d85\u65f6\u65f6\u95f4\u3002 \u8fd4\u56de\u503c \u00b6 0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 \u6ce8\u610f \u00b6 TCP: \u53d1\u8d77TCP\u4e09\u6b21\u63e1\u624b UDP: \u5efa\u7acb4\u5143\u7ec4\u7ed1\u5b9a xxsocket::connect_n \u00b6 \u89e3\u9664socket\u548c\u8fdc\u7a0b\u4e3b\u673a\u76844\u5143\u7ec4\u7ed1\u5b9a\u3002 int disconnect () const ; \u8fd4\u56de\u503c \u00b6 0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 \u6ce8\u610f \u00b6 \u53ea\u7528\u4e8e SOCK_DGRAM (UDP) \u7c7b\u578bsocket\u3002 xxsocket::send \u00b6 \u5411\u8fdc\u7aef\u53d1\u9001\u6307\u5b9a\u957f\u5ea6\u6570\u636e\u3002 int send ( const void * buf , int len , int flags = 0 ); \u53c2\u6570 \u00b6 buf \u8981\u53d1\u9001\u6570\u636e\u7684\u8d77\u59cb\u5b57\u8282\u5730\u5740\u3002 len \u8981\u53d1\u9001\u6570\u636e\u7684\u957f\u5ea6\u3002 flags \u53d1\u9001\u6570\u636e\u5e95\u5c42\u6807\u8bb0\u3002 \u8fd4\u56de\u503c \u00b6 ==len : \u6210\u529f\uff0c < len \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 xxsocket::send_n \u00b6 \u5728\u8d85\u65f6\u65f6\u95f4\u5185\u5c3d\u529b\u5411\u8fdc\u7aef\u53d1\u9001\u6307\u5b9a\u957f\u5ea6\u6570\u636e\u3002 int send_n ( const void * buf , int len , const std :: chrono :: microseconds & wtimeout , int flags = 0 ); \u53c2\u6570 \u00b6 buf \u8981\u53d1\u9001\u6570\u636e\u7684\u8d77\u59cb\u5b57\u8282\u5730\u5740\u3002 len \u8981\u53d1\u9001\u6570\u636e\u7684\u957f\u5ea6\u3002 wtimeout \u53d1\u9001\u8d85\u65f6\u65f6\u95f4\u3002 flags \u53d1\u9001\u6570\u636e\u5e95\u5c42\u6807\u8bb0\u3002 \u8fd4\u56de\u503c \u00b6 ==len : \u6210\u529f\uff0c < len \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 xxsocket::recv \u00b6 \u4ece\u5185\u6838\u53bb\u9664\u8fdc\u7a0b\u4e3b\u673a\u53d1\u9001\u8fc7\u6765\u7684\u6570\u636e\u3002 int recv ( void * buf , int len , int flags = 0 ) const ; \u53c2\u6570 \u00b6 buf \u63a5\u6536\u6570\u636e\u7f13\u51b2\u533a\u3002 len \u63a5\u6536\u6570\u636e\u7f13\u51b2\u533a\u957f\u5ea6\u3002 flags \u63a5\u6536\u6570\u636e\u5e95\u5c42\u6807\u8bb0\u3002 \u8fd4\u56de\u503c \u00b6 ==len : \u6210\u529f\uff0c < len \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 \u6ce8\u610f \u00b6 \u6b64\u51fd\u6570\u662f\u5426\u7acb\u5373\u8fd4\u56de\uff0c\u53d6\u51b3\u4e8esocket\u672c\u8eab\u662f\u5426\u662f \u975e\u963b\u585e\u6a21\u5f0f \u3002 xxsocket::recv_n \u00b6 \u5728\u8d85\u65f6\u65f6\u95f4\u5185\u5c3d\u529b\u4ece\u5185\u6838\u53d6\u51fa\u6307\u5b9a\u957f\u5ea6\u6570\u636e\u3002 int recv_n ( void * buf , int len , const std :: chrono :: microseconds & wtimeout , int flags = 0 ) const ; \u53c2\u6570 \u00b6 buf \u63a5\u6536\u6570\u636e\u7f13\u51b2\u533a\u3002 len \u63a5\u6536\u6570\u636e\u7f13\u51b2\u533a\u957f\u5ea6\u3002 wtimeout \u63a5\u6536\u8d85\u65f6\u65f6\u95f4\u3002 flags \u63a5\u6536\u6570\u636e\u5e95\u5c42\u6807\u8bb0\u3002 \u8fd4\u56de\u503c \u00b6 ==len : \u6210\u529f\uff0c < len \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 xxsocket::sendto \u00b6 \u5411\u8fdc\u7a0b\u4e3b\u673a\u53d1\u9001 DGRAM \uff08UDP\uff09\u6570\u636e\u3002 int sendto ( const void * buf , int len , const endpoint & to , int flags = 0 ) const ; \u53c2\u6570 \u00b6 buf \u5f85\u53d1\u9001\u6570\u636e\u7f13\u51b2\u533a\u3002 len \u5f85\u53d1\u9001\u6570\u636e\u7f13\u51b2\u533a\u957f\u5ea6\u3002 to \u53d1\u9001\u76ee\u6807\u5730\u5740\u3002 flags \u53d1\u9001\u6570\u636e\u5e95\u5c42\u6807\u8bb0\u3002 \u8fd4\u56de\u503c \u00b6 ==len : \u6210\u529f\uff0c < len \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 xxsocket::recvfrom \u00b6 \u4ece\u5185\u6838\u53bb\u9664\u8fdc\u7a0b\u4e3b\u673a\u53d1\u9001\u8fc7\u6765\u7684\u6570\u636e\u3002 int recvfrom ( void * buf , int len , endpoint & peer , int flags = 0 ) const ; \u53c2\u6570 \u00b6 buf \u63a5\u6536\u6570\u636e\u7f13\u51b2\u533a\u3002 len \u63a5\u6536\u6570\u636e\u7f13\u51b2\u533a\u957f\u5ea6\u3002 peer \u63a5\u6536\u6570\u636e\u6765\u6e90\uff0c\u8f93\u51fa\u53c2\u6570\u3002 flags \u63a5\u6536\u6570\u636e\u5e95\u5c42\u6807\u8bb0\u3002 \u8fd4\u56de\u503c \u00b6 ==len : \u6210\u529f\uff0c < len \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 \u6ce8\u610f \u00b6 \u6b64\u51fd\u6570\u662f\u5426\u7acb\u5373\u8fd4\u56de\uff0c\u53d6\u51b3\u4e8esocket\u672c\u8eab\u662f\u5426\u662f \u975e\u963b\u585e\u6a21\u5f0f \u3002 xxsocket::handle_write_ready \u00b6 \u7b49\u5f85socket\u53ef\u5199\u3002 int handle_write_ready ( const std :: chrono :: microseconds & wtimeout ) const ; \u53c2\u6570 \u00b6 wtimeout \u7b49\u5f85\u8d85\u65f6\u65f6\u95f4\u3002 \u8fd4\u56de\u503c \u00b6 0 : \u8d85\u65f6\uff0c 1 : \u6210\u529f\uff0c < 0 : \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 \u6ce8\u610f \u00b6 \u901a\u5e38\u5f53\u5185\u6838\u53d1\u9001\u7f13\u51b2\u533a\u6ca1\u6ee1\u7684\u60c5\u51b5\u4e0b\uff0c\u6b64\u51fd\u6570\u4f1a\u7acb\u5373\u8fd4\u56de\u3002 xxsocket::handle_read_ready \u00b6 \u7b49\u5f85socket\u53ef\u8bfb\u3002 int handle_read_ready ( const std :: chrono :: microseconds & wtimeout ) const ; \u53c2\u6570 \u00b6 wtimeout \u7b49\u5f85\u8d85\u65f6\u65f6\u95f4\u3002 \u8fd4\u56de\u503c \u00b6 0 : \u8d85\u65f6\uff0c 1 : \u6210\u529f\uff0c < 0 : \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 xxsocket::local_endpoint \u00b6 \u83b7\u53d64\u5143\u7ec4\u901a\u4fe1\u7684\u672c\u5730\u5730\u5740\u3002 endpoint local_endpoint () const ; \u8fd4\u56de\u503c \u00b6 \u8fd4\u56de\u672c\u5730\u5730\u5740\u3002 \u6ce8\u610f \u00b6 \u5982\u679c\u6ca1\u6709\u8c03\u7528\u8fc7 xxsocket::connect \u6216\u8005TCP\u8fde\u63a53\u6b21\u63e1\u624b\u672a\u5b8c\u6210\uff0c\u90a3\u4e48\u8fd4\u56de\u7684\u5730\u5740\u662f 0.0.0.0 xxsocket::peer_endpoint \u00b6 \u83b7\u53d64\u5143\u7ec4\u901a\u4fe1\u7684\u5bf9\u7aef\u5730\u5740\u3002 endpoint peer_endpoint () const ; \u8fd4\u56de\u503c \u00b6 \u8fd4\u56de\u672c\u5730\u5730\u5740\u3002 \u6ce8\u610f \u00b6 \u5982\u679c\u6ca1\u6709\u8c03\u7528\u8fc7 xxsocket::connect \u6216\u8005TCP\u8fde\u63a53\u6b21\u63e1\u624b\u672a\u5b8c\u6210\uff0c\u90a3\u4e48\u8fd4\u56de\u7684\u5730\u5740\u662f 0.0.0.0 xxsocket::set_keepalive \u00b6 \u8bbe\u7f6eTCP\u5e95\u5c42\u534f\u8bae\u7684\u5fc3\u8df3\u53c2\u6570\u3002 int set_keepalive ( int flag = 1 , int idle = 7200 , int interval = 75 , int probes = 10 ); \u53c2\u6570 \u00b6 flag 1 : \u5f00\u542f\u5e95\u5c42\u534f\u8bae\u5fc3\u8df3\uff0c 0 : \u5173\u95ed\u3002 idle \u5f53\u5e94\u7528\u5c42\u6ca1\u6709\u4efb\u4f55\u6d88\u606f\u4ea4\u4e92\u540e\uff0c\u542f\u52a8\u5e95\u5c42\u534f\u8bae\u5fc3\u8df3\u63a2\u6d4b\u7684\u6700\u5927\u8d85\u65f6\u65f6\u95f4\uff0c\u5355\u4f4d\uff08\u79d2\uff09\u3002 interval \u5f53\u6ca1\u6709\u6536\u5230\u5fc3\u8df3\u56de\u5e94\u65f6\uff0c\u91cd\u590d\u53d1\u9001\u5fc3\u8df3\u63a2\u6d4b\u62a5\u65f6\u95f4\u95f4\u9694\uff0c\u5355\u4f4d\uff08\u79d2\uff09\u3002 probes \u5f53\u6ca1\u6709\u6536\u5230\u5fc3\u8df3\u56de\u5e94\u65f6\uff0c\u6700\u5927\u63a2\u6d4b\u6b21\u6570\uff0c\u8d85\u8fc7\u63a2\u6d4b\u6b21\u6570\u540e\uff0c\u4f1a\u89e6\u53d1\u5e94\u7528\u5c42\u8fde\u63a5\u65ad\u5f00\u3002 \u8fd4\u56de\u503c \u00b6 0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 \u793a\u4f8b \u00b6 // xxsocket-keepalive.cpp #include \"yasio/xxsocket.hpp\" using namespace yasio ; using namespace inet ; int main (){ xxsocket client ; if ( 0 == client . pconnect ( \"192.168.1.19\" , 80 )) { client . set_keepalive ( 1 , 5 , 10 , 2 ); } return 0 ; } xxsocket::reuse_address \u00b6 \u8bbe\u7f6esocket\u662f\u5426\u5141\u8bb8\u91cd\u7528\u5730\u5740\u3002 void reuse_address ( bool reuse ); \u53c2\u6570 \u00b6 reuse \u662f\u5426\u91cd\u7528\u3002 \u6ce8\u610f \u00b6 \u6b64\u51fd\u6570\u4e00\u822c\u7528\u4e8e\u670d\u52a1\u5668\u6216\u8005\u7ec4\u64ad\u76d1\u542c\u7aef\u53e3\u3002 xxsocket::exclusive_address \u00b6 \u662f\u5426\u660e\u786e\u4e0d\u5141\u8bb8\u5730\u5740\u91cd\u7528\uff0c\u4ee5\u4fdd\u62a4\u901a\u4fe1\u53cc\u65b9\u5b89\u5168\u3002 void exclusive_address ( bool exclusive ); \u53c2\u6570 \u00b6 exclusive true : \u4e0d\u5141\u8bb8\uff0c false : \u5141\u8bb8 \u6ce8\u610f \u00b6 \u70b9\u51fb \u67e5\u770b winsock \u5b89\u5168\u62a5\u544a\u3002 xxsocket::set_optval \u00b6 \u8bbe\u7f6esocket\u9009\u9879\u3002 template < typename _Ty > int set_optval ( int level , int optname , const _Ty & optval ); \u53c2\u6570 \u00b6 level socket\u9009\u9879\u7ea7\u522b\u3002 optname \u9009\u9879\u7c7b\u578b\u3002 optval \u9009\u9879\u503c\u3002 \u8fd4\u56de\u503c \u00b6 0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 \u6ce8\u610f \u00b6 \u6b64\u51fd\u6570\u540cbsd socket setsockopt \u529f\u80fd\u76f8\u540c\uff0c\u53ea\u662f\u4f7f\u7528\u6a21\u677f\u5c01\u88c5\uff0c\u66f4\u65b9\u4fbf\u4f7f\u7528\u3002 xxsocket::get_optval \u00b6 \u8bbe\u7f6esocket\u9009\u9879\u3002 template < typename _Ty > _Ty get_optval ( int level , int optname ) const \u53c2\u6570 \u00b6 level socket\u9009\u9879\u7ea7\u522b\u3002 optname \u9009\u9879\u7c7b\u578b\u3002 \u8fd4\u56de\u503c \u00b6 \u8fd4\u56de\u9009\u9879\u503c\u3002 \u6ce8\u610f \u00b6 \u6b64\u51fd\u6570\u540cbsd socket getsockopt \u529f\u80fd\u76f8\u540c\uff0c\u53ea\u662f\u4f7f\u7528\u6a21\u677f\u5c01\u88c5\uff0c\u66f4\u65b9\u4fbf\u4f7f\u7528\u3002 xxsocket::select \u00b6 \u76d1\u542csocket\u5185\u6838\u4e8b\u4ef6\u3002 int select ( fd_set * readfds , fd_set * writefds , fd_set * exceptfds , const std :: chrono :: microseconds & wtimeout ) \u53c2\u6570 \u00b6 readfds \u53ef\u8bfb\u4e8b\u4ef6\u63cf\u8ff0\u7b26\u6570\u7ec4\u3002 writefds \u53ef\u5199\u4e8b\u4ef6\u63cf\u8ff0\u7b26\u6570\u7ec4\u3002 exceptfds \u5f02\u5e38\u4e8b\u4ef6\u63cf\u8ff0\u7b26\u6570\u7ec4\u3002 wtimeout \u7b49\u5f85\u4e8b\u4ef6\u8d85\u65f6\u4e8b\u4ef6\u3002 \u8fd4\u56de\u503c \u00b6 0 : \u8d85\u65f6\uff0c > 0 : \u6210\u529f\uff0c < 0 : \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 xxsocket::shutdown \u00b6 \u5173\u95edTCP\u4f20\u8f93\u901a\u9053\u3002 int shutdown ( int how = SD_BOTH ) const ; \u53c2\u6570 \u00b6 how \u5173\u95ed\u901a\u9053\u7c7b\u578b\uff0c\u53ef\u4f20\u4ee5\u4e0b\u679a\u4e3e\u503c SD_SEND : \u53d1\u9001\u901a\u9053 SD_RECEIVE : \u63a5\u53d7\u901a\u9053 SD_BOTH : \u5168\u90e8\u5173\u95ed \u8fd4\u56de\u503c \u00b6 0 : \u6210\u529f\uff0c < 0 : \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 xxsocket::close \u00b6 \u5173\u95edsocket\uff0c\u91ca\u653e\u7cfb\u7edf\u8d44\u6e90\u3002 void close ( int shut_how = SD_BOTH ); \u53c2\u6570 \u00b6 shut_how \u5173\u95ed\u901a\u9053\u7c7b\u578b\uff0c\u53ef\u4ee5\u4f20\u4ee5\u4e0b\u679a\u4e3e\u503c SD_SEND : \u53d1\u9001\u901a\u9053 SD_RECEIVE : \u63a5\u53d7\u901a\u9053 SD_BOTH : \u5168\u90e8\u5173\u95ed SD_NONE : \u5168\u90e8\u5173\u95ed \u8fd4\u56de\u503c \u00b6 0 : \u6210\u529f\uff0c < 0 : \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002 \u6ce8\u610f \u00b6 \u5982\u679c shut_how != SD_NONE \uff0c\u6b64\u51fd\u6570\u4f1a\u5148\u8c03\u7528 shutdown \uff0c\u518d\u8c03\u7528\u5e95\u5c42 close \u3002 xxsocket::tcp_rtt \u00b6 \u83b7\u53d6TCP\u8fde\u63a5\u7684RTT\u3002 uint32_t tcp_rtt () const ; \u8fd4\u56de\u503c \u00b6 \u8fd4\u56deTCP\u7684RTT\u65f6\u95f4\uff0c\u5355\u4f4d: \u5fae\u79d2 \u3002 xxsocket::get_last_errno \u00b6 \u83b7\u53d6\u6700\u8fd1\u4e00\u6b21socket\u64cd\u4f5c\u9519\u8bef\u7801\u3002 static int get_last_errno (); \u8fd4\u56de\u503c \u00b6 0 : \u65e0\u9519\u8bef\uff0c > 0 \u901a\u8fc7 xxsocket::strerror \u8f6c\u6362\u4e3a\u8be6\u7ec6\u9519\u8bef\u4fe1\u606f\u3002 \u6ce8\u610f \u00b6 \u6b64\u51fd\u6570\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\u3002 xxsocket::set_last_errno \u00b6 \u8bbe\u7f6esocket\u64cd\u4f5c\u9519\u8bef\u7801\u3002 static void set_last_errno ( int error ); \u53c2\u6570 \u00b6 error \u9519\u8bef\u7801\u3002 \u6ce8\u610f \u00b6 \u6b64\u51fd\u6570\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\u3002 xxsocket::not_send_error \u00b6 \u5224\u65ad\u662f\u5426\u662f\u53d1\u9001\u65f6socket\u51fa\u73b0\u65e0\u6cd5\u7ee7\u7eed\u7684\u9519\u8bef\u3002 static bool not_send_error ( int error ); \u53c2\u6570 \u00b6 error \u9519\u8bef\u7801\u3002 \u8fd4\u56de\u503c \u00b6 true : socket\u6b63\u5e38\uff0c false : socket\u72b6\u6001\u5df2\u7ecf\u53d1\u751f\u9519\u8bef\uff0c\u5e94\u5f53\u5173\u95edsocket\u7ec8\u6b62\u901a\u8baf\u3002 \u6ce8\u610f \u00b6 \u4ec5\u5f53\u53d1\u9001\u64cd\u4f5c\u8fd4\u56de\u503c < 0 \u65f6\uff0c\u8c03\u7528\u6b64\u51fd\u6570\u3002 xxsocket::not_recv_error \u00b6 \u5224\u65ad\u662f\u5426\u662f\u63a5\u6536\u65f6socket\u51fa\u73b0\u65e0\u6cd5\u7ee7\u7eed\u7684\u9519\u8bef\u3002 static bool not_recv_error ( int error ); \u53c2\u6570 \u00b6 error \u9519\u8bef\u7801\u3002 \u8fd4\u56de\u503c \u00b6 true : socket\u6b63\u5e38\uff0c false : socket\u72b6\u6001\u5df2\u7ecf\u53d1\u751f\u9519\u8bef\uff0c\u5e94\u5f53\u5173\u95edsocket\u7ec8\u6b62\u901a\u8baf\u3002 \u6ce8\u610f \u00b6 \u4ec5\u5f53\u63a5\u6536\u64cd\u4f5c\u8fd4\u56de\u503c < 0 \u65f6\uff0c\u8c03\u7528\u6b64\u51fd\u6570\u3002 xxsocket::strerror \u00b6 \u5c06\u9519\u8bef\u7801\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u3002 static const char * strerror ( int error ); \u53c2\u6570 \u00b6 error \u9519\u8bef\u7801\u3002 \u8fd4\u56de\u503c \u00b6 \u9519\u8bef\u4fe1\u606f\u7684\u5b57\u7b26\u4e32\u3002 xxsocket::gai_strerror \u00b6 \u5c06 getaddrinfo \u9519\u8bef\u7801\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u3002 static const char * gai_strerror ( int error ); \u53c2\u6570 \u00b6 error \u9519\u8bef\u7801\u3002 \u8fd4\u56de\u503c \u00b6 \u9519\u8bef\u4fe1\u606f\u7684\u5b57\u7b26\u4e32\u3002 xxsocket::resolve \u00b6 \u89e3\u6790\u57df\u540d\u5305\u542b\u7684\u6240\u6709\u5730\u5740\u3002 int resolve ( std :: vector < endpoint >& endpoints , const char * hostname , unsigned short port = 0 , int socktype = SOCK_STREAM ); \u53c2\u6570 \u00b6 endpoints \u8f93\u51fa\u53c2\u6570\u3002 hostname \u57df\u540d\u3002 port \u7aef\u53e3\u3002 socktype socket\u7c7b\u578b\u3002 \u8fd4\u56de\u503c \u00b6 0 : \u65e0\u9519\u8bef\uff0c > 0 \u901a\u8fc7 xxsocket::strerror \u8f6c\u6362\u4e3a\u8be6\u7ec6\u9519\u8bef\u4fe1\u606f\u3002 xxsocket::resolve_v4 \u00b6 \u89e3\u6790\u57df\u540d\u5305\u542b\u7684IPv4\u5730\u5740\u3002 int resolve_v4 ( std :: vector < endpoint >& endpoints , const char * hostname , unsigned short port = 0 , int socktype = SOCK_STREAM ); \u53c2\u6570 \u00b6 endpoints \u8f93\u51fa\u53c2\u6570\u3002 hostname \u57df\u540d\u3002 port \u7aef\u53e3\u3002 socktype socket\u7c7b\u578b\u3002 \u8fd4\u56de\u503c \u00b6 0 : \u65e0\u9519\u8bef\uff0c > 0 \u901a\u8fc7 xxsocket::strerror \u8f6c\u6362\u4e3a\u8be6\u7ec6\u9519\u8bef\u4fe1\u606f\u3002 xxsocket::resolve_v6 \u00b6 \u89e3\u6790\u57df\u540d\u5305\u542b\u7684IPv6\u5730\u5740\u3002 int resolve_v6 ( std :: vector < endpoint >& endpoints , const char * hostname , unsigned short port = 0 , int socktype = SOCK_STREAM ); \u53c2\u6570 \u00b6 endpoints \u8f93\u51fa\u53c2\u6570\u3002 hostname \u57df\u540d\u3002 port \u7aef\u53e3\u3002 socktype socket\u7c7b\u578b\u3002 \u8fd4\u56de\u503c \u00b6 0 : \u65e0\u9519\u8bef\uff0c > 0 \u901a\u8fc7 xxsocket::strerror \u8f6c\u6362\u4e3a\u8be6\u7ec6\u9519\u8bef\u4fe1\u606f\u3002 xxsocket::resolve_v4to6 \u00b6 \u4ec5\u89e3\u6790\u57df\u540d\u5305\u542b\u7684IPv4\u5730\u5740\u5e76\u8f6c\u6362\u4e3aIPv6 V4MAPPED\u683c\u5f0f\u3002 int resolve_v4to6 ( std :: vector < endpoint >& endpoints , const char * hostname , unsigned short port = 0 , int socktype = SOCK_STREAM ); \u53c2\u6570 \u00b6 endpoints \u8f93\u51fa\u53c2\u6570\u3002 hostname \u57df\u540d\u3002 port \u7aef\u53e3\u3002 socktype socket\u7c7b\u578b\u3002 \u8fd4\u56de\u503c \u00b6 0 : \u65e0\u9519\u8bef\uff0c > 0 \u901a\u8fc7 xxsocket::strerror \u8f6c\u6362\u4e3a\u8be6\u7ec6\u9519\u8bef\u4fe1\u606f\u3002 xxsocket::resolve_tov6 \u00b6 \u89e3\u6790\u57df\u540d\u5305\u542b\u7684\u6240\u6709\u5730\u5740\uff0cIPv4\u5730\u5740\u4f1a\u8f6c\u6362\u4e3aIPv6 V4MAPPED\u683c\u5f0f\u3002 int resolve_tov6 ( std :: vector < endpoint >& endpoints , const char * hostname , unsigned short port = 0 , int socktype = SOCK_STREAM ); \u53c2\u6570 \u00b6 endpoints \u8f93\u51fa\u53c2\u6570\u3002 hostname \u57df\u540d\u3002 port \u7aef\u53e3\u3002 socktype socket\u7c7b\u578b\u3002 \u8fd4\u56de\u503c \u00b6 0 : \u65e0\u9519\u8bef\uff0c > 0 \u901a\u8fc7 xxsocket::strerror \u8f6c\u6362\u4e3a\u8be6\u7ec6\u9519\u8bef\u4fe1\u606f\u3002 xxsocket::getipsv \u00b6 \u83b7\u53d6\u672c\u673a\u652f\u6301\u7684IP\u534f\u8bae\u6808\u6807\u5fd7\u4f4d\u3002 static int getipsv (); \u8fd4\u56de\u503c \u00b6 ipsv_ipv4 : \u672c\u673a\u53ea\u652f\u6301IPv4\u534f\u8bae\u3002 ipsv_ipv6 : \u672c\u673a\u53ea\u652f\u6301IPv6\u534f\u8bae\u3002 ipsv_dual_stack : \u672c\u673a\u652f\u6301IPv4\u548cIPv6\u53cc\u6808\u534f\u8bae\u3002 \u6ce8\u610f \u00b6 \u5f53\u8fd4\u56de\u503c\u652f\u6301\u53cc\u6808\u534f\u8bae\u662f\uff0c\u7528\u6237\u5e94\u5f53\u59cb\u7ec8\u4f18\u5148\u4f7f\u7528IPv4\u901a\u4fe1\uff0c \u4f8b\u5982 \u667a\u80fd\u624b\u673a\u8bbe\u5907 \u5728\u540c\u65f6\u5f00\u542f wifi \u548c \u8702\u7a9d\u7f51\u7edc \u65f6\uff0c\u5c06\u4f1a\u4f18\u5148\u9009\u62e9wifi\uff0c \u800cwifi\u901a\u5e38\u662fIPv4\uff0c\u8be6\u89c1: https://github.com/halx99/yasio/issues/130 \u793a\u4f8b \u00b6 // xxsocket-ipsv.cpp #include <vector> #include \"yasio/xxsocket.hpp\" using namespace yasio ; using namespace yasio :: inet ; int main (){ const char * host = \"github.com\" ; std :: vector < ip :: endpoint > eps ; int flags = xxsocket :: get_ipsv (); if ( flags & ipsv_ipv4 ) { xxsocket :: resolve_v4 ( eps , host , 80 ); } else if ( flags & ipsv_ipv6 ) { xxsocket :: resolve_tov6 ( eps , host , 80 ); } else { std :: cerr << \"Local network not available! \\n \" ; } return 0 ; } xxsocket::traverse_local_address \u00b6 \u679a\u4e3e\u672c\u673a\u5730\u5740\u3002 static void traverse_local_address ( std :: function < bool ( const ip :: endpoint & ) > handler ); \u53c2\u6570 \u00b6 handler \u679a\u4e3e\u5730\u5740\u56de\u8c03\u3002 \u793a\u4f8b \u00b6 // xxsocket-traverse.cpp #include <vector> #include \"yasio/xxsocket.hpp\" using namespace yasio ; using namespace yasio :: inet ; int main (){ int flags = 0 ; xxsocket :: traverse_local_address ([ & ]( const ip :: endpoint & ep ) -> bool { switch ( ep . af ()) { case AF_INET : flags |= ipsv_ipv4 ; break ; case AF_INET6 : flags |= ipsv_ipv6 ; break ; } return ( flags == ipsv_dual_stack ); }); YASIO_LOG ( \"Supported ip stack flags=%d\" , flags ); return flags ; } \u8bf7\u53c2\u9605 \u00b6 io_service Class","title":"xxsocket\u7c7b"},{"location":"api/reference/xxsocket-class/#xxsocket-class","text":"\u5c01\u88c5\u5e95\u5c42bsd socket\u5e38\u7528API\uff0c\u5c4f\u853d\u5404\u64cd\u4f5c\u7cfb\u7edf\u5e73\u53f0\u5dee\u5f02\uff0cyasio\u7684\u8d77\u6e90\u3002 \u7279\u522b\u6ce8\u610f xxsocket\u9664\u4e86 accept_n \u4ee5\u5916\u7684\u6240\u6709 xxx_n \u63a5\u53e3\u5747\u4f1a\u5c06\u5f53\u524dsocket\u5bf9\u8c61\u5e95\u5c42\u63cf\u8ff0\u7b26\u8bbe\u7f6e\u4e3a\u975e\u963b\u585e\u6a21\u5f0f\uff0c\u4e14\u4e0d\u4f1a\u6062\u590d\u3002","title":"xxsocket Class"},{"location":"api/reference/xxsocket-class/#_1","text":"namespace yasio { namespace inet { class xxsocket ; } }","title":"\u8bed\u6cd5"},{"location":"api/reference/xxsocket-class/#_2","text":"Name Description xxsocket::xxsocket \u6784\u9020\u4e00\u4e2a xxsocket \u5bf9\u8c61","title":"\u6210\u5458"},{"location":"api/reference/xxsocket-class/#_3","text":"Name Description xxsocket::xpconnect \u5efa\u7acbTCP\u8fde\u63a5 xxsocket::xpconnect_n \u975e\u963b\u585e\u65b9\u5f0f\u5efa\u7acbTCP\u8fde\u63a5 xxsocket::pconnect \u5efa\u7acbTCP\u8fde\u63a5 xxsocket::pconnect_n \u975e\u963b\u585e\u65b9\u5f0f\u5efa\u7acbTCP\u8fde\u63a5 xxsocket::pserve \u521b\u5efatcp\u670d\u52a1\u7aef xxsocket::swap \u4ea4\u6362socket\u63cf\u8ff0\u7b26\u53e5\u67c4 xxsocket::open \u6253\u5f00socket xxsocket::reopen \u91cd\u65b0\u6253\u5f00socket xxsocket::is_open \u68c0\u67e5socket\u662f\u5426\u6253\u5f00 xxsocket::native_handle \u83b7\u53d6socket\u53e5\u67c4 xxsocket::release_handle \u91ca\u653esocket\u53e5\u67c4\u63a7\u5236\u6743 xxsocket::set_nonblocking \u5c06socket\u8bbe\u7f6e\u4e3a\u975e\u963b\u585e\u6a21\u5f0f xxsocket::test_nonblocking \u68c0\u6d4bsocket\u662f\u5426\u4e3a\u975e\u963b\u585e\u6a21\u5f0f xxsocket::bind \u7ed1\u5b9a\u6307\u5b9a\u672c\u5730\u6307\u5b9a\u7f51\u5361\u5730\u5740 xxsocket::bind_any \u7ed1\u5b9a\u672c\u5730\u4efb\u610f\u5730\u5740 xxsocket::listen \u5f00\u59cbTCP\u76d1\u542c xxsocket::accept \u63a5\u53d7\u4e00\u4e2aTCP\u5ba2\u6237\u7aef\u8fde\u63a5 xxsocket::accept_n \u975e\u963b\u585e\u65b9\u5f0f\u63a5\u53d7TCP\u8fde\u63a5 xxsocket::connect \u5efa\u7acb\u8fde\u63a5 xxsocket::connect_n \u975e\u963b\u585e\u65b9\u5f0f\u5efa\u7acb\u8fde\u63a5 xxsocket::send \u53d1\u9001\u6570\u636e xxsocket::send_n \u975e\u963b\u585e\u65b9\u5f0f\u53d1\u9001\u6570\u636e xxsocket::recv \u63a5\u53d7\u6570\u636e xxsocket::recv_n \u975e\u963b\u585e\u65b9\u5f0f\u63a5\u53d7\u6570\u636e xxsocket::sendto \u53d1\u9001DGRAM\u6570\u636e\u5230\u6307\u5b9a\u5730\u5740 xxsocket::recvfrom \u63a5\u53d7DGRAM\u6570\u636e xxsocket::handle_write_ready \u7b49\u5f85socket\u53ef\u5199 xxsocket::handle_read_ready \u7b49\u5f85socket\u53ef\u8bfb xxsocket::local_endpoint \u83b7\u53d6socket\u672c\u5730\u5730\u5740 xxsocket::peer_endpoint \u83b7\u53d6socket\u8fdc\u7aef\u5730\u5740 xxsocket::set_keepalive \u8bbe\u7f6etcp keepalive xxsocket::reuse_address \u8bbe\u7f6esocket\u662f\u5426\u91cd\u7528\u5730\u5740 xxsocket::exclusive_address \u8bbe\u7f6esocket\u662f\u5426\u963b\u6b62\u5730\u5740\u91cd\u7528 xxsocket::select \u76d1\u542csocket\u4e8b\u4ef6 xxsocket::shutdown \u505c\u6b62socket\u6536\u53d1 xxsocket::close \u5173\u95edsocket xxsocket::tcp_rtt \u83b7\u53d6tcp rtt. xxsocket::get_last_errno \u83b7\u53d6\u6700\u8fd1socket\u9519\u8bef\u7801 xxsocket::set_last_errno \u8bbe\u7f6e\u6700\u8fd1socket\u9519\u8bef\u7801 xxsocket::strerror \u5c06socket\u9519\u8bef\u7801\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32 xxsocket::gai_strerror \u5c06getaddrinfo\u8fd4\u56de\u503c\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32 xxsocket::resolve \u89e3\u6790\u57df\u540d xxsocket::resolve_v4 \u89e3\u6790\u57df\u540d\u5305\u542b\u7684ipv4\u5730\u5740 xxsocket::resolve_v6 \u89e3\u6790\u57df\u540d\u5305\u542b\u7684ipv6\u5730\u5740 xxsocket::resolve_v4to6 \u89e3\u6790\u57df\u540d\u5305\u542b\u7684ipv4\u5730\u5740\u5e76\u8f6c\u6362\u4e3aipv6\u7684V4MAPPED\u683c\u5f0f xxsocket::resolve_tov6 \u89e3\u6790\u57df\u540d\u5305\u542b\u7684\u6240\u6709\u5730\u5740\uff0cipv4\u5730\u5740\u4f1a\u8f6c\u6362\u4e3aipv6\u7684V4MAPPED\u683c\u5f0f xxsocket::getipsv \u83b7\u53d6\u672c\u673a\u652f\u6301\u7684ip\u534f\u8bae\u6808\u7248\u672c\u6807\u5fd7\u4f4d xxsocket::traverse_local_address \u679a\u4e3e\u672c\u673a\u5730\u5740","title":"\u516c\u5171\u65b9\u6cd5"},{"location":"api/reference/xxsocket-class/#xxsocketxxsocket","text":"\u6784\u9020 xxsocket \u5bf9\u8c61\u3002 xxsocket :: xxsocket (); xxsocket :: xxsocket ( socket_native_type handle ); xxsocket :: xxsocket ( xxsocket && right ); xxsocket :: xxsocket ( int af , int type , int protocol );","title":" xxsocket::xxsocket"},{"location":"api/reference/xxsocket-class/#_4","text":"handle \u901a\u8fc7\u5df2\u6709socket\u53e5\u67c4\u6784\u9020 xxsocket \u5bf9\u8c61\u3002 right move\u6784\u9020\u51fd\u6570\u53f3\u503c\u5f15\u7528\u3002 af ip\u534f\u8bae\u5730\u5740\u7c7b\u578b\u3002 protocol \u534f\u8bae\u7c7b\u578b\uff0c\u5bf9\u4e8eTCP/UDP\u76f4\u63a5\u4f20 0 \u5c31\u53ef\u4ee5\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#xxsocketxpconnect","text":"\u548c\u8fdc\u7a0b\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5\u3002 int xxsocket::xpconnect ( const char * hostname , u_short port , u_short local_port = 0 );","title":" xxsocket::xpconnect"},{"location":"api/reference/xxsocket-class/#_5","text":"hostname \u8981\u8fde\u63a5\u670d\u52a1\u5668\u4e3b\u673a\u540d\uff0c\u53ef\u4ee5\u662f IP\u5730\u5740 \u6216 \u57df\u540d \u3002 port \u8981\u8fde\u63a5\u670d\u52a1\u5668\u7684\u7aef\u53e3\u3002 local_port \u672c\u5730\u901a\u4fe1\u7aef\u53e3\u53f7\uff0c\u9ed8\u8ba4\u503c 0 \u8868\u793a\u968f\u673a\u5206\u914d\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_6","text":"\u4f1a\u81ea\u52a8\u68c0\u6d4b\u672c\u673a\u652f\u6301\u7684ip\u534f\u8bae\u6808\u7248\u672c\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#_7","text":"0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketxpconnect_n","text":"\u548c\u8fdc\u7a0b\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5\u3002 int xxsocket::xpconnect_n ( const char * hostname , u_short port , const std :: chrono :: microseconds & wtimeout , u_short local_port = 0 );","title":" xxsocket::xpconnect_n"},{"location":"api/reference/xxsocket-class/#_8","text":"hostname \u8981\u8fde\u63a5\u670d\u52a1\u5668\u4e3b\u673a\u540d\uff0c\u53ef\u4ee5\u662f IP\u5730\u5740 \u6216 \u57df\u540d \u3002 port \u8981\u8fde\u63a5\u670d\u52a1\u5668\u7684\u7aef\u53e3\u3002 local_port \u672c\u5730\u901a\u4fe1\u7aef\u53e3\u53f7\uff0c\u9ed8\u8ba4\u503c 0 \u8868\u793a\u968f\u673a\u5206\u914d\u3002 wtimeout \u5efa\u7acb\u8fde\u63a5\u8d85\u65f6\u65f6\u95f4\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_9","text":"0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_10","text":"\u4f1a\u81ea\u52a8\u68c0\u6d4b\u672c\u673a\u652f\u6301\u7684ip\u534f\u8bae\u6808\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsocketpconnect","text":"\u548c\u8fdc\u7a0b\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5\u3002 int xxsocket::pconnect ( const char * hostname , u_short port , u_short local_port = 0 ); int xxsocket::pconnect ( const endpoint & ep , u_short local_port = 0 );","title":" xxsocket::pconnect"},{"location":"api/reference/xxsocket-class/#_11","text":"hostname \u8981\u8fde\u63a5\u670d\u52a1\u5668\u4e3b\u673a\u540d\uff0c\u53ef\u4ee5\u662f IP\u5730\u5740 \u6216 \u57df\u540d \u3002 ep \u8981\u8fde\u63a5\u670d\u52a1\u5668\u7684\u5730\u5740\u3002 port \u8981\u8fde\u63a5\u670d\u52a1\u5668\u7684\u7aef\u53e3\u3002 local_port \u672c\u5730\u901a\u4fe1\u7aef\u53e3\u53f7\uff0c\u9ed8\u8ba4\u503c 0 \u8868\u793a\u968f\u673a\u5206\u914d\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_12","text":"0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_13","text":"\u4e0d\u4f1a\u68c0\u6d4b\u672c\u673a\u652f\u6301\u7684ip\u534f\u8bae\u6808\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsocketpconnect_n","text":"\u548c\u8fdc\u7a0b\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5\u3002 int pconnect_n ( const char * hostname , u_short port , const std :: chrono :: microseconds & wtimeout , u_short local_port = 0 ); int pconnect_n ( const char * hostname , u_short port , u_short local_port = 0 ); int pconnect_n ( const endpoint & ep , const std :: chrono :: microseconds & wtimeout , u_short local_port = 0 ); int pconnect_n ( const endpoint & ep , u_short local_port = 0 );","title":" xxsocket::pconnect_n"},{"location":"api/reference/xxsocket-class/#_14","text":"hostname \u8981\u8fde\u63a5\u670d\u52a1\u5668\u4e3b\u673a\u540d\uff0c\u53ef\u4ee5\u662f IP\u5730\u5740 \u6216 \u57df\u540d \u3002 ep \u8981\u8fde\u63a5\u670d\u52a1\u5668\u7684\u5730\u5740\u3002 port \u8981\u8fde\u63a5\u670d\u52a1\u5668\u7684\u7aef\u53e3\u3002 local_port \u672c\u5730\u901a\u4fe1\u7aef\u53e3\u53f7\uff0c\u9ed8\u8ba4\u503c 0 \u8868\u793a\u968f\u673a\u5206\u914d\u3002 wtimeout \u5efa\u7acb\u8fde\u63a5\u8d85\u65f6\u65f6\u95f4\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_15","text":"0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketpserve","text":"\u5f00\u542f\u672c\u5730TCP\u670d\u52a1\u76d1\u542c\u3002 int pserve ( const char * addr , u_short port ); int pserve ( const endpoint & ep );","title":" xxsocket::pserve"},{"location":"api/reference/xxsocket-class/#_16","text":"addr \u672c\u673a\u6307\u5b9a\u7f51\u5361 IP\u5730\u5740 \u3002 ep \u672c\u673a\u5730\u5740\u3002 port TCP\u76d1\u542c\u7aef\u53e3\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_17","text":"0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_18","text":"// xxsocket-serve.cpp #include <signal.h> #include <vector> #include \"yasio/xxsocket.hpp\" using namespace yasio ; using namespace yasio :: inet ; xxsocket g_server ; static bool g_stopped = false ; void process_exit ( int sig ) { if ( sig == SIGINT ) { g_stopped = true ; g_server . close (); } printf ( \"exit\" ); } int main () { signal ( SIGINT , process_exit ); if ( g_server . pserve ( \"0.0.0.0\" , 1219 ) != 0 ) return -1 ; const char reply_msg [] = \"hi, I'm server \\n \" ; do { xxsocket cs = g_server . accept (); if ( cs . is_open ()) { cs . send ( reply_msg , sizeof ( reply_msg ) - 1 ); std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 100 )); } } while ( ! g_stopped ); return 0 ; }","title":"\u793a\u4f8b"},{"location":"api/reference/xxsocket-class/#xxsocketswap","text":"\u4ea4\u6362\u5e95\u5c42socket\u53e5\u67c4\u3002 xxsocket & swap ( xxsocket & who );","title":" xxsocket::swap"},{"location":"api/reference/xxsocket-class/#_19","text":"who \u4ea4\u6362\u5bf9\u8c61\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_20","text":"xxsocket \u5de6\u503c\u5bf9\u8c61\u7684\u5f15\u7528\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketopen","text":"\u6253\u5f00\u4e00\u4e2asocket\u3002 bool open ( int af = AF_INET , int type = SOCK_STREAM , int protocol = 0 );","title":" xxsocket::open"},{"location":"api/reference/xxsocket-class/#_21","text":"af \u5730\u5740\u7c7b\u578b\uff0c\u4f8b\u5982 AF_INET (ipv4)\uff0c AF_INET6 (ipv6)\u3002 type socket\u7c7b\u578b\uff0c SOCK_STREAM (TCP), SOCK_DGRAM (UDP)\u3002 protocol \u534f\u8bae\uff0c\u5bf9\u4e8eTCP/UDP\uff0c\u4f20 0 \u5373\u53ef\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_22","text":"true : \u6210\u529f\uff0c false \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketreopen","text":"\u6253\u5f00\u4e00\u4e2asocket\u3002 bool reopen ( int af = AF_INET , int type = SOCK_STREAM , int protocol = 0 );","title":" xxsocket::reopen"},{"location":"api/reference/xxsocket-class/#_23","text":"af \u5730\u5740\u7c7b\u578b\uff0c\u4f8b\u5982 AF_INET (ipv4)\uff0c AF_INET6 (ipv6)\u3002 type socket\u7c7b\u578b\uff0c SOCK_STREAM (TCP), SOCK_DGRAM (UDP)\u3002 protocol \u534f\u8bae\uff0c\u5bf9\u4e8eTCP/UDP\uff0c\u4f20 0 \u5373\u53ef\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_24","text":"true : \u6210\u529f\uff0c false \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_25","text":"\u5982\u679csocket\u5df2\u6253\u5f00\uff0c\u6b64\u51fd\u6570\u4f1a\u5148\u5173\u95ed\uff0c\u518d\u91cd\u65b0\u6253\u5f00\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsocketis_open","text":"\u5224\u65adsocket\u662f\u5426\u5df2\u6253\u5f00\u3002 bool is_open () const ;","title":" xxsocket::is_open"},{"location":"api/reference/xxsocket-class/#_26","text":"true : \u5df2\u6253\u5f00\uff0c false : \u672a\u6253\u5f00\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketnative_handle","text":"\u83b7\u53d6socket\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 socket_native_type native_handle () const ;","title":" xxsocket::native_handle"},{"location":"api/reference/xxsocket-class/#_27","text":"socket\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c yasio::inet::invalid_socket \u8868\u793a\u65e0\u6548socket\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketrelease_handle","text":"\u91ca\u653e\u5e95\u5c42socket\u63cf\u8ff0\u7b26\u63a7\u5236\u6743\u3002 socket_native_type release_handle () const ;","title":" xxsocket::release_handle"},{"location":"api/reference/xxsocket-class/#_28","text":"\u91ca\u653e\u524d\u7684socket\u6587\u4ef6\u63cf\u8ff0\u7b26","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketset_nonblocking","text":"\u8bbe\u7f6esocket\u7684\u975e\u963b\u585e\u6a21\u5f0f\u3002 int set_nonblocking ( bool nonblocking ) const ;","title":" xxsocket::set_nonblocking"},{"location":"api/reference/xxsocket-class/#_29","text":"nonblocking true : \u975e\u963b\u585e\u6a21\u5f0f\uff0c false : \u963b\u585e\u6a21\u5f0f\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_30","text":"0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsockettest_nonblocking","text":"\u68c0\u6d4bsocket\u662f\u5426\u4e3a\u975e\u963b\u585e\u6a21\u5f0f\u3002 int test_nonblocking () const ;","title":" xxsocket::test_nonblocking"},{"location":"api/reference/xxsocket-class/#_31","text":"1 : \u975e\u963b\u585e\u6a21\u5f0f\uff0c 0 : \u963b\u585e\u6a21\u5f0f\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_32","text":"\u5bf9\u4e8ewinsock2\uff0c\u672a\u8fde\u63a5\u7684 SOCK_STREAM \u7c7b\u578bsocket\u4f1a\u8fd4\u56de -1 \u3002","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsocketbind","text":"\u7ed1\u5b9asocket\u672c\u673a\u5730\u5740\u3002 int bind ( const char * addr , unsigned short port ) const ; int bind ( const endpoint & ep ) const ;","title":" xxsocket::bind"},{"location":"api/reference/xxsocket-class/#_33","text":"addr \u672c\u673a\u6307\u5b9a\u7f51\u5361ip\u5730\u5740\u3002 port \u8981\u7ed1\u5b9a\u7684\u7aef\u53e3\u3002 ep \u8981\u7ed1\u5b9a\u7684\u672c\u673a\u5730\u5740\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_34","text":"0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketbind_any","text":"\u7ed1\u5b9asocket\u672c\u673a\u4efb\u610f\u5730\u5740\u3002 int bind_any ( bool ipv6 ) const ;","title":" xxsocket::bind_any"},{"location":"api/reference/xxsocket-class/#_35","text":"ipv6 \u662f\u5426\u7ed1\u5b9a\u672c\u673a\u4efb\u610fIPv6\u5730\u5740","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_36","text":"0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketlisten","text":"\u5f00\u59cb\u76d1\u542c\u6765\u81eaTCP\u5ba2\u6237\u7aef\u7684\u63e1\u624b\u8bf7\u6c42\u3002 int listen ( int backlog = SOMAXCONN ) const ;","title":" xxsocket::listen"},{"location":"api/reference/xxsocket-class/#_37","text":"backlog \u6700\u5927\u76d1\u542c\u6570\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_38","text":"0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketaccept","text":"\u63a5\u53d7\u4e00\u4e2a\u5ba2\u6237\u7aef\u8fde\u63a5\u3002 xxsocket accept () const ;","title":" xxsocket::accept"},{"location":"api/reference/xxsocket-class/#_39","text":"\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684 xxsocket \u5bf9\u8c61\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketaccept_n","text":"\u975e\u963b\u585e\u65b9\u5f0f\u63a5\u53d7\u4e00\u4e2a\u5ba2\u6237\u7aef\u8fde\u63a5\u3002 int accept_n ( socket_native_type & new_sock ) const ;","title":" xxsocket::accept_n"},{"location":"api/reference/xxsocket-class/#_40","text":"new_sock \u8f93\u51fa\u53c2\u6570\uff0c\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\u5e95\u5c42socket\u53e5\u67c4\u5f15\u7528","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_41","text":"0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_42","text":"\u5982\u679c\u6b64\u51fd\u6570\u8fd4\u56de 0 \uff0c new_sock \u4f1a\u88ab\u8bbe\u7f6e\u4e3a\u975e\u963b\u585e\u6a21\u5f0f\u3002 \u8c03\u7528\u6b64\u51fd\u6570\u4e4b\u524d\uff0c\u8bf7\u624b\u52a8\u8c03\u7528 xxsocket::set_nonblocking \u5c06socket\u8bbe\u7f6e\u4e3a\u975e\u963b\u585e\u6a21\u5f0f\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsocketconnect","text":"\u5efa\u7acb\u8fde\u63a5\u3002 int connect ( const char * addr , u_short port ); int connect ( const endpoint & ep );","title":" xxsocket::connect"},{"location":"api/reference/xxsocket-class/#_43","text":"addr \u8fdc\u7a0b\u4e3b\u673aip\u5730\u5740\u3002 port \u8fdc\u7a0b\u4e3b\u673a\u7aef\u53e3\u3002 ep \u8fdc\u7a0b\u4e3b\u673a\u5730\u5740\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_44","text":"0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_45","text":"TCP: \u53d1\u8d77TCP\u4e09\u6b21\u63e1\u624b UDP: \u5efa\u7acb4\u5143\u7ec4\u7ed1\u5b9a","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsocketconnect_n","text":"\u5efa\u7acb\u8fde\u63a5\u3002 int connect_n ( const char * addr , u_short port , const std :: chrono :: microseconds & wtimeout ); int connect_n ( const endpoint & ep , const std :: chrono :: microseconds & wtimeout ); int connect_n ( const endpoint & ep );","title":" xxsocket::connect_n"},{"location":"api/reference/xxsocket-class/#_46","text":"addr \u8fdc\u7a0b\u4e3b\u673aip\u5730\u5740\u3002 port \u8fdc\u7a0b\u4e3b\u673a\u7aef\u53e3\u3002 ep \u8fdc\u7a0b\u4e3b\u673a\u5730\u5740\u3002 wtimeout \u5efa\u7acb\u8fde\u63a5\u7684\u8d85\u65f6\u65f6\u95f4\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_47","text":"0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_48","text":"TCP: \u53d1\u8d77TCP\u4e09\u6b21\u63e1\u624b UDP: \u5efa\u7acb4\u5143\u7ec4\u7ed1\u5b9a","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsocketconnect_n_1","text":"\u89e3\u9664socket\u548c\u8fdc\u7a0b\u4e3b\u673a\u76844\u5143\u7ec4\u7ed1\u5b9a\u3002 int disconnect () const ;","title":" xxsocket::connect_n"},{"location":"api/reference/xxsocket-class/#_49","text":"0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_50","text":"\u53ea\u7528\u4e8e SOCK_DGRAM (UDP) \u7c7b\u578bsocket\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsocketsend","text":"\u5411\u8fdc\u7aef\u53d1\u9001\u6307\u5b9a\u957f\u5ea6\u6570\u636e\u3002 int send ( const void * buf , int len , int flags = 0 );","title":" xxsocket::send"},{"location":"api/reference/xxsocket-class/#_51","text":"buf \u8981\u53d1\u9001\u6570\u636e\u7684\u8d77\u59cb\u5b57\u8282\u5730\u5740\u3002 len \u8981\u53d1\u9001\u6570\u636e\u7684\u957f\u5ea6\u3002 flags \u53d1\u9001\u6570\u636e\u5e95\u5c42\u6807\u8bb0\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_52","text":"==len : \u6210\u529f\uff0c < len \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketsend_n","text":"\u5728\u8d85\u65f6\u65f6\u95f4\u5185\u5c3d\u529b\u5411\u8fdc\u7aef\u53d1\u9001\u6307\u5b9a\u957f\u5ea6\u6570\u636e\u3002 int send_n ( const void * buf , int len , const std :: chrono :: microseconds & wtimeout , int flags = 0 );","title":" xxsocket::send_n"},{"location":"api/reference/xxsocket-class/#_53","text":"buf \u8981\u53d1\u9001\u6570\u636e\u7684\u8d77\u59cb\u5b57\u8282\u5730\u5740\u3002 len \u8981\u53d1\u9001\u6570\u636e\u7684\u957f\u5ea6\u3002 wtimeout \u53d1\u9001\u8d85\u65f6\u65f6\u95f4\u3002 flags \u53d1\u9001\u6570\u636e\u5e95\u5c42\u6807\u8bb0\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_54","text":"==len : \u6210\u529f\uff0c < len \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketrecv","text":"\u4ece\u5185\u6838\u53bb\u9664\u8fdc\u7a0b\u4e3b\u673a\u53d1\u9001\u8fc7\u6765\u7684\u6570\u636e\u3002 int recv ( void * buf , int len , int flags = 0 ) const ;","title":" xxsocket::recv"},{"location":"api/reference/xxsocket-class/#_55","text":"buf \u63a5\u6536\u6570\u636e\u7f13\u51b2\u533a\u3002 len \u63a5\u6536\u6570\u636e\u7f13\u51b2\u533a\u957f\u5ea6\u3002 flags \u63a5\u6536\u6570\u636e\u5e95\u5c42\u6807\u8bb0\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_56","text":"==len : \u6210\u529f\uff0c < len \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_57","text":"\u6b64\u51fd\u6570\u662f\u5426\u7acb\u5373\u8fd4\u56de\uff0c\u53d6\u51b3\u4e8esocket\u672c\u8eab\u662f\u5426\u662f \u975e\u963b\u585e\u6a21\u5f0f \u3002","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsocketrecv_n","text":"\u5728\u8d85\u65f6\u65f6\u95f4\u5185\u5c3d\u529b\u4ece\u5185\u6838\u53d6\u51fa\u6307\u5b9a\u957f\u5ea6\u6570\u636e\u3002 int recv_n ( void * buf , int len , const std :: chrono :: microseconds & wtimeout , int flags = 0 ) const ;","title":" xxsocket::recv_n"},{"location":"api/reference/xxsocket-class/#_58","text":"buf \u63a5\u6536\u6570\u636e\u7f13\u51b2\u533a\u3002 len \u63a5\u6536\u6570\u636e\u7f13\u51b2\u533a\u957f\u5ea6\u3002 wtimeout \u63a5\u6536\u8d85\u65f6\u65f6\u95f4\u3002 flags \u63a5\u6536\u6570\u636e\u5e95\u5c42\u6807\u8bb0\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_59","text":"==len : \u6210\u529f\uff0c < len \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketsendto","text":"\u5411\u8fdc\u7a0b\u4e3b\u673a\u53d1\u9001 DGRAM \uff08UDP\uff09\u6570\u636e\u3002 int sendto ( const void * buf , int len , const endpoint & to , int flags = 0 ) const ;","title":" xxsocket::sendto"},{"location":"api/reference/xxsocket-class/#_60","text":"buf \u5f85\u53d1\u9001\u6570\u636e\u7f13\u51b2\u533a\u3002 len \u5f85\u53d1\u9001\u6570\u636e\u7f13\u51b2\u533a\u957f\u5ea6\u3002 to \u53d1\u9001\u76ee\u6807\u5730\u5740\u3002 flags \u53d1\u9001\u6570\u636e\u5e95\u5c42\u6807\u8bb0\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_61","text":"==len : \u6210\u529f\uff0c < len \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketrecvfrom","text":"\u4ece\u5185\u6838\u53bb\u9664\u8fdc\u7a0b\u4e3b\u673a\u53d1\u9001\u8fc7\u6765\u7684\u6570\u636e\u3002 int recvfrom ( void * buf , int len , endpoint & peer , int flags = 0 ) const ;","title":" xxsocket::recvfrom"},{"location":"api/reference/xxsocket-class/#_62","text":"buf \u63a5\u6536\u6570\u636e\u7f13\u51b2\u533a\u3002 len \u63a5\u6536\u6570\u636e\u7f13\u51b2\u533a\u957f\u5ea6\u3002 peer \u63a5\u6536\u6570\u636e\u6765\u6e90\uff0c\u8f93\u51fa\u53c2\u6570\u3002 flags \u63a5\u6536\u6570\u636e\u5e95\u5c42\u6807\u8bb0\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_63","text":"==len : \u6210\u529f\uff0c < len \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_64","text":"\u6b64\u51fd\u6570\u662f\u5426\u7acb\u5373\u8fd4\u56de\uff0c\u53d6\u51b3\u4e8esocket\u672c\u8eab\u662f\u5426\u662f \u975e\u963b\u585e\u6a21\u5f0f \u3002","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsockethandle_write_ready","text":"\u7b49\u5f85socket\u53ef\u5199\u3002 int handle_write_ready ( const std :: chrono :: microseconds & wtimeout ) const ;","title":" xxsocket::handle_write_ready"},{"location":"api/reference/xxsocket-class/#_65","text":"wtimeout \u7b49\u5f85\u8d85\u65f6\u65f6\u95f4\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_66","text":"0 : \u8d85\u65f6\uff0c 1 : \u6210\u529f\uff0c < 0 : \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_67","text":"\u901a\u5e38\u5f53\u5185\u6838\u53d1\u9001\u7f13\u51b2\u533a\u6ca1\u6ee1\u7684\u60c5\u51b5\u4e0b\uff0c\u6b64\u51fd\u6570\u4f1a\u7acb\u5373\u8fd4\u56de\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsockethandle_read_ready","text":"\u7b49\u5f85socket\u53ef\u8bfb\u3002 int handle_read_ready ( const std :: chrono :: microseconds & wtimeout ) const ;","title":" xxsocket::handle_read_ready"},{"location":"api/reference/xxsocket-class/#_68","text":"wtimeout \u7b49\u5f85\u8d85\u65f6\u65f6\u95f4\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_69","text":"0 : \u8d85\u65f6\uff0c 1 : \u6210\u529f\uff0c < 0 : \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketlocal_endpoint","text":"\u83b7\u53d64\u5143\u7ec4\u901a\u4fe1\u7684\u672c\u5730\u5730\u5740\u3002 endpoint local_endpoint () const ;","title":" xxsocket::local_endpoint"},{"location":"api/reference/xxsocket-class/#_70","text":"\u8fd4\u56de\u672c\u5730\u5730\u5740\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_71","text":"\u5982\u679c\u6ca1\u6709\u8c03\u7528\u8fc7 xxsocket::connect \u6216\u8005TCP\u8fde\u63a53\u6b21\u63e1\u624b\u672a\u5b8c\u6210\uff0c\u90a3\u4e48\u8fd4\u56de\u7684\u5730\u5740\u662f 0.0.0.0","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsocketpeer_endpoint","text":"\u83b7\u53d64\u5143\u7ec4\u901a\u4fe1\u7684\u5bf9\u7aef\u5730\u5740\u3002 endpoint peer_endpoint () const ;","title":" xxsocket::peer_endpoint"},{"location":"api/reference/xxsocket-class/#_72","text":"\u8fd4\u56de\u672c\u5730\u5730\u5740\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_73","text":"\u5982\u679c\u6ca1\u6709\u8c03\u7528\u8fc7 xxsocket::connect \u6216\u8005TCP\u8fde\u63a53\u6b21\u63e1\u624b\u672a\u5b8c\u6210\uff0c\u90a3\u4e48\u8fd4\u56de\u7684\u5730\u5740\u662f 0.0.0.0","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsocketset_keepalive","text":"\u8bbe\u7f6eTCP\u5e95\u5c42\u534f\u8bae\u7684\u5fc3\u8df3\u53c2\u6570\u3002 int set_keepalive ( int flag = 1 , int idle = 7200 , int interval = 75 , int probes = 10 );","title":" xxsocket::set_keepalive"},{"location":"api/reference/xxsocket-class/#_74","text":"flag 1 : \u5f00\u542f\u5e95\u5c42\u534f\u8bae\u5fc3\u8df3\uff0c 0 : \u5173\u95ed\u3002 idle \u5f53\u5e94\u7528\u5c42\u6ca1\u6709\u4efb\u4f55\u6d88\u606f\u4ea4\u4e92\u540e\uff0c\u542f\u52a8\u5e95\u5c42\u534f\u8bae\u5fc3\u8df3\u63a2\u6d4b\u7684\u6700\u5927\u8d85\u65f6\u65f6\u95f4\uff0c\u5355\u4f4d\uff08\u79d2\uff09\u3002 interval \u5f53\u6ca1\u6709\u6536\u5230\u5fc3\u8df3\u56de\u5e94\u65f6\uff0c\u91cd\u590d\u53d1\u9001\u5fc3\u8df3\u63a2\u6d4b\u62a5\u65f6\u95f4\u95f4\u9694\uff0c\u5355\u4f4d\uff08\u79d2\uff09\u3002 probes \u5f53\u6ca1\u6709\u6536\u5230\u5fc3\u8df3\u56de\u5e94\u65f6\uff0c\u6700\u5927\u63a2\u6d4b\u6b21\u6570\uff0c\u8d85\u8fc7\u63a2\u6d4b\u6b21\u6570\u540e\uff0c\u4f1a\u89e6\u53d1\u5e94\u7528\u5c42\u8fde\u63a5\u65ad\u5f00\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_75","text":"0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_76","text":"// xxsocket-keepalive.cpp #include \"yasio/xxsocket.hpp\" using namespace yasio ; using namespace inet ; int main (){ xxsocket client ; if ( 0 == client . pconnect ( \"192.168.1.19\" , 80 )) { client . set_keepalive ( 1 , 5 , 10 , 2 ); } return 0 ; }","title":"\u793a\u4f8b"},{"location":"api/reference/xxsocket-class/#xxsocketreuse_address","text":"\u8bbe\u7f6esocket\u662f\u5426\u5141\u8bb8\u91cd\u7528\u5730\u5740\u3002 void reuse_address ( bool reuse );","title":" xxsocket::reuse_address"},{"location":"api/reference/xxsocket-class/#_77","text":"reuse \u662f\u5426\u91cd\u7528\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_78","text":"\u6b64\u51fd\u6570\u4e00\u822c\u7528\u4e8e\u670d\u52a1\u5668\u6216\u8005\u7ec4\u64ad\u76d1\u542c\u7aef\u53e3\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsocketexclusive_address","text":"\u662f\u5426\u660e\u786e\u4e0d\u5141\u8bb8\u5730\u5740\u91cd\u7528\uff0c\u4ee5\u4fdd\u62a4\u901a\u4fe1\u53cc\u65b9\u5b89\u5168\u3002 void exclusive_address ( bool exclusive );","title":" xxsocket::exclusive_address"},{"location":"api/reference/xxsocket-class/#_79","text":"exclusive true : \u4e0d\u5141\u8bb8\uff0c false : \u5141\u8bb8","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_80","text":"\u70b9\u51fb \u67e5\u770b winsock \u5b89\u5168\u62a5\u544a\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsocketset_optval","text":"\u8bbe\u7f6esocket\u9009\u9879\u3002 template < typename _Ty > int set_optval ( int level , int optname , const _Ty & optval );","title":" xxsocket::set_optval"},{"location":"api/reference/xxsocket-class/#_81","text":"level socket\u9009\u9879\u7ea7\u522b\u3002 optname \u9009\u9879\u7c7b\u578b\u3002 optval \u9009\u9879\u503c\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_82","text":"0 : \u6210\u529f\uff0c < 0 \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_83","text":"\u6b64\u51fd\u6570\u540cbsd socket setsockopt \u529f\u80fd\u76f8\u540c\uff0c\u53ea\u662f\u4f7f\u7528\u6a21\u677f\u5c01\u88c5\uff0c\u66f4\u65b9\u4fbf\u4f7f\u7528\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsocketget_optval","text":"\u8bbe\u7f6esocket\u9009\u9879\u3002 template < typename _Ty > _Ty get_optval ( int level , int optname ) const","title":" xxsocket::get_optval"},{"location":"api/reference/xxsocket-class/#_84","text":"level socket\u9009\u9879\u7ea7\u522b\u3002 optname \u9009\u9879\u7c7b\u578b\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_85","text":"\u8fd4\u56de\u9009\u9879\u503c\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_86","text":"\u6b64\u51fd\u6570\u540cbsd socket getsockopt \u529f\u80fd\u76f8\u540c\uff0c\u53ea\u662f\u4f7f\u7528\u6a21\u677f\u5c01\u88c5\uff0c\u66f4\u65b9\u4fbf\u4f7f\u7528\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsocketselect","text":"\u76d1\u542csocket\u5185\u6838\u4e8b\u4ef6\u3002 int select ( fd_set * readfds , fd_set * writefds , fd_set * exceptfds , const std :: chrono :: microseconds & wtimeout )","title":" xxsocket::select"},{"location":"api/reference/xxsocket-class/#_87","text":"readfds \u53ef\u8bfb\u4e8b\u4ef6\u63cf\u8ff0\u7b26\u6570\u7ec4\u3002 writefds \u53ef\u5199\u4e8b\u4ef6\u63cf\u8ff0\u7b26\u6570\u7ec4\u3002 exceptfds \u5f02\u5e38\u4e8b\u4ef6\u63cf\u8ff0\u7b26\u6570\u7ec4\u3002 wtimeout \u7b49\u5f85\u4e8b\u4ef6\u8d85\u65f6\u4e8b\u4ef6\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_88","text":"0 : \u8d85\u65f6\uff0c > 0 : \u6210\u529f\uff0c < 0 : \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketshutdown","text":"\u5173\u95edTCP\u4f20\u8f93\u901a\u9053\u3002 int shutdown ( int how = SD_BOTH ) const ;","title":" xxsocket::shutdown"},{"location":"api/reference/xxsocket-class/#_89","text":"how \u5173\u95ed\u901a\u9053\u7c7b\u578b\uff0c\u53ef\u4f20\u4ee5\u4e0b\u679a\u4e3e\u503c SD_SEND : \u53d1\u9001\u901a\u9053 SD_RECEIVE : \u63a5\u53d7\u901a\u9053 SD_BOTH : \u5168\u90e8\u5173\u95ed","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_90","text":"0 : \u6210\u529f\uff0c < 0 : \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketclose","text":"\u5173\u95edsocket\uff0c\u91ca\u653e\u7cfb\u7edf\u8d44\u6e90\u3002 void close ( int shut_how = SD_BOTH );","title":" xxsocket::close"},{"location":"api/reference/xxsocket-class/#_91","text":"shut_how \u5173\u95ed\u901a\u9053\u7c7b\u578b\uff0c\u53ef\u4ee5\u4f20\u4ee5\u4e0b\u679a\u4e3e\u503c SD_SEND : \u53d1\u9001\u901a\u9053 SD_RECEIVE : \u63a5\u53d7\u901a\u9053 SD_BOTH : \u5168\u90e8\u5173\u95ed SD_NONE : \u5168\u90e8\u5173\u95ed","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_92","text":"0 : \u6210\u529f\uff0c < 0 : \u5931\u8d25\uff0c\u901a\u8fc7 xxsocket::get_last_errno \u83b7\u53d6\u9519\u8bef\u7801\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_93","text":"\u5982\u679c shut_how != SD_NONE \uff0c\u6b64\u51fd\u6570\u4f1a\u5148\u8c03\u7528 shutdown \uff0c\u518d\u8c03\u7528\u5e95\u5c42 close \u3002","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsockettcp_rtt","text":"\u83b7\u53d6TCP\u8fde\u63a5\u7684RTT\u3002 uint32_t tcp_rtt () const ;","title":" xxsocket::tcp_rtt"},{"location":"api/reference/xxsocket-class/#_94","text":"\u8fd4\u56deTCP\u7684RTT\u65f6\u95f4\uff0c\u5355\u4f4d: \u5fae\u79d2 \u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketget_last_errno","text":"\u83b7\u53d6\u6700\u8fd1\u4e00\u6b21socket\u64cd\u4f5c\u9519\u8bef\u7801\u3002 static int get_last_errno ();","title":" xxsocket::get_last_errno"},{"location":"api/reference/xxsocket-class/#_95","text":"0 : \u65e0\u9519\u8bef\uff0c > 0 \u901a\u8fc7 xxsocket::strerror \u8f6c\u6362\u4e3a\u8be6\u7ec6\u9519\u8bef\u4fe1\u606f\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_96","text":"\u6b64\u51fd\u6570\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsocketset_last_errno","text":"\u8bbe\u7f6esocket\u64cd\u4f5c\u9519\u8bef\u7801\u3002 static void set_last_errno ( int error );","title":" xxsocket::set_last_errno"},{"location":"api/reference/xxsocket-class/#_97","text":"error \u9519\u8bef\u7801\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_98","text":"\u6b64\u51fd\u6570\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsocketnot_send_error","text":"\u5224\u65ad\u662f\u5426\u662f\u53d1\u9001\u65f6socket\u51fa\u73b0\u65e0\u6cd5\u7ee7\u7eed\u7684\u9519\u8bef\u3002 static bool not_send_error ( int error );","title":" xxsocket::not_send_error"},{"location":"api/reference/xxsocket-class/#_99","text":"error \u9519\u8bef\u7801\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_100","text":"true : socket\u6b63\u5e38\uff0c false : socket\u72b6\u6001\u5df2\u7ecf\u53d1\u751f\u9519\u8bef\uff0c\u5e94\u5f53\u5173\u95edsocket\u7ec8\u6b62\u901a\u8baf\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_101","text":"\u4ec5\u5f53\u53d1\u9001\u64cd\u4f5c\u8fd4\u56de\u503c < 0 \u65f6\uff0c\u8c03\u7528\u6b64\u51fd\u6570\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsocketnot_recv_error","text":"\u5224\u65ad\u662f\u5426\u662f\u63a5\u6536\u65f6socket\u51fa\u73b0\u65e0\u6cd5\u7ee7\u7eed\u7684\u9519\u8bef\u3002 static bool not_recv_error ( int error );","title":" xxsocket::not_recv_error"},{"location":"api/reference/xxsocket-class/#_102","text":"error \u9519\u8bef\u7801\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_103","text":"true : socket\u6b63\u5e38\uff0c false : socket\u72b6\u6001\u5df2\u7ecf\u53d1\u751f\u9519\u8bef\uff0c\u5e94\u5f53\u5173\u95edsocket\u7ec8\u6b62\u901a\u8baf\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_104","text":"\u4ec5\u5f53\u63a5\u6536\u64cd\u4f5c\u8fd4\u56de\u503c < 0 \u65f6\uff0c\u8c03\u7528\u6b64\u51fd\u6570\u3002","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#xxsocketstrerror","text":"\u5c06\u9519\u8bef\u7801\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u3002 static const char * strerror ( int error );","title":" xxsocket::strerror"},{"location":"api/reference/xxsocket-class/#_105","text":"error \u9519\u8bef\u7801\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_106","text":"\u9519\u8bef\u4fe1\u606f\u7684\u5b57\u7b26\u4e32\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketgai_strerror","text":"\u5c06 getaddrinfo \u9519\u8bef\u7801\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u3002 static const char * gai_strerror ( int error );","title":" xxsocket::gai_strerror"},{"location":"api/reference/xxsocket-class/#_107","text":"error \u9519\u8bef\u7801\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_108","text":"\u9519\u8bef\u4fe1\u606f\u7684\u5b57\u7b26\u4e32\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketresolve","text":"\u89e3\u6790\u57df\u540d\u5305\u542b\u7684\u6240\u6709\u5730\u5740\u3002 int resolve ( std :: vector < endpoint >& endpoints , const char * hostname , unsigned short port = 0 , int socktype = SOCK_STREAM );","title":" xxsocket::resolve"},{"location":"api/reference/xxsocket-class/#_109","text":"endpoints \u8f93\u51fa\u53c2\u6570\u3002 hostname \u57df\u540d\u3002 port \u7aef\u53e3\u3002 socktype socket\u7c7b\u578b\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_110","text":"0 : \u65e0\u9519\u8bef\uff0c > 0 \u901a\u8fc7 xxsocket::strerror \u8f6c\u6362\u4e3a\u8be6\u7ec6\u9519\u8bef\u4fe1\u606f\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketresolve_v4","text":"\u89e3\u6790\u57df\u540d\u5305\u542b\u7684IPv4\u5730\u5740\u3002 int resolve_v4 ( std :: vector < endpoint >& endpoints , const char * hostname , unsigned short port = 0 , int socktype = SOCK_STREAM );","title":" xxsocket::resolve_v4"},{"location":"api/reference/xxsocket-class/#_111","text":"endpoints \u8f93\u51fa\u53c2\u6570\u3002 hostname \u57df\u540d\u3002 port \u7aef\u53e3\u3002 socktype socket\u7c7b\u578b\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_112","text":"0 : \u65e0\u9519\u8bef\uff0c > 0 \u901a\u8fc7 xxsocket::strerror \u8f6c\u6362\u4e3a\u8be6\u7ec6\u9519\u8bef\u4fe1\u606f\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketresolve_v6","text":"\u89e3\u6790\u57df\u540d\u5305\u542b\u7684IPv6\u5730\u5740\u3002 int resolve_v6 ( std :: vector < endpoint >& endpoints , const char * hostname , unsigned short port = 0 , int socktype = SOCK_STREAM );","title":" xxsocket::resolve_v6"},{"location":"api/reference/xxsocket-class/#_113","text":"endpoints \u8f93\u51fa\u53c2\u6570\u3002 hostname \u57df\u540d\u3002 port \u7aef\u53e3\u3002 socktype socket\u7c7b\u578b\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_114","text":"0 : \u65e0\u9519\u8bef\uff0c > 0 \u901a\u8fc7 xxsocket::strerror \u8f6c\u6362\u4e3a\u8be6\u7ec6\u9519\u8bef\u4fe1\u606f\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketresolve_v4to6","text":"\u4ec5\u89e3\u6790\u57df\u540d\u5305\u542b\u7684IPv4\u5730\u5740\u5e76\u8f6c\u6362\u4e3aIPv6 V4MAPPED\u683c\u5f0f\u3002 int resolve_v4to6 ( std :: vector < endpoint >& endpoints , const char * hostname , unsigned short port = 0 , int socktype = SOCK_STREAM );","title":" xxsocket::resolve_v4to6"},{"location":"api/reference/xxsocket-class/#_115","text":"endpoints \u8f93\u51fa\u53c2\u6570\u3002 hostname \u57df\u540d\u3002 port \u7aef\u53e3\u3002 socktype socket\u7c7b\u578b\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_116","text":"0 : \u65e0\u9519\u8bef\uff0c > 0 \u901a\u8fc7 xxsocket::strerror \u8f6c\u6362\u4e3a\u8be6\u7ec6\u9519\u8bef\u4fe1\u606f\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketresolve_tov6","text":"\u89e3\u6790\u57df\u540d\u5305\u542b\u7684\u6240\u6709\u5730\u5740\uff0cIPv4\u5730\u5740\u4f1a\u8f6c\u6362\u4e3aIPv6 V4MAPPED\u683c\u5f0f\u3002 int resolve_tov6 ( std :: vector < endpoint >& endpoints , const char * hostname , unsigned short port = 0 , int socktype = SOCK_STREAM );","title":" xxsocket::resolve_tov6"},{"location":"api/reference/xxsocket-class/#_117","text":"endpoints \u8f93\u51fa\u53c2\u6570\u3002 hostname \u57df\u540d\u3002 port \u7aef\u53e3\u3002 socktype socket\u7c7b\u578b\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_118","text":"0 : \u65e0\u9519\u8bef\uff0c > 0 \u901a\u8fc7 xxsocket::strerror \u8f6c\u6362\u4e3a\u8be6\u7ec6\u9519\u8bef\u4fe1\u606f\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#xxsocketgetipsv","text":"\u83b7\u53d6\u672c\u673a\u652f\u6301\u7684IP\u534f\u8bae\u6808\u6807\u5fd7\u4f4d\u3002 static int getipsv ();","title":" xxsocket::getipsv"},{"location":"api/reference/xxsocket-class/#_119","text":"ipsv_ipv4 : \u672c\u673a\u53ea\u652f\u6301IPv4\u534f\u8bae\u3002 ipsv_ipv6 : \u672c\u673a\u53ea\u652f\u6301IPv6\u534f\u8bae\u3002 ipsv_dual_stack : \u672c\u673a\u652f\u6301IPv4\u548cIPv6\u53cc\u6808\u534f\u8bae\u3002","title":"\u8fd4\u56de\u503c"},{"location":"api/reference/xxsocket-class/#_120","text":"\u5f53\u8fd4\u56de\u503c\u652f\u6301\u53cc\u6808\u534f\u8bae\u662f\uff0c\u7528\u6237\u5e94\u5f53\u59cb\u7ec8\u4f18\u5148\u4f7f\u7528IPv4\u901a\u4fe1\uff0c \u4f8b\u5982 \u667a\u80fd\u624b\u673a\u8bbe\u5907 \u5728\u540c\u65f6\u5f00\u542f wifi \u548c \u8702\u7a9d\u7f51\u7edc \u65f6\uff0c\u5c06\u4f1a\u4f18\u5148\u9009\u62e9wifi\uff0c \u800cwifi\u901a\u5e38\u662fIPv4\uff0c\u8be6\u89c1: https://github.com/halx99/yasio/issues/130","title":"\u6ce8\u610f"},{"location":"api/reference/xxsocket-class/#_121","text":"// xxsocket-ipsv.cpp #include <vector> #include \"yasio/xxsocket.hpp\" using namespace yasio ; using namespace yasio :: inet ; int main (){ const char * host = \"github.com\" ; std :: vector < ip :: endpoint > eps ; int flags = xxsocket :: get_ipsv (); if ( flags & ipsv_ipv4 ) { xxsocket :: resolve_v4 ( eps , host , 80 ); } else if ( flags & ipsv_ipv6 ) { xxsocket :: resolve_tov6 ( eps , host , 80 ); } else { std :: cerr << \"Local network not available! \\n \" ; } return 0 ; }","title":"\u793a\u4f8b"},{"location":"api/reference/xxsocket-class/#xxsockettraverse_local_address","text":"\u679a\u4e3e\u672c\u673a\u5730\u5740\u3002 static void traverse_local_address ( std :: function < bool ( const ip :: endpoint & ) > handler );","title":" xxsocket::traverse_local_address"},{"location":"api/reference/xxsocket-class/#_122","text":"handler \u679a\u4e3e\u5730\u5740\u56de\u8c03\u3002","title":"\u53c2\u6570"},{"location":"api/reference/xxsocket-class/#_123","text":"// xxsocket-traverse.cpp #include <vector> #include \"yasio/xxsocket.hpp\" using namespace yasio ; using namespace yasio :: inet ; int main (){ int flags = 0 ; xxsocket :: traverse_local_address ([ & ]( const ip :: endpoint & ep ) -> bool { switch ( ep . af ()) { case AF_INET : flags |= ipsv_ipv4 ; break ; case AF_INET6 : flags |= ipsv_ipv6 ; break ; } return ( flags == ipsv_dual_stack ); }); YASIO_LOG ( \"Supported ip stack flags=%d\" , flags ); return flags ; }","title":"\u793a\u4f8b"},{"location":"api/reference/xxsocket-class/#_124","text":"io_service Class","title":"\u8bf7\u53c2\u9605"}]}